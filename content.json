{"pages":[{"title":"简历","text":"求职信息岗位：Java开发工程师 薪资：10k – 11k 基本信息 姓名：阳浩 性别：男 年龄：24 手机：137-5585-4643 邮箱：ooyhao1996@163.com 英语水平 CET6 专业技能 熟练掌握Java基础，集合及面向对象思想。 熟练使用Spring，SpringBoot，SpringMVC，Mybatis及MybatisPlus。 熟练使用Redis，RabbitMQ，shiro，MySQL及常见的SQL优化策略。 熟悉使用SpringCloudAlibaba，Maven。 熟练使用Git，Idea，Postman，Navicat等开发管理工具。 熟悉前端框架EasyUI，LayUI，会使用VueJs。 工作经历 2018.06 – 至今 上海丽人丽妆网络科技有限公司 项目经验 2019.06 – 至今 用户运营平台 描述：负责全公司所有运营的店铺数据与品牌方进行对接。 模块：由于项目的特殊性，需要一个人负责N个店铺的某一个特定业务接口的对接。从数据的准备，数据的组装计算到数据的传输和日志记录，都是独立设计和开发。根据品牌方与我方数据分析人员讨论好接口文档，根据所提供的接口文档进行设计开发，到后续的测试上线。至今（2019.12），已经负责对接了七个店铺的数据，包括有天猫的销售数据和退款数据等。 收获：通过这个项目，对公司的业务场景有更深刻了解，同时对与第三方公司进行接口对接更加熟练，也增强了与人沟通的能力。本项目是以SpringBoot，SpringMVC，Mybatis及Redis为基础，配合以SpringTask形式在服务器定时执行。同时使用多线程提高接口的性能。 2018.09 – 2019.05 OMS订单管理系统 描述：oms系统负责公司最主要的订单业务。包括订单下载，订单按店铺分表解析，营销活动按规则添加赠品，按配置拆单分仓，发货单推送仓库，客服工作台等。 负责： 客服工作台智能地址识别功能开发。 售后数据日报，店铺数据日报以及店小蜜数据日报等。开发数据报表用于运营后续统计和分析客户购买行为的特点。 负责售后客户退款退款的二次开发和升级。 营销活动的二期升级开发。 负责采购模块的采购订单和采购退货单的审核通知（钉钉&amp;邮件）。 负责开发智能库存自动化分配管理，以及库存的实时查询。 收获：通过对本项目的开发，更加熟练了公司的业务，同时更加深入的了解了Redis缓存，RabbitMQ消息队列的实际工作场景。以及对Spring，SpringMVC，Mybatis以及EasyUI更加的熟练使用。对服务(系统)之间调用Dubbo的使用更加理解和熟练。 2018.06 – 2018.09 人事考试管理系统 描述：本项目是专门为人事部门开发的一个考试系统。 负责：主要负责考试题目的导入，普通试卷的生产和随机试卷的生产。同时支持同一张试卷进行多次考试。 收获：本项目使用的基础技术栈是SpringBoot，SpringMVC，MybatisPlus，Redis。本项目是进公司接触到的第一个项目，是真正了解到企业系统如何运作的项目。从需求到开发，测试，上线。通过这个项目让我真正的能够胜任某个模块的单独开发，同时也提高了与测试人员交流沟通的能力。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Integer 类","text":"源码说明Java中Integer是基本数据类型int的包装类。也就是每一个Integer对象包含一个int类型的属性，是抽象类Number类的子类，位于java.lang包下。 部分源码： 123456789101112131415public final class Integer extends Number implements Comparable&lt;Integer&gt; { @Native public static final int MIN_VALUE = 0x80000000; @Native public static final int MAX_VALUE = 0x7fffffff; private final int value; public Integer(int value) { this.value = value; } public Integer(String s) throws NumberFormatException { this.value = parseInt(s, 10); }} 通过源码可以看出，最小值用十六进制表示为0x80000000。使用二进制表示为1000 0000 0000 0000 0000 0000 0000 0000.最大值用十六进制表示为0x7fffffff。 使用二进制表示为 0111 1111 1111 1111 1111 1111 1111 1111. 由于一个字节占用8位，而Integer的最大值和最小值都是占用32位，由此而知，int类型是占用4个字节的。最小值为 -2的31次方。最大值为2的31次方-1. 为何0x80000000可以表示最小值，可以参考这篇文章 原码，反码和补码. 面试题我们首先来看一道题： 12345678910111213public class IntegerTest { public static void main(String[] args) { Integer i1 = 127; Integer i2 = new Integer(127); Integer i3 = 127; System.out.println(i1 == i2); System.out.println(i1.equals(i2)); System.out.println(i1 == i3); Integer ii1 = 128; Integer ii2 = 128; System.out.println(ii1 == ii2); }} 结果是： 1234falsetruetruefalse 不知道你们有没有答对呢？下面我们来看一下反编译过来的代码： 12345678910111213public class IntegerTest { public static void main(String[] args) { Integer i1 = Integer.valueOf(127); Integer i2 = new Integer(127); Integer i3 = Integer.valueOf(127); System.out.println((i1 == i2)); System.out.println(i1.equals(i2)); System.out.println((i1 == i3)); Integer ii1 = Integer.valueOf(128); Integer ii2 = Integer.valueOf(128); System.out.println((ii1 == ii2)); }} 可以看出 i1 和 i3 都调用了Integer.valueOf方法，这其实就是自动装箱的过程.Java基本数据自动转为包装类的过程称为自动装箱。 我们看一下valueOf()方法的源码： 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);} 我们看到其中有一个IntegerCache类，我们再看一下源码： 1234567891011121314151617181920212223242526private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) {} } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); assert IntegerCache.high &gt;= 127; } private IntegerCache() {}} 可以看出其中有一步是：sun.misc.vm.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;). 实际上在Java5中引入这个特性的时候，范围固定在-128到127之间。后来在Java6后，最大映射到 java.lang.Integer.IntegerCache.high, 可以使用JVM的启动参数设置最大值。(通过JVM的启动参数 -XX:AutoBoxCacheMax=size 修改) 我们暂时把自定义部分去掉，如下： 1234567891011121314151617private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { int h = 127; high = h; cache = new Integer[(high - low) + 1];//127-(-128)+1=256 int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); assert IntegerCache.high &gt;= 127; } private IntegerCache() {}} 以上就是Integer缓存池的源代码。为什么长度要加上1呢？因为需要把整数0算上。我们通过源码可以看到，对于Integer类型，内部有一个缓存池，实现把-128到127之间的对象先创建出来了。所以如果是通过调用valueOf()方法创建并且在-128到127之间的数，自动返回缓存中的对象，而由于自动装箱调用的就是valueOf方法。 下面我们再次来看下面的题： 123456789Integer i1 = 127;Integer i2 = new Integer(127);Integer i3 = 127;System.out.println(i1 == i2);//falseSystem.out.println(i1.equals(i2));//trueSystem.out.println(i1 == i3);//trueInteger ii1 = 128;Integer ii2 = 128;System.out.println(ii1 == ii2);//false 由于i1,i3 是自动装箱，调用了Integer.valueOf(),同时在默认返回下-128–127范围内，所以走的是缓存，故i1==i3为true （等于号是直接比较地址的）。而i2是自己创建对象，不是调用valueOf方法的，那么就不会走缓存，所以 i1 == i2 是false。那么为什么i1.equals(i2) 也会是true。我们看一下Integer类 valueOf()源码： 123456public boolean equals(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intValue(); } return false;} 通过源码可以看出，首先判断传入的是否为Integer 类型。 是：判断其intValue()值与当前对象的value是否相等 是：返回true。 否：返回false。 其他：返回false。 总结，使用Integer i = 9 这种方式来定义; 只要给值在-128到127之间，调用自动装箱方法valueOf,这个值都是作为下标处理的，取的是Integer缓存池的对象。 装箱拆箱过程自动装箱： 1Integer i = 2; 上面的代码会自动装箱。编译之后如下： 1Integer i = Integer.valueOf(2); 自动拆箱： 123int i = 2;Integer ii = 2;System.out.println(i == ii); 上面的代码经过自动拆箱。即编译之后变成如下： 123int i = 2;Integer ii = Integer.valueOf(2);System.out.println(i == ii.intValue()) 试题+1在牛客上看到这样一个问题，如下： 【JAVA】条件 a == (Integer) 1 &amp;&amp; a == (Integer) 2有可能为true吗？ 代码可以表示为： 123456public static void main(String[] args){ int a = 1; if(a == (Integer)1 &amp;&amp; a == (Integer)2){ System.out.println(\"true\"); }} 乍一看，肯定不可能啊，但是仔细想想呢？ 我们先看一下其反编译过来的代码： 123int a = 1;if (a == Integer.valueOf(1).intValue() &amp;&amp; a == Integer.valueOf(2).intValue()) System.out.println(true); 可以看出来，a == (Integer)1 ,这句其实是先将1进行装箱，再进行拆箱与a进行比较。但是由于自动装箱走缓存同时1和2又在-128到127之间，所以我们可以从缓存进行入手。 如下： 12345678910111213141516171819202122public static void main(String[] args) throws Exception { //1.获取Integer类的Class类对象 Class&lt;Integer&gt; integerClass = Integer.class; //2.获取Integer类内部的类的对象,只有一个，取0，就是IntegerCache类 Class&lt;?&gt; integerCacheClass = integerClass.getDeclaredClasses()[0]; //3.获取IntegerCache类的cache属性对象 Field cacheField = integerCacheClass.getDeclaredField(\"cache\"); //4.设置可访问 cacheField.setAccessible(true); //5.由于IntegerCache类是static的，在加载的时候会走IntegerCache类中的static代码块 //把cache数组给初始化，所以我们后面是可以直接操作的 Integer[] o = (Integer[])cacheField.get(integerCacheClass); //0 下标是示-128对象,127下标的是-1对象，128下标的是0对象，129和130下标的分别是1对象 和 2对象 //6. 将下标为130的2对象 更新为 下标为129的1对象. o[130] = o[129]; System.out.println(Arrays.toString(o)); int a = 1; //此时由于使用了类型装换，会进行自动装箱，再拆箱比较，所以1和2获取到的都是缓存中的1对象。再拆箱比较，就成立了。 if (a == (Integer)1 &amp;&amp; a == (Integer)2){ System.out.println(true); }} 上面的代码即可在最后输入true. 主要是利用反射来修改IntegerCache的内容。如果前面自动装箱走缓存理解了，那么这里也可以理解，主要是配合反射来修改原来已经初始化好的缓存中的内容。 数组截图： 另： byte类型占用1个字节。 short类型占用2个字节。 char类型占用2个字节。 int类型占用4个字节。 long类型占用8个字节。 float类型占用4个字节。7到8位有效数字。 double类型占用8个字节。16到17位有效数字。","link":"/2020/04/05/%E5%9F%BA%E7%A1%80/Integer/"},{"title":"LinkedList 源码分析","text":"LinkedList 部分参考来源: https://www.cnblogs.com/aflyun/p/6481274.html https://www.cnblogs.com/ysocean/p/8657850.html 图片来源于 ysocean博主博客的图片 LinkedList 介绍LinkedList 的继承结构: 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{} LinkedList 底层是使用链表实现的. 通过源码可以看出，具有 prev 和 next ，则是一个双向链表。除了当链表之外，我们也可以当成栈(先进后出)，队列(先进先出)和双端队列进行操作。不是线程安全的，继承自AbstractSequentialList ,实现 List, Deque, Cloneable, Serializable. LinkedList继承自AbstractSequentialList. Sequential的中文意思就是按顺序的，故：LinkedList是不支持随机访问（ArrayList是支持随机访问的）。 LinkedList实现了List接口，即拥有List的所有特点 LinkedList实现了Deque(双端队列)接口，所以可以实现双端队列的作用。 LinkedList实现了Cloneable接口，即覆盖了clone()方法，可以实现克隆。 LinkedList实现了Serializable接口，这意味LinkedList是支持序列化的，能通过序列化去传输。 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} LinkedList 的方法总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Get Elementpublic E getFirst() {}public E getLast() {}public E get(int index) {}public E peek() {}public E element() {}public E peekFirst() {}public E peekLast() {}public E pollFirst() {}public E pollLast() {}// Remove Elementpublic E pop() {}public E poll() {}public E removeFirst() {}public E removeLast() {}public boolean remove(Object o) {}public E remove(int index) {}public E remove() {}public boolean removeFirstOccurrence(Object o) {}public boolean removeLastOccurrence(Object o) {}// Add Elementpublic void addFirst(E e) {}public void addLast(E e) {}public boolean add(E e) {}public void add(int index, E element) {}public boolean addAll(Collection&lt;? extends E&gt; c) {}public boolean addAll(int index, Collection&lt;? extends E&gt; c) {}public E set(int index, E element) {}public boolean offer(E e) {}public boolean offerFirst(E e) {}public boolean offerLast(E e) {}public void push(E e) {}// Search Elementpublic boolean contains(Object o) {}public int size() {}Node&lt;E&gt; node(int index) {}public int indexOf(Object o) {}public int lastIndexOf(Object o) {}// otherpublic void clear() {}public Object[] toArray() {}public &lt;T&gt; T[] toArray(T[] a) {} LinkedList 源码分析Get Element123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 获取第一个节点，如果集合为empty，则抛出NoSuchElementException */public E getFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;}/** * 获取最后一个节点，如果List为null，则抛出NoSuchElementException */public E getLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;}/** * 返回指定下标的元素 */public E get(int index) { //检查元素下标是否合法 checkElementIndex(index); return node(index).item;}/** * 检索返回第一个元素,但不删除，与element()方法不同，如果元素为null,则返回null，不抛出异常 */public E peek() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;}/** * 检索返回第一个元素，但不删除，如果List为null.抛出 NoSuchElementException */public E element() { return getFirst();}/** * 检索返回第一个元素，但不删除，若List为empty,则返回null */public E peekFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;}/** * 检索返回最后一个元素，但不删除，若List为empty，则返回null */public E peekLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;}/** * 检索返回第一个元素，但不删除，如果List为empty，则返回null */public E pollFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);}/** * 检索返回最后一个元素，但不删除，如果List为empty，则返回null */public E pollLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);} Remove Element123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 删除并返回第一个元素，等同于removeFirst(). */public E pop() { return removeFirst();}/** * 删除并返回第一个元素。如果List为null，则返回null */public E poll() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);}/** * 删除第一个元素，并返回数据，如果List为空，则抛出NoSuchElementException */public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);}/** * 删除最后一个元素，并返回数据，如果List为空，则抛出NoSuchElementException */public E removeLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);}/** * 删除第一个符合要求的元素，如果不存在，则不进行任何改变。即：删除符合的元素中下标最小的那个。 * 分为null 和 not null。返回是否包含指定值（true和false） */public boolean remove(Object o) { if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false;}/** * 移除并返回指定下标的元素（后面的元素全部左移，对于链表来说，无需手动移动）。 * 如果下标不合法，则抛出 IndexOutOfBoundsException */public E remove(int index) { checkElementIndex(index); return unlink(node(index));}/** * 检索返回第一个元素，并移除，如果List为null，则抛出NoSuchElementException */public E remove() { return removeFirst();}/** * 移除第一个命中的元素，（从头到尾遍历，即顺序遍历），若不包含，则不改变 */public boolean removeFirstOccurrence(Object o) { return remove(o);}/** * 移除最后一个命中的元素，（从尾遍历到头，即倒序遍历），若不包含，则不改变 */public boolean removeLastOccurrence(Object o) { if (o == null) { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { if (x.item == null) { unlink(x); return true; } } } else { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { if (o.equals(x.item)) { unlink(x); return true; } } } return false;} Add Element[图片来源于YSOcean] addFirst(E e) 将指定元素添加到链表头部 addLast(E e) 和 add(E e) 将指定元素添加到链表尾部. add(int index, E element) 将指定的元素插入到链表的指定位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 在头部插入一个元素 */public void addFirst(E e) { linkFirst(e);}/** * 在尾部插入一个元素，与add()方法作用一致 */public void addLast(E e) { linkLast(e);}/** * add方法默认将 元素添加到链表最后，等同于 addLast() */public boolean add(E e) { linkLast(e); return true;}/** * 将元素添加到指定下标处，原下标位置元素及所有右边元素均向后移动（链表无需手动操作） * 如果下边不合法，则抛出IndexOutOfBoundsException */public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));}/** * 添加指定集合中的所有元素到当前链表的最后。 */public boolean addAll(Collection&lt;? extends E&gt; c) { return addAll(size, c);}/** * 添加指定集合中的所有元素到当前集合中。 * 若给定集合为null，则抛出 NullPointerException * 若元素下标不合法，则抛出 IndexOutOfBoundsException */public boolean addAll(int index, Collection&lt;? extends E&gt; c) { //检查下标是否违法 checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) //给定集合为empty，则返回false return false; //分为添加到链表最后，和添加到链表中 Node&lt;E&gt; pred, succ; if (index == size) { succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true;}/** * 将元素替换指定下标的元素。如果元素不合法，则抛出IndexOutOfBoundsException。 */public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;}/** * 添加一个元素到尾部 */public boolean offer(E e) { return add(e);}// Deque operations/** * 添加一个元素到头部 */public boolean offerFirst(E e) { addFirst(e); return true;}/** * 添加一个元素到尾部 */public boolean offerLast(E e) { addLast(e); return true;}/** * 添加一个元素到首部 */public void push(E e) { addFirst(e);} Search Element1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 判断当前元素是否在集合中，（可以为null） * (o==null ? e==null : o.equals(e)) */public boolean contains(Object o) { return indexOf(o) != -1;}/** * 查找第一个符合的元素的下标(使用顺序遍历)，如果没有，则返回-1。 * 即：返回所有符合的元素的最小下标。 */public int indexOf(Object o) { int index = 0; //判断当前元素是否为空（这里可以看出，LinkedList是可以存储null的） if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } //如果没有找到，则返回-1 return -1;}/** * 查找最后一个符合的元素的下标(使用倒序遍历），如果没有，则返回-1 * 即：返回符合要求的所有元素的最大下标。 */public int lastIndexOf(Object o) { int index = size; if (o == null) { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { index--; if (x.item == null) return index; } } else { for (Node&lt;E&gt; x = last; x != null; x = x.prev) { index--; if (o.equals(x.item)) return index; } } return -1;} other1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 集合元素的个数 */public int size() { return size;}/** * 移除集合中的所有元素。 */public void clear() { for (Node&lt;E&gt; x = first; x != null; ) { Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; } first = last = null; size = 0; modCount++;}/** * 将链表转化为数组 */public Object[] toArray() { Object[] result = new Object[size]; int i = 0; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; return result;}/** * 将集合填充到给定数据中，如果给定的数组大小小于集合元素的个数，则全部替换。 * 如果数组元素大于集合元素个数，则将集合大小的下标的元素设置为null， * 如果给定数据为null，则抛出NullPointerException * * 集合为：{\"A\",\"B\",\"C\",\"D\"}. * 若数组为：{\"AA\",\"BB\",\"CC\",\"DD\",\"EE\",\"FF\"}, ==&gt; {\"A\",\"B\",\"C\",\"D\",null,\"FF\"} * 若数组为：{\"AA\",\"BB\",\"CC\"} 或 {\"AA\",\"BB\",\"CC\",\"DD\"} ==&gt; {\"A\",\"B\",\"C\",\"D\"} * */@SuppressWarnings(\"unchecked\")public &lt;T&gt; T[] toArray(T[] a) { //如果数据的长度小于当前集合元素的个数，创建一个size大小的数组 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size); int i = 0; Object[] result = a; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; if (a.length &gt; size) //如果数组大小大于元素个数，将size位置上的元素设置为null a[size] = null; return a;} ArrayList与LinkedList遍历性能比较ArrayList性能测试1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void test(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100000; i++) { list.add(i); } long start1 = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) { list.get(i); } long end1 = System.currentTimeMillis(); System.out.println(\"普通for：\"+(end1 - start1)); long start2 = System.currentTimeMillis(); for (Integer i : list) {} long end2 = System.currentTimeMillis(); System.out.println(\"增加for：\"+(end2 - start2)); long start3 = System.currentTimeMillis(); ListIterator&lt;Integer&gt; listIterator = list.listIterator(); while(listIterator.hasNext()){ listIterator.next(); } long end3 = System.currentTimeMillis(); System.out.println(\"ListIterator:\"+(end3 - start3)); long start4 = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ iterator.next(); } long end4 = System.currentTimeMillis(); System.out.println(\"iterator:\"+(end4-start4));}//测试结果/**普通for:1增加for:3ListIterator:5iterator:1*/ LinkedList性能测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Testpublic void test(){ LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; 100000; i++) { linkedList.add(i); } //使用普通for循环遍历 long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; linkedList.size(); i++) { linkedList.get(i); } long endTime = System.currentTimeMillis(); System.out.println(\"普通for循环：\"+(endTime-startTime)); //使用增强for循环遍历 long start1 = System.currentTimeMillis(); for (Integer i : linkedList) {} long end1 = System.currentTimeMillis(); System.out.println(\"增加for循环：\"+(end1 - start1)); //使用ListIterator ListIterator&lt;Integer&gt; iterator = linkedList.listIterator(); long start = System.currentTimeMillis(); while(iterator.hasNext()){ iterator.next(); } long end = System.currentTimeMillis(); System.out.println(\"使用ListIterator遍历:\"+(end - start)); Iterator&lt;Integer&gt; iter = linkedList.iterator(); long start2 = System.currentTimeMillis(); while(iter.hasNext()){ iter.next(); } long end2 = System.currentTimeMillis(); System.out.println(\"使用iterator:\"+(end2 - start2));}//测试结果/**普通for循环:3807增加for循环:2使用ListIterator遍历:1使用iterator:1*/ 通过上述测试可以知道，用100000条数据来测试，可以发现遍历所消耗的时间大部分都相似，但是唯独LinkedList 在使用普通for循环的时候，花费的时间是其他的上千倍。 代码很简单，就是使用LinkedList 的 get(int index) 方法，遍历出所有的元素。但是需要注意的是，get(int indx) 方法每次都要遍历该索引之前的所有元素，这句话这么理解： 比如我们使用一个LinkedList 集合，存储A,B,C,D四个元素，总共需要四次遍历： 第一次遍历打印A : 还需要遍历一次。 第二次遍历打印B : 需要先找到A，然后再找到B打印。 第三次遍历打印C : 需要先找到A，然后找到B，然后找到C打印。 第四次遍历打印D : 需要先找到A，然后找到B，然后找到C，最后找到D。 这样如果集合元素越多，查找的时间就越久。如上述测试结果所示。 下面使用YSOcean 博主的图再解释一下： 普通for循环：每次遍历一个索引的元素之前，都要访问之间所有的索引。 迭代器：每次访问一个元素后，都会用游标记录当前访问元素的位置，遍历一个元素，记录一个位置。 总结 LinkedList的实现是基于双向链表，实现了List和Deque接口。实现了所有可选的列表操作，并允许所有元素（包括null） LinkedList是线程不安全的，只能在单线程的情况下适合使用 这个类的iterator和返回的迭代器listIterator方法是fail-fast, 要注意ConcurrentModificationException. LinkedList实现了Serializable接口，支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。 在查找和删除元素是，都分为元素是null和不为null两种情况来处理，LinkedList中允许元素为null. LinkedList是基于链表的，LinkedList没有扩容方法，插入元素默认就自动扩容了。 LinkedList还实现了栈和队列的操作方法，因此也可以作为栈，队列和双端队列来使用。 12345678910//栈的特性是:先进后出可以使用 pop()和push()实现栈 pop() 删除并返回第一个元素。 push() 添加一个元素到首部。//队列的特性是:先进先出 可以使用 addFirst(), addLast(), removeFirst()和 removeLast() addFirst() 在头部插入元素 addLast() 在尾部插入元素 removeFirst() 在头部移除一个元素并返回 removeLast() 在尾部移除一个元素并返回 LinkedList是基于链表实现的，因此插入删除效率高，查询效率低，不支持随机访问（只能进行遍历）","link":"/2020/04/25/%E5%9F%BA%E7%A1%80/LinkedList/"},{"title":"六、Mybatis中的# 和 $","text":"Mybatis中的# 和 $ 准备数据库12345678910111213141516171819202122232425262728SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tb_role-- ----------------------------DROP TABLE IF EXISTS `tb_role`;CREATE TABLE `tb_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色id', `role_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名称', `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色描述', `status` int(1) NOT NULL COMMENT '角色状态，0:启用，1:禁用', `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间', `create_user` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '创建人', `modify_time` datetime(0) NULL DEFAULT NULL COMMENT '修改时间', `modify_user` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '修改人', PRIMARY KEY (`id`) USING BTREE, INDEX `index_role_name`(`role_name`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- ------------------------------ Records of tb_role-- ----------------------------INSERT INTO `tb_role` VALUES (1, 'admin', '超级管理员', 0, '2019-03-01 11:33:09', 'system', '2019-03-05 09:17:41', 'admin');INSERT INTO `tb_role` VALUES (2, 'develop', '开发人员', 0, '2019-03-01 17:19:55', 'admin', '2019-04-04 10:02:37', 'admin');INSERT INTO `tb_role` VALUES (3, 'testing', '用于测试人员测试', 0, '2019-03-01 22:14:33', 'admin', '2019-04-04 10:03:05', 'admin');INSERT INTO `tb_role` VALUES (5, 'guest', '运营', 1, '2019-03-16 10:59:38', 'admin', '2019-04-06 10:46:30', 'admin');INSERT INTO `tb_role` VALUES (6, 'root', 'root', 0, '2019-09-19 09:46:03', 'admin', '2019-09-19 09:55:25', 'admin'); ​ 本案例代码基于前面小节的整合案例，所以此处不再赘述整合代码，如有需要，可以参考前面的SSM整合。 $ 和 # 执行原理下面我们只讨论#{}与${}的差别. 使用#{}接收参数： 1select * from tb_role where role_name = #{roleName} 我们看一下上面sql的打印SQL结果： 使用${}接收参数： 1select * from tb_role where role_name = '${roleName}' 对应的SQL执行结果： 如上两个SQL的执行结果，可以看出： #{value} 会进行SQL预编译，即把参数替换成 ?占位符。 ${} 只是进行简单的字符串替换。 SQL 注入百度百科：所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 正是由于上述差别，${}可能会导致SQL注入，下面我们来看一下： 12-- 传入参数：a' or '1' = '1select * from tb_role where role_name = #{roleName} 执行结果如下，无法找到对应的数据： 而当我们使用${} : 12-- 传入参数：a' or '1' = '1select * from tb_role where role_name = '${roleName}' 所以，如果使用${} ，可以发现，sql注入是成功的，这样就把数据库中的所有数据，这里只是演示了查询的注入，最多可能会导致数据泄露，如果注入的是更新、删除操作，后果将不堪设想，所以，在这种情况下我们不能使用$ 来接收参数。 说明：我们使用 mybatis 编写 SQL 语句时，难免会使用模糊查询的方法，mybatis 提供了两种方式 #{} 和 ${} 。 #{value} 在预处理时，会把参数部分用一个占位符 ? 替代，其中 value 表示接受输入参数的名称。能有效解决 SQL 注入问题 ${} 表示使用拼接字符串，将接受到参数的内容不加任何修饰符拼接在 SQL 中，使用${}拼接 sql，将引起 SQL 注入问题。 少不了$​ 有些人看到前面的 ${} 会导致SQL注入问题，可能会认为，那以后的开发就不再使用 ${}了， 全部使用#{}.正所谓存在就有价值，所以，有些情况，${} 还是需要的使用的。 例如：当我们需要通过参数传递来指定排序字段的时候，我们需要使用${}. 12-- 参数：role_nameselect * from tb_role ORDER BY #{orderRoleName} 执行结果如下： 我们可以看出使用#{} 并没有进行排序，此时我们将其更换如下： 12-- 参数：role_nameselect * from tb_role ORDER BY ${orderRoleName} 执行结果： 说明： 如果需要动态的传递查询字段和排序字段等情况，我们需要使用$来进行字符串替换。 1select ${orderRoleName} from tb_role ORDER BY ${orderRoleName} 查询结果： 总结： 能使用#{}的地方，尽量使用 如查询字段，排序字段等，则需要使用${} 附：这里顺带提下防止sql注入的几种方式(可能不止这几种): (jdbc使用 PreparedStatement代替Statement， PreparedStatement 不仅提高了代码的可读性和可维护性.而且也提高了安全性，有效防止sql注入； 在程序代码中使用正则表达式过滤参数。使用正则表达式过滤可能造成注入的符号，如’ –等 在页面输入参数时也进行字符串检测和提交时进行参数检查，同样可以使用正则表达式，不允许特殊符号出现。 部分参考自:https://www.cnblogs.com/weixuqin/p/9522802.html","link":"/2020/01/18/SSM/mybatis/7Mybatis%E4%B8%AD%E7%9A%84%E4%BA%95%E5%92%8C%E6%98%9F/"},{"title":"九、SpringCache","text":"Caching (缓存)可以存储经常会用到的数据，这样，每次需要的时候，这些信息都是立即可用的。这里，我们会介绍Spring的缓存抽象。SpringCache 是对缓存解决方案的抽象，并且它对缓存功能提供了声明式的支持，能够与多种流行的缓存实现集成。在Spring中可以使用 ConcurrentMapCacheManager 来实现简单的缓存，但是ConcurrentMapCacheManager是基于java.util.concurrent.ConcurrentHashMap，那么这就意味着它是基于内存的，生命周期是与应用关联的，可以用于开发和测试，但是对于生产级别的大型企业级应用程序，这可能不是一个理想的选择。 ConcurrentMapCacheManager 开启EnableCaching注解，默认是没有开启的。 配置CacheManager 1234567891011@Configuration@EnableCachingpublic class CachingConfig { /*配置缓存管理器，使用SpringCache的ConcurrentMapCacheManager*/ @Bean public CacheManager cacheManager(){ ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager(); return cacheManager; }} 切换成RedisCacheManager123456789/*配置缓存管理器，使用Redis来进行缓存处理*/@Beanpublic CacheManager cacheManager2(JedisConnectionFactory jedisConnectionFactory){ RedisCacheManager.RedisCacheManagerBuilder builder = RedisCacheManager .RedisCacheManagerBuilder .fromConnectionFactory(jedisConnectionFactory); return builder.build();} Spring Cache 注解注解声明规则 注解 描述 @Cacheable 表明Spring在调用方法之前，首先应该在缓存中查找方法的返回值。如果这个值能够找到，就会返回缓存中的值。否则的话，这个方法就会被调用，返回值会放到缓存之中。 @CachePut 表明Spring应该将方法的返回值放到缓存中。在方法的调用前并不会检查缓存，方法始终都会被调用 @CacheEvict 表明Spring应该在缓存中清除一个或多个条目 @Caching 这是一个分组的注解，能够同时应用多个其他的缓存的注解 @Cacheable的源码 123456789101112131415161718@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable { @AliasFor(\"cacheNames\") String[] value() default {}; @AliasFor(\"value\") String[] cacheNames() default {}; String key() default \"\"; String keyGenerator() default \"\"; String cacheManager() default \"\"; String cacheResolver() default \"\"; String condition() default \"\"; String unless() default \"\"; boolean sync() default false;} @CachePut的源码 1234567891011121314151617@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut { @AliasFor(\"cacheNames\") String[] value() default {}; @AliasFor(\"value\") String[] cacheNames() default {}; String key() default \"\"; String keyGenerator() default \"\"; String cacheManager() default \"\"; String cacheResolver() default \"\"; String condition() default \"\"; String unless() default \"\";} 填充缓存​ 我们可以看到，@Cacheable和@CachePut注解都可以填充缓存，但它们的工作方式略有不同。 @Cacheable首先在缓存中查找条目，如果找到了匹配的条目，那么就不会对方法进行了调用。如果没有找到匹配的条目，方法会被调用并且返回值要放到缓存之中。而@CachePut并不会在缓存中查询匹配的值，目标方法总是会被调用，并将返回值添加到缓存之中。 @Cacheable和@CachePut共有的属性 属性 类型 描述 value String[] 要使用的缓存名称 condition String SpEL表达式，如果得到的值是false的话，不会将缓存应用到方法调用上 key String SpEL表达式，用来计算自定的缓存key unless String SpEL表达式，如果得到的值是true的话，返回值不会放到缓存之中。 ​ @Cacheable与@CachePut提供了两个属性用以实现条件化：unless和condition，这两个属性都接受一个SpEL表达式。如果unless属性的SpEL表示式计算结果为true，那么缓存方法返回的数据就不会放到缓存中。与之类似，如果condition属性的SpEL表达式计算结果为false，那么对于这个方法缓存就会被禁用掉。 ​ 表面上来看，unless和condition属性做的是相同的事情。但是，这里有一点细微的差别。unless属性只能阻止将对象放进缓存，但是在这个方法调用的时候，依然会去缓存中查询，如果找到匹配的值，就会返回找到的值。与之不同的，如果condition的表达式计算结果为false，那么在这个方法调用的过程中，缓存是被禁用的。就是说，不会去缓存中查询，同时也不会将返回值放到缓存中。 自定义缓存key​ @Cacheable和@CachePut都有一个名为key的属性，这个属性能够替换默认的key，它是通过一个SpEL表达式计算得到的。任意的SpEL表达式都是可行的，但是更常见的场景是所定义的表达式与存储在缓存中的值有关，据此计算得到key。 缓存元数据 表达式 描述 #root.args 传递给缓存方法的参数，形式为数组 #root.caches 该方法执行时所对应的缓存，形式为数组 #root.target 目标对象 #root.targetClass 目标对象的类，是#root.target.class的简写形式 #root.method 缓存方法 #root.methodName 缓存方法的名字，是#root.method.name的简写形式 #result 方法调用的返回值（不能用在@Cacheable注解上） #Argument 任意的方法参数名（如#argName）或参数索引(如#a0或#p0) 移除缓存条目​ @CacheEvict 并不会往缓存中添加任何东西。相反，如果带有@CacheEvict注解的方法被调用的话，那么会有一个或更多的条目会在缓存中移除。 注意：与@Cacheable 和 @CachePut不同，@CacheEvict 能够应用在返回值为void 的方法上，而@Cacheable 和 @CachePut 需要非void的返回值，它将会作为放在缓存中的条目。因为@CacheEvict只是将条目从缓存中移除，因为它可以放在任意的方法上，甚至是void方法。 @CacheEvict 注解的属性 value String[] 要使用的缓存名称 key String SpEL表示式,用来计算自定义的缓存key condition String SpEL表达式，如果得到的值是false的，缓存不会应用到方法调用上 allEntries boolean 如果为true的话，特定缓存的所有条目都会被移除掉 beforeInvocation boolean 如果为true的话，在方法调用之前移除条目。如果为false（默认值）的话，在方法成功调用之后再移除条目","link":"/2020/01/29/SSM/spring4x/9SpringCache/"},{"title":"10.SpringBoot之系统启动任务","text":"SpringBoot之系统启动任务 什么是系统启动任务呢？其实就是在系统启动的时候需要执行的任务代码，而后面都不会再执行到的，就成为系统启动任务。 监听器在 Servlet/Jsp 项目中，如果涉及到系统任务，例如在项目启动阶段要做一些数据初始化操作，这些操作有一个共同的特点，只在项目启动时进行，以后都不再执行，这里，容易想到web基础中的三大组件（ Servlet、Filter、Listener ）之一 Listener ，这种情况下，一般定义一个 ServletContextListener，然后就可以监听到项目启动和销毁，进而做出相应的数据初始化和销毁操作，例如下面这样： 12345678910public class IListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { //在这里做数据初始化操作 } @Override public void contextDestroyed(ServletContextEvent sce) { //在这里做数据备份操作 }} 当然，这是基础 web 项目的解决方案，如果使用了 Spring Boot，那么我们可以使用更为简便的方式。Spring Boot 中针对系统启动任务提供了两种解决方案，分别是 CommandLineRunner 和 ApplicationRunner，分别来看。 CommandLineRunner使用CommandLineRunner 创建系统启动任务还是很简单的。如下,我们创建两个系统启动任务： ICommandLineRunner1: 123456789@Component@Order(99)//Order数值越大，优先级越低public class ICommandLineRunner1 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"ICommandLineRunner1:\"+ Arrays.toString(args)); System.out.println(\"系统启动时执行ICommandLineRunner1\"); }} ICommandLineRunner2: 12345678910@Component@Order(98)//Order数值越大，优先级越低public class ICommandLineRunner2 implements CommandLineRunner { @Override public void run(String... args) throws Exception { //参数其实就是main方法的args System.out.println(\"ICommandLineRunner2:\"+Arrays.toString(args)); System.out.println(\"系统启动时执行ICommandLineRunner2\"); }} 首先， 我们通过自定义类实现CommandLineRunner接口并是实现run方法。run方法中定义的就是系统启动时需要执行的代码。 Order指明其执行的优先级顺序。Order的数值最大，优先级越低。 args参数，其实就是SpringBoot的main方法传入的参数。 其他的就不再赘述，说一下参数的问题。 参数可以在main方法的代码中指定。 可以在idea开发环境中指定。多个参数换行指定。 可以在jar包启动的时候执行。多个参数空格指定。（打包 maven package） ApplicationRunnerApplicationRunner大致与CommandLineRunner 是一样的，但是在接收参数的时候，有些不同，下面我们实验一下。首先自定义类实现ApplicationRunner 并实现其run方法，同样，run方法就是系统启动任务需要执行的方法。 IApplicationRunner1: 123456789101112131415161718192021@Component@Order(99)public class IApplicationRunner1 implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取启动的所有参数 String[] sourceArgs = args.getSourceArgs(); System.out.println(\"sourceArgs:\"+Arrays.toString(sourceArgs)); //获取无Key值的参数 List&lt;String&gt; stringList = args.getNonOptionArgs(); System.out.println(\"NonOptionArgs:\"+stringList); Set&lt;String&gt; optionNames = args.getOptionNames(); System.out.println(\"========================\"); //获取有key值的参数 for (String optionName : optionNames){ System.out.println(\"optionName:\" + optionName + \":\" + args.getOptionValues(optionName)); } System.out.println(\"IApplicationRunner1结束\"); }} IApplicationRunner2: 12345678910111213141516171819202122@Component@Order(98)public class IApplicationRunner2 implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取启动的所有参数 String[] sourceArgs = args.getSourceArgs(); System.out.println(\"sourceArgs:\" + Arrays.toString(sourceArgs)); //获取无Key值的参数 List&lt;String&gt; stringList = args.getNonOptionArgs(); System.out.println(\"NonOptionArgs:\" + stringList); Set&lt;String&gt; optionNames = args.getOptionNames(); System.out.println(\"========================\"); //获取有key值的参数 for (String optionName : optionNames) { System.out.println(\"optionName:\" + optionName + \":\" + args.getOptionValues(optionName)); } System.out.println(\"IApplicationRunner2结束\"); }} 同样，我们利用maven package进行打包，然后看结果,命令如下： 12java -jar springboot-applicationrunner-0.0.1-SNAPSHOT.jar --name=ooyhao--address=ooyhao.github.io 三国演义 红楼梦 其中，--name=ooyhao 和 --address=ooyhao.github.io 就是有key的参数。三国演义 和 红楼梦 就是无key值得参数。 执行结果： 通过结果同样可以看出： sourceArgs 表示的是全部参数。 nonOptionsArgs 表示的是无key的参数。 optionNames 表示所有key 的name。 拓展可以查看：https://www.javaboy.org/2019/0415/springboot-commandlinerunner.html","link":"/2020/03/04/SSM/springboot/10.SpringBoot%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1/"},{"title":"12.SpringBoot之WebMvcConfigurer","text":"SpringBoot之WebMvcConfigurer 路径映射就是当我们只需要在Controller对请求进行页面跳转，但是不需要进行数据处理。可以使用更简单的路径映射。 我们这里借助动态页面来实现： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 如下：自定义配置类并实现WebMvcConfigurer. 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/ooyhao\").setViewName(\"ooyhao\"); }} 定义ooyhao.html页面：classpath:/resources/templates/ooyhao.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello springboot&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 浏览器访问localhost:8080/ooyhao 就可以看到页面了。","link":"/2020/03/04/SSM/springboot/12.SpringBoot%E4%B9%8BWebMvcConfigurer/"},{"title":"11.SpringBoot之整合三大基础组件","text":"SpringBoot之整合三大基础组件 三大组件其实就是我们常说的 Servlet，Filter，和Listener。下面我们看一下在SpringBoot如何整合这三大组件。 定义三大组件定义servlet： 12345678@WebServlet(urlPatterns = \"/iServlet\")public class IServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"IServlet\"); }} 定义Filter： 12345678910@WebFilter(\"/*\")public class IFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"iFilter\"); filterChain.doFilter(servletRequest,servletResponse); }} 定义Listener： 12345678910111213@WebListenerpublic class IRequestListener implements ServletRequestListener { @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(\"requestInitialized\"); } @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\"requestDestroyed\"); }} 这里说明一下：Serlvet就其实相当于SpringMvc里面用 @RequestMapping 注解标注了的方法。 应用组件上面我们已经定义好了三个组件，接下来，我们来看一下如何注册到SpringBoot中去。 1234567@SpringBootApplication@ServletComponentScan(basePackages = \"com.hao.springbootservlet.component\")public class SpringbootServletApplication { public static void main(String[] args) { SpringApplication.run(SpringbootServletApplication.class, args); }} 我们用@ServletComponentScan 去扫描到这三大组件，虽然名字是一servlet开头的，但是可以把这三大组件都扫到。 测试我们通过浏览器访问localhost:8080/iSerlvet 得到如下结果：","link":"/2020/03/04/SSM/springboot/11.SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88%E4%B8%89%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"},{"title":"13.SpringBoot之类型转换","text":"SpringBoot之类型转换 类型转换就是在前端传入的和controller中接收的不一样的时候，我们需要使用相应的类型转换器来实现自动转换功能。如下： 实例12345678@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello(Date birth){ System.out.println(birth); return \"success\"; }} 当我们使用 localhost:8080/hello?birth=2020-01-01 访问接口的时候，会抛出错误： 大致就是：不能将String类型转为要求的Date类型。 下面我们定义一个日期类型转换器并加入到Spring容器中去： 12345678910111213141516@Componentpublic class DateConverter implements Converter&lt;String, Date&gt; { @Override public Date convert(String s) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); if (s != null &amp;&amp; !\"\".equals(s)){ try { return simpleDateFormat.parse(s); } catch (ParseException e) { e.printStackTrace(); } } return null; }} 再次访问就可以正常运行了。","link":"/2020/03/04/SSM/springboot/13.SpringBoot%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"04.SpringBoot 之 JSON解析","text":"SpringBoot 之 JSON解析 Jackson数据转换@RestController 注解相当于 @Controller + @ResponseBody. 我们都知道，使用了上面的注解，我们就可以返回JSON格式的数据，那么是为什么呢？ HttpMessageConverter, 这是一个消息转换工具，有两方面的功能： 将服务端返回的对象序列化成JSON字符串。 将前端传来的JSON字符串反序列化成Java对象。 所有的JSON生成都离不开相关的HttpMessageConverter。 SpringMVC自动配置了Jackson和Gson的HttpMessageConverter，SpringBoot中又对此做了自动化配置。所以，如果用户使用jackson和gson的话，没有其他配置，则只需要添加依赖即可。 12org.springframework.boot.autoconfigure.http.GsonHttpMessageConvertersConfigurationorg.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration 实例：当我们正常使用Controller返回时间类型的时候。得到的是这样的： 123456{ \"id\": 1, \"username\": \"tom-0\", \"address\": \"ooyhao.github.io\", \"birthday\": \"2020-02-29T15:54:03.065+0000\"} 那么我们如果需要格式化时间呢，需要如何做呢，有两种方式。 第一种：在属性上面使用@JsonFormat注解进行指定，这种可以单独指定某一个属性的格式，可以自由设定。 12345678@Datapublic class User { private Integer id; private String username; private String address; @JsonFormat(pattern = \"yyyy-MM-dd\") private Date birthday;} 第二种：全局配置，统一管理：当我们只需要进行格式时间等时，以下两种方式任选其一即可。这样配置，将相当于出去的格式是统一的。 1234567891011121314151617//全局配置@Beanpublic MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(){ MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); ObjectMapper mapper = new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); converter.setObjectMapper(mapper); return converter;}//可以使用上面的配置，也可以使用下面的配置@Beanpublic ObjectMapper objectMapper(){ ObjectMapper mapper = new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); return mapper;} 当然；如果我们大部分情况下，需要的是全局配置统一格式，但是有时候也不乏需要定制格式呢。但怎么办？可以通过上面两者结合的方式，既指定@JsonFormat 也使用全局配置MapperJackson2HttpMessageConverter。此时生效的是使用@JsonFormat。所以，定制化的配置会覆盖全局配置的。 Gson 数据转换上面使用的是Jackson，下面我们使用一下Gson。 由于SpringBoot默认使用的是Jackson，那么如何进行切换呢？ 12345678910111213141516&lt;!--导入spring web mvc 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; Gson的全局配置该如何配置呢？ 123456789101112131415@Beanpublic GsonHttpMessageConverter gsonHttpMessageConverter(){ GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setDateFormat(\"yyyy-MM-dd\"); converter.setGson(gsonBuilder.create()); return converter;}// 上下二者任选其一，都可以做到统一格式化时间的效果@Beanpublic Gson gson(){ GsonBuilder builder = new GsonBuilder(); builder.setDateFormat(\"yyyy-MM-dd\"); return builder.create();} 如上所述，是利用Gson统一配置时间格式化信息。 FastJson数据转换Jackson和Gson，在SpringBoot中都做了默认的支持，即有响应的自动配置类，但是FastJson，springBoot并没有做默认的支持，所以需要我们手动来配置 HttpMessageConverter. 在我们没有配置FastJson的HttpMessageConverter的时候，同时也把Jackson和Gson依赖去除时。 12345678910111213141516171819&lt;!--导入spring web mvc 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--GSON--&gt;&lt;!--&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt;--&gt; 访问： 12345678910111213141516@RestControllerpublic class UserController { @GetMapping(\"/users\") public List&lt;User&gt; getAllUser(){ List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setId(i + 1); user.setUsername(\"tom-\" + i); user.setAddress(\"ooyhao.github.io\"); user.setBirthday(new Date()); users.add(user); } return users; }} 访问上面这段代码会抛出异常，也可以看出，No converter found for return value of type. 但是我们可以发现，使用Jackson或是Gson的时候，我们是可以正常访问的。这就是SpringBoot自动配置的功劳了。下面我们使用FastJson： 首先引入依赖： 123456 &lt;!--引入FastJSON--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; 配置HttpMessageConverter： 12345678@Beanpublic FastJsonHttpMessageConverter fastJsonHttpMessageConverter(){ FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setDateFormat(\"yyyy-MM-dd HH:mm:ss\"); converter.setFastJsonConfig(fastJsonConfig); return converter;} 我们再次访问就正常了，同时时间也进行了格式化。 同时FastJson也支持单个字段格式化： 12345678@Datapublic class User { private Integer id; private String username; private String address; @JSONField(format = \"yyyy-MM-dd\") private Date birthday;}","link":"/2020/03/04/SSM/springboot/4.SpringBoot%E4%B9%8BJSON%E8%A7%A3%E6%9E%90/"},{"title":"05.SpringBoot之静态资源","text":"SpringBoot之静态资源 默认静态资源访问路径SpringBoot默认配置的静态资源路径：ResourceProperties 源码 12345678@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties { private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" };} 上面四个目录都可以作为静态资源目录，如下： 我们通过http://localhost:8080/a.js，http://localhost:8080/b.js ， http://localhost:8080/c.js 和 http://localhost:8080/d.js都可以访问到响应的js文件。 一般使用默认的static目录。static 目录和 templates 目录 在创建项目勾选web组件时会自动创建，但是创建项目的时候没有勾选web组件则需要自己手动创建。 自定义静态资源访问目录我们先来看一下ResourceProperties 源码： 123456789101112@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties { private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" }; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;} 我们可以看出，是通过 staticLocations 属性执行的。同时可以看到这个类用 @ConfigurationProperties注解标识了，以``spring.resources为前缀。即可以自己通过spring.resources.staticLocations` 进行自定义。 123spring.resources.static-locations=classpath:/hao/# 静态资源访问URLspring.mvc.static-path-pattern=/** 上面配置的路径，就与下面进行对应了： 通过 http://localhost:8080/hao.js即可访问了。 当然，通过java配置类也可以进行配置指定： 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/hao/\"); }} 上面的Java配置的方式和配置文件配置的方式是一样的，可以实现相同的效果。","link":"/2020/03/04/SSM/springboot/5.SpringBoot%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"},{"title":"06.SpringBoot 之文件上传","text":"SpringBoot 之文件上传 文件上传对于日常开发其实也比较常见的，存在于一些业务里面需要长传一些文件。比如说用户中心的用户头像，招聘App中的简历文件等。那么下面我们就来看看springboot中如何实现文件上传。 通过表单上传文件首先，我们先使用普通的表单来上传文件。 1234&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 后端接受和配置信息： application.properties 12345# 文件的最大大小spring.servlet.multipart.max-file-size=5MBspring.servlet.multipart.enabled=true# 最大请求大小spring.servlet.multipart.max-request-size=10MB 配置类： 12345678@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //配置文件存储位置。 registry.addResourceHandler(\"/img/**\").addResourceLocations(\"file:c://upload/img/\"); }} 说明：这里我们通过配置的方式来指定文件的访问路径，因为上传的文件将放在此目录下。 controller： 123456789101112131415161718192021222324252627282930@RestControllerpublic class FileUploadController { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy/MM/dd/\"); @PostMapping(\"/upload\") public String upload(MultipartFile file, HttpServletRequest request) { String format = simpleDateFormat.format(new Date()); String path = \"c:/upload/img/\" + format; File folder = new File(path); if (!folder.exists()) { folder.mkdirs(); } String originalFilename = file.getOriginalFilename(); String suffix = originalFilename.substring(originalFilename.lastIndexOf(\".\")); String newFileName = UUID.randomUUID().toString() + suffix; try { file.transferTo(new File(folder, newFileName)); String scheme = request.getScheme();//协议 http 或 https String serverName = request.getServerName();//服务器名称 int serverPort = request.getServerPort();//服务器端口 String url = scheme + \"://\" + serverName + \":\" + serverPort + \"/img/\" + format + newFileName; return url; } catch (IOException e) { e.printStackTrace(); } return \"error\"; }} 通过Ajax上传文件通过Ajax实现文件上传，后端代码不用修改，只需要前端有普通的表单提交修改为Ajax提交了。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;script src=\"jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;body&gt;&lt;input type=\"file\" id=\"file\" name=\"file\" &gt;&lt;input type=\"button\" value=\"上传\" onclick=\"uploadFile()\" &gt;&lt;div id=\"result\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; function uploadFile() { var file = $(\"#file\")[0].files[0]; var formData = new FormData(); formData.append(\"file\",file); $.ajax({ type:'post', url:'/upload', processData:false, contentType:false, data:formData, success:function (msg) { $(\"#result\").html(msg); } }); }&lt;/script&gt;&lt;/html&gt; 这里通过$(&quot;#file&quot;) 获取指定id的组件，取第0个转为DOM对象。获取该DOM对象的files属性。同时只取其中的第一个文件。上传我们利用FormData对象来协助。如果有更多的属性，可以继续通过append来添加。 后端代码不需要改变。 多文件上传12345&lt;!--两种不同的多文件上传--&gt;&lt;form action=\"/uploads\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"files\" multiple&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 上面是同一个File中支持多个文件上传，后端需要使用数组来接收。另一种多文件上传的方式就是多个单文件上传的控件。则controller形参中需要定义多个MultipartFile对象。如下： 123456789101112131415161718192021222324252627282930/** * 多文件上传。 * 如果使用的不是多文件输入框，而是多个文件输入款。则将其改为多个MultipartFile进行标识。 * public String uploads(MultipartFile file1, MultipartFile file1, HttpServletRequest request) */@PostMapping(\"/uploads\")public String uploads(MultipartFile[] files, HttpServletRequest request) { String format = simpleDateFormat.format(new Date()); String path = \"c:/upload/img/\" + format; File folder = new File(path); if (!folder.exists()) { folder.mkdirs(); } for (int i = 0; i &lt; files.length; i++) { MultipartFile file = files[i]; String originalFilename = file.getOriginalFilename(); String suffix = originalFilename.substring(originalFilename.lastIndexOf(\".\"));//文件后缀 String newFileName = UUID.randomUUID().toString() + suffix;//文件新名字 try { file.transferTo(new File(path, newFileName)); String fileName = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + \"/img/\" + format + newFileName; System.out.println(fileName); } catch (IOException e) { e.printStackTrace(); return \"error\"; } } return \"success\";}","link":"/2020/03/04/SSM/springboot/6.SpringBoot%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"07.SpringBoot之@ControllerAdvice","text":"SpringBoot之@ControllerAdvice @ControllerAdvice@ControllerAdvice 注解有以下三个方面的作用： 处理全局异常 预设全局数据 请求参数预处理 异常处理进行异常处理，我们在捕捉到指定的异常之后，可以跳转到指定的页面或是返回响应的数据，这里以跳转页面为例。错误页面如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:text=\"${error}\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 全局异常处理： 1234567891011121314151617181920212223@ControllerAdvicepublic class MyCustomException { /** * 文件大小超过限制的异常处理 * @param e */ @ExceptionHandler(value = {MaxUploadSizeExceededException.class}) public ModelAndView myException(MaxUploadSizeExceededException e) throws IOException { ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"error\",\"上传文件大小超过限制\"); modelAndView.setViewName(\"myerror\"); return modelAndView; } /*@ExceptionHandler(value = {MaxUploadSizeExceededException.class}) public void myException(MaxUploadSizeExceededException e, HttpServletResponse response) throws IOException { response.setContentType(\"text/html;charset=utf-8\"); PrintWriter writer = response.getWriter(); writer.write(\"上传文件大小超出限制\"); writer.flush(); writer.close(); }*/} 上面的两种方式分别以定制错误页面和返回数据为示例。 预设全局数据预设全局数据，其实就是在某一个地方定义好数据之后，其他Controller中都可以获取到的。 12345678910@ControllerAdvicepublic class GlobalData { @ModelAttribute(value = \"info\") public Map&lt;String,Object&gt; myData(){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\",\"hao.yang\"); map.put(\"address\",\"ooyhao.github.io\"); return map; }} controller中获取： 12345678@GetMapping(\"/hello\")public String hello(Model model){ Map&lt;String, Object&gt; map = model.asMap(); for (Map.Entry&lt;String,Object&gt; ma : map.entrySet()){ System.out.println(ma); } return \"hello\";} 打印结果：info={address=ooyhao.github.io, name=hao.yang} 请求参数预处理我们定义两个实体类： 1234567891011@Datapublic class Book { private String name; private Double price;}@Datapublic class Author { private String name; private Integer age;} 可以看出，在Book和Author实体中，都有一个相同的属性，为name。编写Controller。 12345@PostMapping(\"/book\")public void addBook(Book book,Author author){ System.out.println(book); System.out.println(author);} 此时我们同事使用PostMan测试，结果如下： 测试结果： 可以看出，这样的结果是有问题的，不管Book还是Author的name都是两个值拼接起来的，那么在不改变实体类的情况下保证没有问题呢？ 下面我们使用@ControllerAdvice 和 @ModelAttribute来实现： 首先，修改Controller类： 12345678@RestControllerpublic class BookController { @PostMapping(\"/book\") public void addBook(@ModelAttribute(\"b\") Book book,@ModelAttribute(\"a\") Author author){ System.out.println(book); System.out.println(author); }} 随后，我们利用@ControllerAdvice和@InitBinder注解，来按前缀进行指定。定义如下。 1234567891011@ControllerAdvicepublic class GlobalData { @InitBinder(\"a\") public void initA(WebDataBinder binder){ binder.setFieldDefaultPrefix(\"a.\"); } @InitBinder(\"b\") public void initB(WebDataBinder binder){ binder.setFieldDefaultPrefix(\"b.\"); }} 此时我们测试时，前端传的数据就需要改变一下。","link":"/2020/03/04/SSM/springboot/7.SpringBoot%E4%B9%8B@ControllerAdvice/"},{"title":"09.SpringBoot 之跨域问题","text":"SpringBoot 之跨域问题 部分参考自：https://www.javaboy.org/2019/0412/springboot-cors.html 同源策略很多人对跨域有一种误解，以为这是前端的事，和后端没有关系。事实上不是这样的，说到跨域，就不得不说说浏览器的同源策略。同源策略是有NetScape提出的一个著名的安全策略，它是浏览器最核心也是最基本的安全能，现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指 协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身是没有问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是JSONP，JSONP虽然能解决跨域但是有一个很大的局限性，那就是只支持GET请求，不支持其它类型的请求，而今天我们说的CORS（跨域源资源共享）（CORS Cross-origin Resource Sharing） 是一个 W3C标准，它是一份浏览器技术的规范，提供了Web服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是JSONP模板的现代版。 在Spring框架中，对于CORS也提供了相应的解决方案，今天我们就来看看SpringBoot中如何实现CORS。 实践首先我们创建两个项目，一个项目(springboot-cors1)的端口就设置为默认的8080，另一个(springboot-cors2)端口设置为8081. 在springboot-cors1中定义如下内容： 1234567@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello(){ return \"hello cors!\"; }} 启动项目。我们接下来把请求页面写在项目springboot-cors2中,(导入jQuery)： classpath:/resources/static/index.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;input type=\"button\" value=\"get\" onclick=\"getData()\"&gt;&lt;script&gt; function getData() { $.get('http://localhost:8080/hello',function (msg) { $(\"#app\").html(msg); }); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 启动项目，请求： 我们F12签到springboot-cors2的前端请求页面抛出错误了。No 'Access-Control-Allow-Origin Header is present on the requested resource'. 因为同源问题，请求无法发送成功。 我们在SpringBoot使用CORS可以在不修改前端的任何代码时，实现跨域，那么接下来我们看看在springboot-cors1中需要如何进行配置。 方式一： 12345678@RestControllerpublic class HelloController { @GetMapping(\"/hello\") @CrossOrigin(origins = \"http://localhost:8081\")//跨域 public String hello(){ return \"hello cors!\"; }} 我们可以使用注解@CrossOrigin 注解并指定源来实现跨域，但是这种情况下，如果一个Controller中有很多方法，肯定不可能手动在每一个方法上加注解。所以我们可以将注解加到类上： 123456789@RestController@CrossOrigin(origins = \"http://localhost:8081\")//跨域 可以加载类上，也可以加上方法上public class HelloController { @GetMapping(\"/hello\")// @CrossOrigin(origins = \"http://localhost:8081\")//跨域 public String hello(){ return \"hello cors!\"; }} 此时我们测试，可以发现，可以正常访问了。 但是我们在项目中，肯定不可能将所有的接口都放在一个Controller中，有没有一种方法可以全局配置呢？当然。我们可以通过下面这种方法： 1234567891011@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\").allowedOrigins(\"http://localhost:8081\") .allowedHeaders(\"*\") .allowedMethods(\"*\")//支持所有的方法 .maxAge(30 * 1000)//有效时间 ; }} 我们可以删除在Controller中使用注解的方式。而是自定义一个配置类并实现WebMvcConfigurer接口，同时重写addCorsMappings方法。如上，我们就可以全局进行配置了。此时我们再次访问，成功。如下： 存在的问题了解了整个CORS的工作过程之后，我们通过Ajax发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为one-click attack 或者 session riding，通常缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，举个例子： 假如一家银行用以运行转账操作的URL地址如下：http://icbc.com/aa?bb=cc，那么，一个恶意攻击者可以在另一个网站上放置如下代码：&lt;img src=”http://icbc.com/aa?bb=cc&quot; &gt; ，如果用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会遭受损失。 基于此，浏览器在实际操作中，会对请求进行分类，分为简单请求，预先请求，带凭证的请求等，预先请求会首先发送一个options探测请求，和浏览器进行协商是否接受请求。默认情况下跨域请求是不需要凭证的，但是服务端可以配置要求客户端提供凭证，这样就可以有效避免csrf攻击。","link":"/2020/03/04/SSM/springboot/9.SpringBoot%E4%B9%8B%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"title":"二、Docker安装单机版Nacos","text":"Docker安装单机版Nacos 安装wget1234# 安装wgetyum install wget# 查询版本wget --version 安装Git1234# 安装gityum install git# 查询git版本git --version 安装curl 部分参考：https://www.cnblogs.com/suidouya/p/7387861.html 获取安装包，从网上直接下载或者其他途径，这里使用wget 1wget https://curl.haxx.se/download/curl-7.55.1.tar.gz 解压安装包 1tar -zxf curl-7.55.1.tar.gz 进入解压后的包 1cd curl-7.55.1 配置，指定安装路径，这里是/usr/local/curl 12./configure --prefix=/usr/local/curlmake 安装 1sudo make install 查询版本 1curl --version 安装docker-compose 方式一 1234567curl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose# 修改权限chmod +x /usr/local/bin/docker-compose# 查询版本docker-compose version 方式二 12345yum -y install epel-releaseyum -y install python-pippip --versionpip install docker-composedocker-compose version 安装Nacos clone项目 12git clone https://github.com/nacos-group/nacos-docker.gitcd nacos-docker 单机模式MySQL 1docker-compose -f example/standalone-mysql.yaml up 启动时出现权限异常异常可以使用sudo -i 12345678#查看SELinux状态（如果SELinux status参数为enabled即为开启状态）/usr/sbin/sestatus -v #临时关闭setenforce 0#修改配置文件重启机器禁用（将SELINUX=enforcing改为SELINUX=disabled）vim /etc/selinux/config","link":"/2020/01/18/SSM/springcloudalibaba/0.2.Docker%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Nacos/"},{"title":"三、Linux上安装单机版Nacos","text":"Linux上安装单机版Nacos 下载 地址:https://github.com/alibaba/nacos/releases 这里以下载.tar.gz版本为例： 上传并解压通过xftp等工具将下载包上传至LInux服务器上。 使用下列命令解压： 1tar -xvf nacos-server-1.1.3.tar.gz 配置数据持久化在conf目录下的application.properties的添加以下配置： 123456spring.datasource.platform = mysqldb.num = 1db.url.0 = jdbc:mysql://127.0.0.1:3306/nacos_devtest? characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=root 启动进入bin目录下使用命令启动 1sh startup.sh -m standalone 后台启动 1sh startup.sh -m standalone &amp; 通过：127.0.0.1:8848/nacos 登录，使用nacos/nacos登录 通过命令查询Nacos启动进程 1ps -ef|grep nacos","link":"/2020/01/18/SSM/springcloudalibaba/0.3.Linux%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Nacos/"},{"title":"十三、Nacos集群部署","text":"前面已经学习了Nacos的注册中心功能以及分布式配置中心的各个功能。在前一节我们知道了如何实现Nacos的数据持久化（其实在安装的时候就有涉及到）。前面为了方便演示和测试，使用的都是单机版，而没有实现集群搭建。但是在分布式架构中，微服务解决方案里，都是要满足三大特性：高并发，高性能，高可用。所以，单机版本的Nacos(注册中心&amp;配置中心)已经不够满足实际场景了，所以本节来搭建一个Nacos集群。 集群部署架构图我们看看nacos官网的介绍： 因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面 http://ip1:port/openAPI 直连ip模式，机器挂则需要修改ip才可以使用。 http://VIP:port/openAPI 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。 http://nacos.com:port/openAPI 域名 + VIP模式，可读性好，而且换ip方便，推荐模式 预备环境 64 bit的 linux/unix/mac，推荐使用Linux。 64 bit的 JDK 1.8+。 Maven 3.2.x+。 3个或3个以上Nacos节点才能构成集群。 单机部署集群我们准备已经下载好的Nacos压缩包，并解压，配置好mysql数据连接（可参考前一节）。 在Nacos的conf 目录下有一个cluster.conf.example , 可以直接把.example 去掉使用，也可以单独创建一个cluster.conf文件,用于后续搭建集群的实例地址配置。 我们打开cluster.conf， 删除默认配置，添加下述配置： 1234#it is ip192.168.1.104:8085192.168.1.104:8086192.168.1.104:8087 需要保证部署3个或3个以上节点，这样才能搭建成集群。注意ip不可填写127.0.0.1，必须是内网ip，否则在nacos.log中会报 1java.lang.IllegalStateException: unable to find local peer 修改完cluster.conf之后，我们将bin/startup.sh 复制三份，分别命名为： 123startup-8085.shstartup-8086.shstartup-8087.sh 然后分别打开这三个文件，进行修改，如下： 我们可以看到： 设置相应的启动端口。 如果内存不够，设置不同的内容。 8087就不展示了，分别启动 123sh startup-8085.shsh startup-8086.shsh startup-8087.sh 然后选择其中一个端口进行登录，可以看到集群管理的节点列表中就有了节点信息，可以看到节点状态。如下图： 192.168.1.104:8087 为leader节点，192.168.1.104:8085/8086 为Follower节点。 生产部署集群生产环境部署集群，无非就是将不同的节点部署到不同的服务器上，这样不会因为一台服务器宕机而导致整个Nacos集群不可用。 第一步：修改cluster.conf文件，三个节点均需要配置 123120.79.167.88:8848119.23.104.130:884847.101.47.127:8848 第二步：修改application.properties 文件，配置数据源，三个节点均要 12345spring.datasource.platform = mysqldb.num = 1db.url.0 = jdbc:mysql://120.79.167.xxx:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=pwd 第三步：分别启动每个节点的startup.sh 1sh startup.sh 注意：如果服务器内存不足，需要先修改startup.sh . 结果如图： 依照上述的配置，如果没有部署成功，请看下一节【Nacos集群部署异常】。我自己按照上述的生产部署也没有成功。","link":"/2020/01/18/SSM/springcloudalibaba/10.Nocos%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"title":"十五、安装sentinel控制台","text":"前面我们结束了nacos的注册中心和配置中心的基础知识，以及Ribbon和Feign的简单使用，接下来我们学习一下alibaba的流量防卫兵–sentinel。在使用sentinel之前，我们先安装一下sentinel的管理控制台– sentinel-dashboard 。 下载 地址:https://github.com/alibaba/Sentinel/releases 当前最新版本是1.6.3，我们下载这个jar包。 启动注意：sentinel控制台需要在JDK 1.8+的版本上运行。 使用下列命令启动： 1java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar 如果我们需要修改端口，其中 -Dserver.port=8080 用于指定 Sentinel 控制台端口为 8080。需要注意，我们启动的时候需要使用绝对路径来启动，如果sentinel-dashboard.jar像我一样放置于/data/soft/sentinel ,那么启动命令为： 1java -Dserver.port=8082 -Dcsp.sentinel.dashboard.server=localhost:8082 -Dproject.name=sentinel-dashboard -jar /data/soft/sentinel/sentinel-dashboard-1.6.3.jar &amp; &amp; 表示后台启动应用。并且将端口修改为了8082.默认登录用户名和密码为：sentinel/sentinel; 修改登录信息 https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#%E9%89%B4%E6%9D%83 如果需要自定义登录用户名和密码等信息可以参考上面的文档； 用户可以通过如下参数进行配置： -Dsentinel.dashboard.auth.username=sentinel 用于指定控制台的登录用户名为 sentinel； -Dsentinel.dashboard.auth.password=123456 用于指定控制台的登录密码为 123456；如果省略这两个参数，默认用户和密码均为 sentinel； -Dserver.servlet.session.timeout=7200 用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟； 我们可以下载到源码包，修改相应的配置。如下： 效果： 登录：sentinel / sentinel","link":"/2020/01/18/SSM/springcloudalibaba/12.%E5%AE%89%E8%A3%85sentinel%E6%8E%A7%E5%88%B6%E5%8F%B0/"},{"title":"四、Nacos服务注册和发现","text":"Nacos服务注册和发现 依赖Nacos服务注册和发现的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;0.9.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 项目结构本示例的项目结构如下： 服务提供者 服务提供方：是指提供可复用和可调用服务的应用方 使用Idea 的SpringBoot项目引导器创建SpringBoot项目 导入依赖123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;0.9.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写测试Controller12345678910111213141516@SpringBootApplication@EnableDiscoveryClient //启动服务注册发现public class ServiceProviderApplication { public static void main(String[] args) { SpringApplication.run(ServiceProviderApplication.class, args); } @RestController class EchoController { @RequestMapping(value = \"/echo/{string}\", method = RequestMethod.GET) public String echo(@PathVariable String string) { return \"Hello Nacos Discovery \" + string; } }} 注意：使用@EnableDiscoveryClient 注解来启用服务注册发现机制。 配置properties123server.port= 8070spring.application.name= service-providerspring.cloud.nacos.discovery.server-addr= 127.0.0.1:8848 服务消费者 服务消费者：是指会发起对某个服务调用的应用方 导入依赖这里没有什么不同，与服务提供者是一样的。 12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;0.9.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写消费服务示例123456789101112131415161718192021222324252627282930313233343536373839404142package com.ooyhao.serviceconsumer;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@SpringBootApplication@EnableDiscoveryClientpublic class ServiceConsumerApplication { public static void main(String[] args) { SpringApplication.run(ServiceConsumerApplication.class, args); } @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } @RestController public class TestController { private final RestTemplate restTemplate; @Autowired public TestController(RestTemplate restTemplate) {this.restTemplate = restTemplate;} @RequestMapping(value = \"/echo/{str}\", method = RequestMethod.GET) public String echo(@PathVariable String str) { return restTemplate.getForObject(\"http://service-provider/echo/\" + str, String.class); } }} 这里使用RestTemplate进行调用，可以看出，此时这里可以看到使用的是服务名称 service-provider . 而不是使用IP地址。这也是服务注册中心的存在的重要意义，我们不需要知道服务提供方的IP地址，而只需要知道服务名，将IP地址和服务名的映射关系交给注册中心去动态维护，这样，如果同一个服务的IP地址变了，我们也不需要修改服务器消费者。 配置properties123server.port=8080spring.application.name= service-consumerspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 启动服务提供者和消费者项目。 我们可以使用spring.cloud.nacos.discovery.enabled=false 来禁用。 查询服务列表此时我们再查询服务列表，如图所示,服务提供者和服务消费者已经成功注册到服务注册中心了。 测试服务调用访问localhost:8080/echo/HelloNacos,结果如下： 此时，简单的服务注册和发现已经测试成功了。So Easy 有不有！ 更多配置信息 https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_more_information_about_nacos_discovery_starter_configurations","link":"/2020/01/18/SSM/springcloudalibaba/1.Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/"},{"title":"十六、连接sentinel控制台并实现限流","text":"连接sentinel控制台并实现限流 连接sentinel控制台我们这里依赖之前 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件12345678910spring: cloud: sentinel: transport: dashboard: 192.168.56.101:8080 port: 8719 application: name: sentinel-simpleserver: port: 8081 说明： spring.cloud.sentinel.transport.dashboard 来配置连接sentinel控制台的 ip:port； port: 默认是8719，这是端口是配置与sentinel dashboard来实时通信端口； server.port : 是当前项目的端口。 Controller我们先简单编写一个测试的controller，来测试连接sentinel控制台的效果： 1234567@RestControllerpublic class TestController { @GetMapping(value = \"/hello\") public String hello() { return \"Hello Sentinel\"; }} 下面我们通过在控制台使用curl命令或是在浏览器访问几次 http://localhost:8081/hello 。 1curl http://localhost:8081/hello sentinel控制台效果实时监控： 机器列表： 限流配置下面我们利用sentinel 的dashboard管理页面来配置流控规则： 我们点击簇点链路菜单，选择我们当前的/hello 接口的流控 按钮，配置相应的流控规则： 我们通过流控规则添加页面添加一条针对/hello 的流控规则. 阈值类型： 线程数：顾名思义就是当前接口的并发数。 QPS：Queries Per Second,中文就是，每秒查询数。 当前我们将单机阈值的值设置为2.下面我们测试一下： 我们通过测试可以发现，当我们快速的访问接口时，在一秒之内的第三次访问会自动被sentinel限制，返回默认值Blocked by Sentinel (flow limiting) .我们可以再看一下流控规则 的页面：","link":"/2020/01/18/SSM/springcloudalibaba/13.%E8%BF%9E%E6%8E%A5sentinel%E5%B9%B6%E9%99%90%E6%B5%81/"},{"title":"十四、unable to find local peer 172.16.26.250:8848","text":"问题描述 当我在虚拟机搭建成集群之后，（单机的虚拟机需要注意配置局域网IP而不要配置127.0.0.1）。打算拿三台实际的云服务器来搭建一台可以用于生产的Nacos集群. 但是遇到了一些问题：主要异常如下： 123456789101112131415161718java.lang.IllegalStateException: unable to find local peer: 172.16.26.250:8848, all peers: [120.79.167.88:8848, 119.23.104.130:8848, 47.101.47.127:8848] at com.alibaba.nacos.naming.consistency.persistent.raft.RaftPeerSet.local(RaftPeerSet.java:224) at com.alibaba.nacos.naming.monitor.PerformanceLoggerThread.collectMetrics(PerformanceLoggerThread.java:100) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:84) at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:93) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)2019-10-18 14:06:45,000 ERROR Unexpected error occurred in scheduled task. 这个日志是从logs/nacos.log中查询到的。我们在部署的时候，可以关注一下下列三个日志文件： 123logs/nacos.loglogs/naming-raft.loglogs/start.out 主要是查看nacos.log日志。一开始启动三个节点，均没有出错，但是在控制页面的节点列表中一直无法显示出节点信息。所以我怀疑没有真正搭建成功，于是从网上得知查询启动日志的文件，如上。发现nacos读取的是内网IP，但是在集群列表中不存在这个IP，所以报异常。网上大部分的集群ip都是在一个网段的，直接配置外网ip都是可以搭建成功，我按照这个方式一致搭建不成功。后面参考了下面这篇文章，修改启动配置，才得以搭建成功。 https://www.wandouip.com/t5i278697/ 结果如下： 解决方案修改每个节点的startup.sh启动文件 123456789101112131415161718#===========================================================================================# JVM Configuration#===========================================================================================if [[ \"${MODE}\" == \"standalone\" ]]; then JAVA_OPT=\"${JAVA_OPT} -Xms512m -Xmx512m -Xmn256m\" JAVA_OPT=\"${JAVA_OPT} -Dnacos.standalone=true\"else JAVA_OPT=\"${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\" JAVA_OPT=\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${BASE_DIR}/logs/java_heapdump.hprof\" JAVA_OPT=\"${JAVA_OPT} -XX:-UseLargePages\" JAVA_OPT=\"${JAVA_OPT} -Dnacos.server.ip=120.79.167.88\"fiif [[ \"${FUNCTION_MODE}\" == \"config\" ]]; then JAVA_OPT=\"${JAVA_OPT} -Dnacos.functionMode=config\"elif [[ \"${FUNCTION_MODE}\" == \"naming\" ]]; then JAVA_OPT=\"${JAVA_OPT} -Dnacos.functionMode=naming\"fi 添加这一行：JAVA_OPT=&quot;${JAVA_OPT} -Dnacos.server.ip=120.79.167.88&quot; ip分别改为对应主机的外网IP即可。 我们也查询一下源码： 在config模块下，utils/SystemConfig.java中。 12345678910111213141516171819202122232425262728293031public class SystemConfig { public static final String LOCAL_IP = getHostAddress(); private static final Logger log = LoggerFactory.getLogger(SystemConfig.class); private static String getHostAddress() { String address = System.getProperty(\"nacos.server.ip\"); if (StringUtils.isNotEmpty(address)) { return address; } else { address = \"127.0.0.1\"; } try { Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); while (en.hasMoreElements()) { NetworkInterface ni = en.nextElement(); Enumeration&lt;InetAddress&gt; ads = ni.getInetAddresses(); while (ads.hasMoreElements()) { InetAddress ip = ads.nextElement(); // 兼容集团不规范11网段 if (!ip.isLoopbackAddress() &amp;&amp; ip.getHostAddress().indexOf(\":\") == -1 /* &amp;&amp; ip.isSiteLocalAddress() */) { return ip.getHostAddress(); } } } } catch (Exception e) { log.error(\"get local host address error\", e); } return address; }} 读取nacos.server.ip 的值。 停节点将130节点停止之后，会选择一个先的leader节点 88. 我们再把130节点启动起来：可以方式，130节点并不会恢复之前的leader节点，而是变为了follower节点。","link":"/2020/01/18/SSM/springcloudalibaba/11.Nacos%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E5%BC%82%E5%B8%B8/"},{"title":"二十二、SpringCloud Gateway 的初体验","text":"SpringCloud Gateway 的初体验 引入gateway12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.ooyhao&lt;/groupId&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置文件配置映射123456789101112spring: application: name: spring-cloud-gateway cloud: gateway: routes: - id: 163_route uri: http://www.163.com/ predicates: - Path=/163server: port: 8080 配置文件配置映射123456789101112131415/** * @author hao.ouYang * @create 2019-10-25 11:38 */@Configurationpublic class RouteConfig { @Bean public RouteLocator routeLocator(RouteLocatorBuilder builder){ return builder.routes() .route(\"ooyhao_route\",r -&gt; r.path(\"/164\") .uri(\"http://www.163.com/\")) .build(); }} 测试： 当我使用https://localhost:8080/163 和 https://localhost:8080/164访问时，都可以转发到https://www.163.com. 效果如下： 总结这一节主要是简单尝试一下SpringCloud Gateway的使用，利用配置属性文件和配置类的方式来实现路径转发，这是就可以实现屏蔽真实路径的效果。","link":"/2020/01/18/SSM/springcloudalibaba/20.gateway%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"二十一、Sentinel规则之黑白名单规则","text":"很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的黑白名单控制的功能。黑白名单根据资源的请求来源（origin）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。 调用方信息通过 ContextUtil.enter(resourceName, origin) 方法中的 origin 参数传入 规则配置黑白名单规则（AuthorityRule）非常简单，主要有以下配置项： resource：资源名，即限流规则的作用对象 limitApp：对应的黑名单/白名单，不同 origin 用 , 分隔，如 appA,appB strategy：限制模式，AUTHORITY_WHITE 为白名单模式，AUTHORITY_BLACK 为黑名单模式，默认为白名单模式 源码1234public class AuthorityRule extends AbstractRule { //Mode: 0 for whitelist; 1 for blacklist. private int strategy = RuleConstant.AUTHORITY_WHITE;} 实验这个规则比前面的规则都更加简单，而且更加容易理解： 12345678910111213141516171819202122232425public static void testAuthorityRuleWithWhite() { ContextUtil.enter(\"entrance1\",\"App3\"); Entry entry = null; try { entry = SphU.entry(\"login\"); System.out.println(\"访问通过！\"); } catch (BlockException e) { System.out.println(\"访问受限！\"); } finally { if (entry != null) { entry.exit(); } }}public static void initAuthorityRule() { List&lt;AuthorityRule&gt; rules = new ArrayList&lt;&gt;(); AuthorityRule rule = new AuthorityRule(); rule.setResource(\"login\"); //配置白名单 rule.setStrategy(RuleConstant.AUTHORITY_WHITE); rule.setLimitApp(\"App1,App2\"); rules.add(rule); AuthorityRuleManager.loadRules(rules);} 上面代码测试结果为：访问受限！ 通过Strategy 来设置规则策略，白名单和黑名单。 通过LimitApp 来配置白名单列表或黑名单列表。多个之间使用逗号隔开。 上面的初始化规则在页面显示如下：","link":"/2020/01/18/SSM/springcloudalibaba/18.sentinel%E8%A7%84%E5%88%99%E4%B9%8B%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E8%A7%84%E5%88%99/"},{"title":"二十、Sentinel规则之熔断降级规则","text":"Sentinel规则之热点参数限流规则 文档： https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81 概述何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如： 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。 Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。 热点参数规则热点参数规则（ParamFlowRule）类似于流量控制规则（FlowRule）： 属性 说明 默认值 resource 资源名，必填 count 限流阈值，必填 grade 限流模式 QPS 模式 durationInSec 统计窗口时间长度（单位为秒），1.6.0 版本开始支持 1s controlBehavior 流控效果（支持快速失败和匀速排队模式），1.6.0 版本开始支持 快速失败 maxQueueingTimeMs 最大排队等待时长（仅在匀速排队模式生效），1.6.0 版本开始支持 0ms paramIdx 热点参数的索引，必填，对应 SphU.entry(xxx, args) 中的参数索引位置 paramFlowItemList 参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面 count 阈值的限制。仅支持基本类型和字符串类型 clusterMode 是否是集群参数流控规则 false clusterConfig 集群流控相关配置 上面都是摘抄子官方网站，下面使用代码来测试。 我们先看一下热点参数规则的源码： 12345678910111213141516171819202122232425262728293031323334public class ParamFlowRule extends AbstractRule { //限流模式 private int grade = RuleConstant.FLOW_GRADE_QPS; //热点参数的索引 private Integer paramIdx; //The threshold count. private double count; //流控效果 private int controlBehavior = RuleConstant.CONTROL_BEHAVIOR_DEFAULT; //最大排队等待时长 private int maxQueueingTimeMs = 0; private int burstCount = 0; //统计窗口时间长度 private long durationInSec = 1; //参数的额外项，可以针对指定的参数值单独设置限流阈值，不受前面的count影响，仅支持基本数据类型和字符串 private List&lt;ParamFlowItem&gt; paramFlowItemList = new ArrayList&lt;ParamFlowItem&gt;(); //额外参数 private Map&lt;Object, Integer&gt; hotItems = new HashMap&lt;Object, Integer&gt;(); //是否是集群参数流控规则 默认是false private boolean clusterMode = false; private ParamFlowClusterConfig clusterConfig;}public class ParamFlowItem { private String object;//参数值 private Integer count;//限流阈值 private String classType;//参数类型} 实验初始化规则123456789101112131415161718192021222324252627282930public static void initParamFlowRule(){ List&lt;ParamFlowRule&gt; rules = new ArrayList&lt;&gt;(); ParamFlowRule rule = new ParamFlowRule(); //阈值类型：只支持QPS rule.setGrade(RuleConstant.FLOW_GRADE_QPS); //阈值 rule.setCount(1); //资源名 rule.setResource(\"test\"); rule.setParamIdx(0);//指配热点参数的下标 //统计窗口时间长度 rule.setDurationInSec(10); List&lt;ParamFlowItem&gt; items = new ArrayList&lt;&gt;(); ParamFlowItem item = new ParamFlowItem(); item.setClassType(String.class.getTypeName()); item.setCount(2); item.setObject(\"123456\");//需要统计的值 ParamFlowItem item1 = new ParamFlowItem(); item1.setClassType(int.class.getName()); item1.setCount(3); item1.setObject(\"12\"); items.add(item); items.add(item1); rule.setParamFlowItemList(items); rules.add(rule); ParamFlowRuleManager.loadRules(rules);} 上述初始化规则代码相当于按如下在控制台页面配置 ： 逻辑代码1234567891011121314151617181920212223242526272829@GetMapping(\"/test\")public String test( @RequestParam(\"username\") String username, @RequestParam(\"password\") String password, @RequestParam(\"age\") int age) { String echo = echoService.test(username,password,age); SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); System.out.println(echo+\" | t:\"+dateFormat.format(new Date())); return \"访问成功\";}public interface EchoService { String test(String username, String password, int age);}@Servicepublic class EchoServiceImpl implements EchoService { @Override @SentinelResource(value = \"test\",blockHandler = \"handleBlockForTest\") public String test(String username,String password, int age) { return \"username:\"+username +\" password:\"+password + \" age:\"+age; } public String handleBlockForTest(String username, String password,int age, BlockException e){ return \"username:\"+username +\" password:\"+password +\" age:\"+age+\" e:\"+e.getClass().getSimpleName(); }} 测试112localhost:8083/test?username=admin&amp;password=123456&amp;age=12参数索引设置为：0 如果使用上述路径测试，结果为： 可以看出，passed的数量为1条，所以有效的阈值为1，统计的热点参数是username。 测试212localhost:8083/test?username=admin&amp;password=123456&amp;age=12参数索引设置为：1 可以看出，passed的数量为2条，所以有效的阈值为2，统计的热点参数，由于上面设置的为1，所以为password。 我们将password的123456修改一下，设置为12345，测试结果如下： passed的条数为1条，所以在额外的参数不匹配时，阈值还原到了第一个热点参数：username。 总结热点参数限流规则主要是针对请求参数来统计，并实现限流的。首先热点参数是基于QPS统计，如果参数索引设置为0，则以第一个参数统计为准，阈值也是按照基本参数中的阈值来控制的，但是指定的是额外的参数列表的下标，则需要提供指定的热点参数的值，如果当前访问的参数与预设定的参数不一致，依旧与第一个参数的阈值为准。","link":"/2020/01/18/SSM/springcloudalibaba/17.sentinel%E8%A7%84%E5%88%99%E4%B9%8B%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99/"},{"title":"二十六、Gateway 配置实例","text":"Gateway 配置实例 开启微服务名称转发123456789101112131415161718192021spring: application: name: SERVICE-GATEWAY cloud: nacos: discovery: server-addr: 120.79.167.88:8848 namespace: 0a1c17ae-b270-470f-881d-18e22e1e3e20 service: ${spring.application.name} sentinel: transport: dashboard: 127.0.0.1:8080 port: 8719 gateway: loadbalancer: use404: true# 以下使用服务名自动转发的方式，可以自动实现LoadBalancer discovery: locator: enabled: true # 开启根据服务名称自动转发 lower-case-service-id: true # 微服务名称以小写的形式呈现","link":"/2020/01/18/SSM/springcloudalibaba/24.Gateway/"},{"title":"二十五、Gateway全局过滤器","text":"全局过滤器GlobalFilte 接口与 GatewayFilter 具有相同的签名，这些特定的过滤器有条件的应用到所有的路由上。 https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.0.RC1/reference/html/#global-filters 组合使用GlobalFilter和GatewayFilter当请求进来的时候，过滤器Web处理器将会将所有的GlobalFilter 实例和所有特定的GatewayFilter 路由实例添加到过滤器filter链中，该组合的过滤器按org.springframework.core.Ordered接口排序，通过实现getOrder()方法来设置。 由于Spring Cloud Gateway 区分了过滤器逻辑执行器的”前”阶段和”后”阶段，因此优先级最高的过滤器在pre 阶段中处于第一个，而在post 阶段处于最后一个。 CustomGlobalFilter.java 123456789101112public class CustomGlobalFilter implements GlobalFilter,Ordered { @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { return chain.filter(exchange); } @Override public int getOrder() { return 0; }} 注意：数值越小，越靠前执行。 LoadBalancerClient 将LoadBalancerClientFilter在交换属性查找一个URI ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR。如果url有一个lb方案（即lb://myservice），它将使用Spring Cloud LoadBalancerClient将名称（myservice在前面的示例中）解析为实际的主机和端口，并在同一属性中替换URI。未经修改的原始url将附加到ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR属性中的列表。过滤器还将在ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR属性中查找是否相等lb，然后应用相同的规则 application.yaml 12345678spring: cloud: gateway: routes: - id: myRoute uri: lb://service predicates: - Path=/service/** 上面的介绍难以理解，其实通过代码可以看出，就是使用lb 来指定是否使用ribbon负载均衡。可以发现，这里Gateway也是使用ribbon来实现负载均衡的。 默认情况下，当一个服务示例不能被LoadBalancer发现,将会返回503, 我们可以配置spring.cloud.gateway.loadbalancer.use404 = false 来使得Gateway返回404. 我们建议使用ReactiveLoadBalancerClientFilter。您可以通过设置spring.cloud.loadbalancer.ribbon.enabled的值为false来使用ReactiveLoadBalancerClientFilter. ReactiveLoadBalancerClientFilter如上，见识使用这个，只需要将spring.cloud.loadbalancer.ribbon.enabled设置为false就可以了。 Sentinel 整合Gateway12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * @author hao.ouYang * @create 2019-10-29 14:15 */@Configurationpublic class GatewayConfiguration { private final List&lt;ViewResolver&gt; viewResolvers; private final ServerCodecConfigurer serverCodecConfigurer; public GatewayConfiguration(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) { this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList); this.serverCodecConfigurer = serverCodecConfigurer; }// 这两个在SentinelSCGAutoConfiguration已经配置好了 /*@Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() { return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer); } @Bean @Order(-1) public GlobalFilter sentinelGatewayFilter() { return new SentinelGatewayFilter(); }*/ /*@PostConstruct public void doInit() { initCustomizedApis(); initGatewayRules(); }*/ /*可以使用管理控制台进行管理*/ /*初始化自定义的Api*/ private void initCustomizedApis() { Set&lt;ApiDefinition&gt; definitions = new HashSet&lt;&gt;(); // some_customized_api api名称 ApiDefinition api1 = new ApiDefinition(\"some_customized_api\") .setPredicateItems(new HashSet&lt;ApiPredicateItem&gt;() {{ add(new ApiPathPredicateItem().setPattern(\"/ahas\")); add(new ApiPathPredicateItem().setPattern(\"/product/**\") .setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX)); }}); ApiDefinition api2 = new ApiDefinition(\"another_customized_api\") .setPredicateItems(new HashSet&lt;ApiPredicateItem&gt;() {{ add(new ApiPathPredicateItem().setPattern(\"/**\") .setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX)); }}); definitions.add(api1); definitions.add(api2); GatewayApiDefinitionManager.loadApiDefinitions(definitions); } /*初始化网关流控规则*/ private void initGatewayRules() { Set&lt;GatewayFlowRule&gt; rules = new HashSet&lt;&gt;(); rules.add(new GatewayFlowRule(\"aliyun_route\") .setCount(10) .setIntervalSec(1) ); rules.add(new GatewayFlowRule(\"aliyun_route\") .setCount(2) .setIntervalSec(2) .setBurst(2) .setParamItem(new GatewayParamFlowItem() .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_CLIENT_IP) ) ); rules.add(new GatewayFlowRule(\"httpbin_route\") .setCount(10) .setIntervalSec(1) .setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER) .setMaxQueueingTimeoutMs(600) .setParamItem(new GatewayParamFlowItem() .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_HEADER) .setFieldName(\"X-Sentinel-Flag\") ) ); rules.add(new GatewayFlowRule(\"httpbin_route\") .setCount(1) .setIntervalSec(1) .setParamItem(new GatewayParamFlowItem() .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM) .setFieldName(\"pa\") ) ); rules.add(new GatewayFlowRule(\"httpbin_route\") .setCount(2) .setIntervalSec(30) .setParamItem(new GatewayParamFlowItem() .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM) .setFieldName(\"type\") .setPattern(\"warn\") .setMatchStrategy(SentinelGatewayConstants.PARAM_MATCH_STRATEGY_CONTAINS) ) ); rules.add(new GatewayFlowRule(\"some_customized_api\") .setResourceMode(SentinelGatewayConstants.RESOURCE_MODE_CUSTOM_API_NAME) .setCount(5) .setIntervalSec(1) .setParamItem(new GatewayParamFlowItem() .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM) .setFieldName(\"pn\") ) ); GatewayRuleManager.loadRules(rules); }}","link":"/2020/01/18/SSM/springcloudalibaba/23.gateway%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"title":"九、初识Nacos 配置中心","text":"初识Nacos 配置中心 文档SpringCloud官方文档： https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_config Github中文文档： https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config 依赖创建一个SpringBoot，引入相关的依赖，如下： 123456&lt;!--nacos配置中心--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; Properties类型创建配置在Nacos控制页面配置相关的配置信息，由于上面的配置文件中未指定拓展名(properties/yml),默认是properties。 配置文件在classpath目录下创建一个名为bootstrap.properties文件，必须为bootstrap.properties。内容如下： 12spring.application.name=nacos-configspring.cloud.nacos.config.server-addr=127.0.0.1:8848 程序我们建立简单的web项目： User123456@Data@AllArgsConstructorpublic class User { private String username; private Integer age;} UserService1234567891011121314@Servicepublic class UserService { @Value(\"${user.name}\") private String username; @Value(\"${user.age}\") private Integer age; public User findUser(){ User user = new User(username,age); return user; }} UserController1234567891011@RestControllerpublic class UserController { @Autowired private UserService userService; @RequestMapping(value = \"/findUser\", method = RequestMethod.GET) public User findUser(){ return userService.findUser(); }} 测试结果 Yaml类型创建配置 配置文件将Bootstrap文件修改如下： 123456# 服务名，配置名spring.application.name=nacos-config# 配置格式spring.cloud.nacos.config.file-extension=yaml# 配置中心地址spring.cloud.nacos.config.server-addr=127.0.0.1:8848 测试结果 注意： 如果Nacos配置的是xxx.yaml.而服务配置上写的是yml，那么也读取不到配置，需要配置文件和Nacos配置的DataId一致。 如果使用的是域名的方式来访问配置中心Nacos时，spring.cloud.nacos.config.server-addr 配置方式为：域名:port ;例如Nocos的域名为abc.com.nacos,监听端口为80，则spring.cloud.nacos.config.server-addr=abc.com.nacos:80 . 80端口不能省略。","link":"/2020/01/18/SSM/springcloudalibaba/6.%E5%88%9D%E8%AF%86Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"title":"七、No Feign Client for loadBalancing defined","text":"No Feign Client for loadBalancing defined 这是在使用Feign调服务的时候，报的一个错误，完整错误如下： 12No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon? 从错误中看到，说的是我们是不是忘记引入spring-cloud-starter-netflix-ribbon 包了，但是我自己查看之后，发现这个包是存在。于是开启了面向度娘编程, 哈哈。 网上说有可能是因为没有引入eureka 包，但是，很显然我们使用的是alibaba系列，于是就想到了eureka的作用，所以是因为没有导入服务注册中心的包和配置。 于是添加配置就可以了： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件： 1spring.cloud.nacos.discovery.server-addr=120.79.167.88:8848","link":"/2020/01/18/SSM/springcloudalibaba/4.No%20Feign%20Client%20for%20loadBalancing%20defined/"},{"title":"八、Ribbon 负载均衡的坑","text":"由于Feign一般使用更加方便，所以这个问题是在Feign调用多个服务的时候出现了404. 描述：案例中 是 服务A 调用了服务B，然后调用了服务C，再次调用B的时候出现了404. 控制台输出如下异常： 12345feign.FeignException: status 404 reading FeignService#echo(String) at feign.FeignException.errorStatus(FeignException.java:78) ~[feign-core-10.1.0.jar:na] at feign.codec.ErrorDecoder$Default.decode(ErrorDecoder.java:93) ~[feign-core-10.1.0.jar:na] at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:149) ~[feign-core-10.1.0.jar:na] at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:78) ~[feign-core-10.1.0.jar:na] 其实异常是由于Ribbon引起的，由于Feign中封装使用了Ribbon，所以虽然是在使用Feign，但是是由于Ribbon造成的，我们来看看如何解决： 这个问题是由于Ribbon配置扫描的问题导致的：我们到官网看一下： https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.2.0.M3/reference/html/#customizing-the-ribbon-client 我们看一下警告的地方：自定义的配置类(CustomConfiguration)必须是一个被@configuration 注解标识的类，并且不应该被@ComponentScan 扫描到。当然也不能被@component 和 @SpringBootApplication 注解扫描到，如果扫描到会被所有的RibbonClient共享。 解决方法 配置文件： 123456789@Configurationpublic class LoadBalanceConfig { @Bean public IRule iRule(){// return new RandomRule();//随机策略 return new RoundRobinRule();//轮询策略 }}","link":"/2020/01/18/SSM/springcloudalibaba/5.Feign%E8%B0%83%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0404/"},{"title":"十二、Nacos的数据持久化","text":"Nacos的数据持久化 Nacos部署文档:https://nacos.io/zh-cn/docs/deployment.html 按照我们之前使用本地启动方式来测试Nacos，如果没有进行数据持久化配置的话，那么默认是使用嵌入式数据库来存储数据的。 目录结构我们下载下来的Nacos包，解压之后如下：以Windows为例： 单机模式支持mysql在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据存储，但是由于是内嵌式的，不方便我们观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤： 安装数据库，版本要求：5.6.5+ 初始化mysql数据库，数据库初始化文件是 conf/nacos-mysql.sql 修改conf/application.properties文件，增加支持mysql的配置信息(目前只支持mysql)，添加mysql数据源的url，用户名和密码。 123456spring.datasource.platform = mysqldb.num = 1db.url.0 = jdbc:mysql://127.0.0.1:3306/nacos_devtest? characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=root 然后再以单机模式启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql。 数据库存储表","link":"/2020/01/18/SSM/springcloudalibaba/9.Nacos%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"1.Linux上安装 redis","text":"Linux上安装 redis 下载压缩包进入redis官网【https://redis.io/】，将redis.tar.gz包下载下来，如果下载缓慢，可以把链接复制到迅雷中下载。 【http://download.redis.io/releases/redis-5.0.7.tar.gz】 上传服务器将下载的包【redis-5.0.7.tar.gz】上传到服务器或是虚拟机中。 解压并安装执行命令【tar -zxvf redis-5.0.7.tar.gz】解压。cd 进入到redis包中，执行 make 命令进行编译。 你可以会遇到下列报错： 12345678[root@localhost redis-5.0.7]# makecd src &amp;&amp; make allmake[1]: 进入目录“/ooyhao/software/redis-5.0.7/src” CC adlist.o/bin/sh: cc: 未找到命令make[1]: *** [adlist.o] 错误 127make[1]: 离开目录“/ooyhao/software/redis-5.0.7/src”make: *** [all] 错误 2 是因为没有安装 gcc环境，我们执行下列命令来安装环境 1yum install gcc-c++ 再执行下列命令 清空上次编译失败残留文件 1make distclean 最后执行下列命令编译及安装 1make &amp;&amp; make install 修改配置文件5.启动之前，执行【vi redis.conf】修改一下redis.conf这个配置文件。将里面的daemonize no改为yes。让服务在后台启动。如下： 1vi redis.conf 启动执行命令启动redis，如下： 12cd srcredis-server ../redis-conf 测试通过下列命令进入到控制台,然后通过 ping命令进行连通性测试，如果看到了pong，则表示连接通了。 1234[root@localhost redis-5.0.7]# redis-cli127.0.0.1:6379&gt;127.0.0.1:6379&gt; pingPONG 关闭关闭redis，通过shutdown命令我们可以关闭实例。 123127.0.0.1:6379&gt; shutdownnot connected&gt;not connected&gt; exit 到这里，我们的redis就算安装成功了。 远程连接如果需要使用redis客户端软件连接虚拟的redis，则需要将 1bind 127.0.0.1 修改为 1bind 0.0.0.0 说明：127.0.0.1 表示只允许本机访问，先改为0.0.0.0 可以开放给任何机器访问。 在 windows的cmd中使用telnet 测试是否可以连接 1telnet 192.168.36.131 6379 如果连接不成功，可能是没有打开6379端口。我们需要开启其端口 查询zone名称 123[root@localhost src]# firewall-cmd --get-active-zonespublic interfaces: ens33 开启6379端口 12[root@localhost src]# firewall-cmd --zone=public --add-port=6379/tcp --permanentsuccess 重启防火墙 12[root@localhost src]# firewall-cmd --reloadsuccess 检查端口是否成功开启 12[root@localhost src]# firewall-cmd --query-port=6379/tcpyes 再次测试，如图所示","link":"/2020/02/22/db/redis/1.Linux%E4%B8%8A%E5%AE%89%E8%A3%85redis/"},{"title":"10.Redis之事务管理","text":"Redis之事务管理 事务简介Redis事务可以一次执行多个命令，并且带有以下三个重要的保证： 批量操作在EXEC命令前被放入队列缓存。 收到EXEC命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历一下三个阶段： 开启事务 命令入列 执行事务 事务相关命令 序号 命令 描述 1 discard discard 命令用于取消事务，放弃执行事务块内的所有命令 2 exec exec命令用于执行所有事务块内的命令 3 multi multi 命令用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由EXEC命令原子性(atomic)地执行 4 unwatch unwatch 命令用于取消watch命令对所有key的监视 5 watch WATCH key [key ...] watch 命令用于监视一个或多个key，如果再事务执行之前这个或这些key被其他命令所改动，那么事务将被打断。 实例下面执行一个事务的例子。它是以 multi 开始一个事务，然后将多个命令入列到事务中，最后通过exec命令来触发事务，一并执行事务中的所有命令。如下： 1234567891011121314151617127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set book-name 'springboot in action'QUEUED127.0.0.1:6379&gt; get book-nameQUEUED127.0.0.1:6379&gt; sadd tag spring springboot javaQUEUED127.0.0.1:6379&gt; smembers tagQUEUED127.0.0.1:6379&gt; exec1) OK2) \"springboot in action\"3) (integer) 34) 1) \"java\" 2) \"springboot\" 3) \"spring\" 单个Redis命令的执行是原子性的，但是Redis没有在事务上增加任何原子性的机制，所以Redis事务的执行并不是原子性的。事务可以理解为一个打包的批量执行脚本，但批量执行并不是原子性的操作，中间某条执行失败也不会导致前面的命令进行回滚，也不会导致后面的执行不会被执行。 例如： 123456789101112127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set a aaaQUEUED127.0.0.1:6379&gt; set b bbbQUEUED127.0.0.1:6379&gt; set c cccQUEUED127.0.0.1:6379&gt; exec1) OK2) OK3) OK 说明：如果再set b bbb处失败了，set a 已经成功执行，不会进行回滚。并且set c还会继续执行。 事务中的异常情况redis 中事务的异常情况总的来说，分为两种： 进入队列之前就能发现的错误，比如命令输错。 执行exec命令之后才能发现的错误，比如给一个非数字字符加1。 那么对于这两种不同的异常，redis中有不同的处理策略。对于第一种错误，服务器会对命令入列失败的情况进行记录，并在客户端调用exec命令时，拒绝执行并自动放弃这个事务。如下： 1234567891011121314151617181920127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt;127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3 3 3QUEUED127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; exec1) OK2) OK3) (error) ERR syntax error4) OK127.0.0.1:6379&gt; keys *1) \"k4\"2) \"k1\"3) \"k2\" 而对于第二种情况，redis并没有对它们进行特别处理，即使事务中有某个/某些命令在执行时产生了错误，事务中的其他命令仍然会继续执行。如下： 1234567891011127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 vvQUEUED127.0.0.1:6379&gt; incr k1QUEUED127.0.0.1:6379&gt; exec1) OK2) (error) ERR value is not an integer or out of range127.0.0.1:6379&gt; get k1\"vv\" 不同于关系型数据库，redis的事务中出错时不会进行事务回滚。即redis的事务更像是命令操作的批处理。对此，官方解释如下： Redis命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面。这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。因为不需要对回滚进行支持，所有redis的内部可以保持简单且快速。 watch 命令事务中的watch命令可以用来监控一个key，通过一个或多个key。通过这种监控，我们可以为redis事务提供（CAS）行为。如果有至少一个被watch监视的键在exec执行之前被修改了，那么整个事务都会被取消。exec返回nil-reply 来表示事务已经失败。如下： 12345678910111213141516127.0.0.1:6379&gt; set k4 2OK127.0.0.1:6379&gt; watch k4OK127.0.0.1:6379&gt; set k4 5OK127.0.0.1:6379&gt; get k4\"5\"127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k4 8QUEUED127.0.0.1:6379&gt; exec(nil)127.0.0.1:6379&gt; get k4\"5\" watch 命令可以监控一个或多个key。一旦其中一个键被修改（或删除）。之后的事务就不会执行，监控一直持续到exec命令（事务中的命令是在exec之后才执行的，exec命令执行完之后被监控的键会自动被unwatch）. 通过unwatch 命令，可以取消对一个key的监控。如下： 123456789101112131415161718127.0.0.1:6379&gt; set kk 3OK127.0.0.1:6379&gt; watch kkOK127.0.0.1:6379&gt; set kk 5OK127.0.0.1:6379&gt; get kk\"5\"127.0.0.1:6379&gt; unwatchOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set kk 9QUEUED127.0.0.1:6379&gt; exec1) OK127.0.0.1:6379&gt; get kk\"9\" 关于Redis的事务问题就先到这了。 部分参考自：http://www.javaboy.org/2019/0615/redis-pub-sub.html https://www.runoob.com/redis/redis-transactions.html","link":"/2020/02/22/db/redis/10.redis%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"title":"14.Redis之集群搭建","text":"Redis之集群搭建 集群原理redis集群架构如下图： Redis 集群的运行原理如下： 所有的Redis节点彼此互联(ping + pong机制)，内部使用二进制协议优化传输速度和带宽。 节点的fail是通过集群中超过半数的节点监测失效时才生效。 客户端与Redis节点直连，不需要中间proxy层，客户端不需要连接集群中的所有节点，连接集群中的任何一个可用节点即可。 Redis-cluster 把所有的物理节点映射到【0-16383】slot上，cluster(簇)负责维护 node &lt;-&gt; slot &lt;-&gt; value。Redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个key-value时，Redis先对key使用crc16算法算出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，Redis会根据节点数量大致均等的将哈希槽映射到不同的节点。 怎么样投票投票过程中是集群中所有的Master参与，如果半数以上的master节点与master节点通信超过cluster-node-timeout设置的时间，认为当前的master节点挂掉。 怎么判定节点不可用 如果集群任意master挂掉，且当前master没有slave，集群进入fail状态，也可以理解成集群的slot映射【0-16383】不完整时进入fail状态。 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态，当集群不可用时，所有对集群的操作都不可用，收到((error) CLUSTERDOWN the cluster is down) 错误。 集群搭建首先我们对集群做一个简单的规划，假设我的集群中一共有三个节点，每一个节点一个主机一个从机，那么我就需要6个redis实例。首先创建redis-cluster文件夹，在该文件下分别创建7001,7002,7003,7004,7005,7006文件夹。用来存放我的Redis配置文件，如下： 12[root@localhost redis-cluster]# ls7001 7002 7003 7004 7005 7006 redis-5.0.7 redis-5.0.7.tar.gz 将Redis也在redis-cluster 目录下安装一份，然后将redis.conf文件向7001-7006这六个文件夹中分别拷贝一份，拷贝完成后，分别修改如下配置信息： 123456port 7001bind 0.0.0.0cluster-enable yescluster-config-file nodes7001.confprotected-mode nodaemonize yes 这是Redis7001目录下的配置，其他的文件夹中只需要将7001改为对应的数字即可。修改完成之后，进入到redis安装目录中，分别启动各个redis，使用刚刚修该过的配置文件，如下： 通过上图可以看出，各个节点都已经成功启动了。接下来我们就可以进行集群的配置。 执行下列命令： 1redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 注意：replicas 后面的 1 表示每个主机都带有1个从机，执行过程如下： 从创建过程的日志中可以看出，每个redis都获取了一个编号，同时日志也说明了哪些实例是做主机，哪些实例是做从机的。每个从机的主机是谁，每个主机所分配到的hash槽范围等等。 查询集群信息集群创建成功后，我们可以登录到redis控制台查看集群信息，注意登录时要添加-c 参数，表示以集群方式连接，如下： 添加主节点首先我们准备一个端口为7007的主节点并启动，准备方式和前面步骤一样，启动成功后，通过如下命令添加主机节点： 1redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7001 主节点添加之后，我们可以通过 cluster nodes 命令查看主节点是否添加成功，此时我们发现新的节点没有分配到slot，如下： 没有分配到slot将不能存储数据，此时我们需要手动分配slot，分配命令如下： 1redis-cli --cluster reshard 127.0.0.1:7001 后面的地址为任意一个节点地址，在分配的过程中，我们一共要输入如下几个参数： 一共要划分多少个hash槽出来？就是我们总共要给新添加的节点分多少hash槽，这个参数依实际情况而定，如下： 这些划分出来的槽要给谁，这里输入7007节点的编号，如下： 要从哪里拿出hash槽来呢？因为hash槽目前已经全部分配好了，要重新从已经分配好的节点中拿出一部分分给7007节点，必须要让另外三个节点释放一点出来，这里我们可以输入多个节点的编号，每次输入完一个回车，输入完所有后，输入done表示输入完成，这样就让这几个节点让出部分slot，如果要让所有具有slot的节点都参与到此处slot重新分配的活动中，那就直接输入all即可。如下： 这几个参数设置完之后，就进行到了slot重新分配的环节，分配完成后，通过cluster nodes命令，我们可以发现7007已经具有slot了，如下： 我们计算一下：2666 + 2667 + 2666 = 8000. OK，我们把主节点已经设置好了，我们也可以添加从节点，比如要把7008设置为7007的从节点，添加方式如下： 1redis-cli --cluster add-node 127.0.0.1:7008 127.0.0.1:7007 --cluster-slave --cluster-master-id 05675df35a13c4ee6c261377cdb7369218f6fff8 其中05675df35a13c4ee6c261377cdb7369218f6fff8 是 7007 的编号。 删除节点删除节点也比较简单，如下： 1redis-cli --cluster del-node 127.0.0.1:7007 05675df35a13c4ee6c261377cdb7369218f6fff8 注意：05675df35a13c4ee6c261377cdb7369218f6fff8 是要删除节点的编号。 再注意：删除已经占用了hash槽的节点会失败，如下： 需要先把该节点占用的hash槽分配出去，（分配方式和上文一致）。 Redis的集群搭建就介绍这么多了。是不是也挺简单的。 部分参考自：http://www.javaboy.org/2019/0615/redis-cluster.html","link":"/2020/02/23/db/redis/14.redis%E4%B9%8B%E9%9B%86%E7%BE%A4/"},{"title":"2.redis 数据类型","text":"redis 数据类型 redis基本简介redis 与 其他key-value缓存产品有以下三个特点： - redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 - redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 - redis支持数据的备份，即master-slave模式的数据备份。 redis 数据类型五大数据类型： string(字符串) string是redis最基本的数据类型，可以理解成与Memcached一模一样的类型，一个key对应一个value。 string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 string类型是redis最基本的数据类型，string类型的值最大能存储512MB。 hash(哈希)redis hash 是一个键值(key=&gt;value)对集合。HASH 类似于 Java 中的 Map ，是一个键值对集合，在 redis 中可以用来存储对象。 list(列表)redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。 set(集合)redis 的set 是string类型的无序集合。集合是通过哈希表实现，所以添加，删除，查找的复杂度都是O(1). zset(sorted set:有序集合)redis zset和set一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正式通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。 redis keys命令我们通过set命令先插入一条数据： 12127.0.0.1:6379&gt; set name zhangsanOK del 命令上面我们看到OK表示成功插入了一条记录。我们可以通过del命令来删除一个已经存在的key。如下： 12127.0.0.1:6379&gt; del name(integer) 1 看到(integer)1表示数据删除成功。同时删除多个key，可以使用 del name age sex. dump 命令dump命令可以序列化给定的key，并返回序列化之后的值： 12127.0.0.1:6379&gt; dump name\"\\x00\\bzhangsan\\t\\x00\\xa7\\xce\\xa1\\xe9\\xcc\\xbeE\\xf9\" exists 命令exists 用来判断指定key是否存在。例如： 1234127.0.0.1:6379&gt; exists name(integer) 1127.0.0.1:6379&gt; exists age(integer) 0 如上述所示，表示key为name 是存在，而 key为age不存在 ttl 命令ttl命令可以查看一个给定key的有效时间： 1234127.0.0.1:6379&gt; ttl name(integer) -1127.0.0.1:6379&gt; ttl age(integer) -2 -2 表示key不存在或是已经过期。-1 表示key存在并且没有设置过期时间（永久有效）。当然，我们可以通过下面的命令给key设置一个过期时间。 expire 命令expire命令可以给key设置一个有效期，有效期过后，该key就会自动被销毁： 12345678127.0.0.1:6379&gt; expire name 20(integer) 1127.0.0.1:6379&gt; ttl name(integer) 14127.0.0.1:6379&gt; ttl name(integer) 11127.0.0.1:6379&gt; ttl name(integer) -2 20表示过期时间为20秒，ttl name 返回14,11. 表示这个key的有效时间还剩下 14秒或11秒。 persist 命令persist 命令表示移除一个key的过期时间，这样该key就永远不会过期了。 123456789101112127.0.0.1:6379&gt; set name lisiOK127.0.0.1:6379&gt; get name\"lisi\"127.0.0.1:6379&gt; expire name 30(integer) 1127.0.0.1:6379&gt; ttl name(integer) 23127.0.0.1:6379&gt; persist name(integer) 1127.0.0.1:6379&gt; ttl name(integer) -1 pexpire 命令pexpire 命令的功能和expire命令的功能基本一致，只不过这里设置的参数值是以毫秒为单位的： 123456127.0.0.1:6379&gt; pexpire name 60000(integer) 1127.0.0.1:6379&gt; ttl name(integer) 55127.0.0.1:6379&gt; ttl name(integer) 52 pttl 命令pttl命令和ttl命令基本一致，但是pttl命令返回的是以毫秒为单位的： 123456127.0.0.1:6379&gt; pexpire name 60000(integer) 1127.0.0.1:6379&gt; pttl name(integer) 56919127.0.0.1:6379&gt; pttl name(integer) 53676 keys 命令keys命令可以获取满足给定模式所有key，如： 1234567127.0.0.1:6379&gt; set name ooyhaoOK127.0.0.1:6379&gt; set age 23OK127.0.0.1:6379&gt; keys *1) \"name\"2) \"age\" keys * 表示获取所有的key。* 也可以是一个正则表达式。 关于key相关的常见命令就差不多了，如果需要完整可以移步：http://www.redis.cn/commands.html 部分参考自：http://www.javaboy.org/2019/0615/redis-datatype.html","link":"/2020/02/22/db/redis/2.redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"15.SpringBoot 整合 Redis","text":"SpringBoot 整合 Redis SpringBoot 整合 Redis简单介绍前面我们基本把Redis 的基本知识介绍完了，但是可以看出，全部都是在SSH命令行操作的，作为一个学习Java的程序员，肯定希望使用Java来操作一把。我们这里直接使用SpringDataRedis来玩，不在单独使用Jedis来操作了。 项目搭建创建项目创建项目我们使用 SpringBoot的引导器来创建，这里就不多赘述了。如何创建SpringBoot项目可以参考。 https://blog.csdn.net/ooyhao/article/details/82898973 导入依赖12345678910111213141516171819202122232425&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 依赖分为两个部分，第一个部分就是jackson-databind,jackson-core,jackson-annotations 关于jackson的几个，第二个部分就是SpringBoot整合redis的staterspring-boot-starter-data-redis 。 配置文件12345678910111213141516171819spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379# Redis数据库索引(默认为0)spring.redis.database=0# Redis服务器连接密码(默认为空)spring.redis.password=# 连接池最大连接数(使用负值表示没有限制)spring.redis.jedis.pool.max-idle=8# 连接池最大阻塞等待时间(使用负值表示没有限制)spring.redis.jedis.pool.max-wait=-1# 连接池中的最大空闲连接数spring.redis.jedis.pool.max-active=8# 连接池中的最小空闲连接数spring.redis.jedis.pool.min-idle=0# 连接超过时间(毫秒)#spring.redis.timeout=0 配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ouyanghao.springbootredis.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig { @Bean @SuppressWarnings(\"all\") public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory){ Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(factory); template.setKeySerializer(new StringRedisSerializer());//key的序列化方式 template.setValueSerializer(jackson2JsonRedisSerializer); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } @Bean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory factory){ StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(); stringRedisTemplate.setConnectionFactory(factory); return stringRedisTemplate; }} 封装组件类123456789101112131415161718192021222324252627package com.ouyanghao.springbootredis.test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;/** * 主要用于测试相应的List类型的API */@Componentpublic class RedisListOps { @Autowired private RedisTemplate&lt;String,Object&gt; redisTemplate; public void leftPush(String key, Object value){ redisTemplate.boundListOps(key).leftPush(value); } public void leftPushAll(String key, Object...value){ redisTemplate.boundListOps(key).leftPushAll(value); } public Object leftPop(String key){ return redisTemplate.boundListOps(key).leftPop(); }} 这个组件类是以操作List列表创建的，就不单独每一种类型都创建一个了。 项目测试测试代码12345678910111213141516171819202122package com.ouyanghao.springbootredis;import com.ouyanghao.springbootredis.test.RedisListOps;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass SpringbootRedisApplicationTests { @Autowired private RedisListOps redisListOps; @Test void contextLoads() { redisListOps.leftPush(\"animal\",\"apple\"); redisListOps.leftPushAll(\"animal\",\"orange\",\"banana\");// System.out.println(redisListOps.leftPop(\"animal\"));// System.out.println(redisListOps.leftPop(\"animal\"));// System.out.println(redisListOps.leftPop(\"animal\")); }} 测试结果 使用SpringBoot整合Redis就先到这里了。","link":"/2020/02/24/db/redis/15.SpringBoot%E6%95%B4%E5%90%88Redis/"},{"title":"4.redis 字符串 string-bit","text":"​前面我们介绍了Redis中的字符串类型的基本命令操作。但是没有涉及到bit相关的命令。本文我们来看几个bit相关的命令。 bit相关的命令指的是 bitcount , bitfield, bitop, bitpos, setbit, getbit 几个命令。 准备知识在学习这几个命令之前。我们需要知道，redis中的字符串的存储方式，是采用二进制的方式进行存储的，如果下面的命令： 12127.0.0.1:6379&gt; set name aOK a对应的ASCII码对应的是97，转换为二进制就是 0110 0001 ，我们bit相关的命令就是基于这个二进制数据进行操作的。 getbitgetbit 命令可以返回key对应的value在offset处的bit值。例如如上key为name，value为a。a对应的二进制是 0110 0001，所以当offset为0时，对应的bit值是0.当offset为1时，对应的bit值是1，offset为2时，对应的bit值为1….以此类推。 如下： 123456789101112131415161718127.0.0.1:6379&gt; set name aOK127.0.0.1:6379&gt; getbit name 0(integer) 0127.0.0.1:6379&gt; getbit name 1(integer) 1127.0.0.1:6379&gt; getbit name 2(integer) 1127.0.0.1:6379&gt; getbit name 3(integer) 0127.0.0.1:6379&gt; getbit name 4(integer) 0127.0.0.1:6379&gt; getbit name 5(integer) 0127.0.0.1:6379&gt; getbit name 6(integer) 0127.0.0.1:6379&gt; getbit name 7(integer) 1 setbitsetbit命令可以用来修改二进制数据，比如a对应的ASCII码对应为97，而 b的ASCII码对应为98. 98所对应的二进制数为 0110 0010.下面我们通过setbit来修改对应位置上的数据。只需将第六位设置1，第七位设置为0即可。如下： 123456127.0.0.1:6379&gt; setbit name 6 1(integer) 0127.0.0.1:6379&gt; setbit name 7 0(integer) 1127.0.0.1:6379&gt; get name\"b\" 此时，name的存储的字符串由a变成了b。setbit在执行时返回的数据，表示该位置上原来的bit值。 bitcountbitcount 可以用来统计这个二进制数据中的1的个数。如下： 1234127.0.0.1:6379&gt; set name aOK127.0.0.1:6379&gt; bitcount name(integer) 3 关于bitcount,redis官方网站上有一个非常有意思的案例：用户上线次数统计。节选部分原文如下： 举一个例子,如果今天是网站上线的第100天，而用户Peter在今天浏览过网站，那么执行命令 setbit peter 100 1; 如果明天也继续浏览了网站，那么执行命令setbit peter 101 1,以此类推。当要计算peter总共以来上线了多少次。就可以是用bitcount命令。执行bitcount peter，得出的结果就是peter上线的总天数。 这种统计方式最大的好处就是节省空间并且计算速度非常快。每天占用一个bit。一年也就只要365个bit。10年也才3650个bit。也就是456个字节。对于这么大的数据。bit操作速度是非常快的。 bitopbitop可以对一个或者多个二进制位串执行并(and),或(or),异或(xor)以及非(not)运算。如下：a对应的ASCII码对应的是0110 0001 ， c对应的二进制为 0110 0011.对于这两个二进制串分别执行 and/or/xor/not的结果为： 12345678910111213141516127.0.0.1:6379&gt; set k1 aOK127.0.0.1:6379&gt; set k2 cOK127.0.0.1:6379&gt; bitop and k3 k1 k2(integer) 1127.0.0.1:6379&gt; get k3\"a\"127.0.0.1:6379&gt; bitop or k3 k1 k2(integer) 1127.0.0.1:6379&gt; get k3\"c\"127.0.0.1:6379&gt; bitop xor k3 k1 k2(integer) 1127.0.0.1:6379&gt; get k3\"\\x02\" 另外，bitop也可以执行not操作，但是只需一个参数，如下： 1234127.0.0.1:6379&gt; bitop not k3 k1(integer) 1127.0.0.1:6379&gt; get k3\"\\x9e\" 下面我们手动来验证一下：a = &gt; 0110 0001. c =&gt; 011 0011 and. 1 1 得 1， 1 0 得 0 ， 0 1 得 0 ， 0 0 得 0； 0 1 1 0 0 0 0 1 0 1 1 0 0 0 1 1 – 0 1 1 0 0 0 0 1 =&gt; a or. 1 1 得 1，1 0 得 1， 0 1 得 1， 0 0 得 0 0 1 1 0 0 0 0 1 0 1 1 0 0 0 1 1 – 0 1 1 0 0 0 1 1 =&gt; c xor. 1 1 得 0，1 0 得 1 ，0 1 得 1 ，0 0 得 0 0 1 1 0 0 0 0 1 0 1 1 0 0 0 1 1 – 0 0 0 0 0 0 1 0 =&gt; 2 转为16进行为 2 not. 0 1 1 0 0 0 0 1 – 1 0 0 1 1 1 1 0 =&gt; 2^7 + 2^ 4 + 2^3 + 2^2 + 2^1 = 128 + 16 + 8 + 4 + 2 = 158 转为16进制为 9e bitposbitops 用来获取二进制位串中第一个1或者0 的位置。如下： 1234127.0.0.1:6379&gt; bitpos k1 1(integer) 1127.0.0.1:6379&gt; bitpos k1 0(integer) 0 也可以在后面设置一个范围，不过后面的范围是字节的范围，而不是二进制位串的范围。 关于redis的bit字符串类型就先介绍到这里，如果需要更加详细的文档，可以移步官方文档： http://www.redis.cn/commands.html#generic 本文部分参考自：http://www.javaboy.org/2019/0615/redis-string.html","link":"/2020/02/22/db/redis/4.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bstring-bit/"},{"title":"3.Redis数据类型之字符串String","text":"Redis 字符串 string ​ 前面介绍了redis的五种数据类型以及一些通用的命令，从本文开始，我们分别来看一下这几种数据类型对应的命令操作。从字符串string开始。 append使用append命令时，如果key已经存在，则会直接追加到value后面，如果key不存在，则会先创建一个value为空的key，然后再追加。 12345678127.0.0.1:6379&gt; append name hello(integer) 5127.0.0.1:6379&gt; get name\"hello\"127.0.0.1:6379&gt; append name redis(integer) 10127.0.0.1:6379&gt; get name\"helloredis\" decrdecr命令可以实现对value的减一操作。如果key不存在，则key对应的初始值会被设置为0，如果key的value不是数字，则会报错。实验如下： 12345678127.0.0.1:6379&gt; set age 20OK127.0.0.1:6379&gt; decr age(integer) 19127.0.0.1:6379&gt; set nick tomOK127.0.0.1:6379&gt; decr nick(error) ERR value is not an integer or out of range decrbydecrby 和 decr 类型，不同的是 decrby 可以指定步长。如下： 12345127.0.0.1:6379&gt; get age\"19\"127.0.0.1:6379&gt; decrby age 5(integer) 14 getget命令就是用来获取指定key的value。如果不存在则返回nil。如下： 1234127.0.0.1:6379&gt; get age\"14\"127.0.0.1:6379&gt; get newAge(nil) getsetgetset命令可以用来获取key所对应的value，并对key进行重置。如下： 12345678910127.0.0.1:6379&gt; set name ouYangOK127.0.0.1:6379&gt; getset name ooyhao\"ouYang\"127.0.0.1:6379&gt; get name\"ooyhao\"127.0.0.1:6379&gt; getset newName zhangsan(nil)127.0.0.1:6379&gt; get newName\"zhangsan\" 由上面的执行结果可以看出，如果getset执行前，该key已经存在了，那么返回的是 oldValue, 并重置为newValue。如果该key不存在，则返回nil 并重置为newValue. incrincr 操作可以对指定key的value执行加1操作。如果指定的key不存在，那么在加1操作之前，会先将key对应的value设置为0，如果key的value不是数字，则会报错。如下： 12345678127.0.0.1:6379&gt; incr age(integer) 1127.0.0.1:6379&gt; get age\"1\"127.0.0.1:6379&gt; set newAge aOK127.0.0.1:6379&gt; incr newAge(error) ERR value is not an integer or out of range incrbyincrby 和 incr 功能类似，不同的是可以指定增长步长。如下： 123456127.0.0.1:6379&gt; get age\"1\"127.0.0.1:6379&gt; incrby age 10(integer) 11127.0.0.1:6379&gt; get age\"11\" incrbyfloatincrbyfloat 命令可以用来增长浮点数。如下： 1234127.0.0.1:6379&gt; get age\"11\"127.0.0.1:6379&gt; incrbyfloat age 1.5\"12.5\" mget 与 msetmget与mset分别用来批量设置值和批量获取值。如下： 123456127.0.0.1:6379&gt; mset name ooyhao age 23 sex maleOK127.0.0.1:6379&gt; mget name age sex1) \"ooyhao\"2) \"23\"3) \"male\" setexsetex 用来给key设置value，同时设置过期时间，等效于先给key设置value，再给key设置过期时间。如下： 123456127.0.0.1:6379&gt; setex name 30 zhangsanOK127.0.0.1:6379&gt; get name\"zhangsan\"127.0.0.1:6379&gt; ttl name(integer) 24 psetexpsetex 的作用和setex类似，不同的是，这里设置过期时间的单位是毫秒值。如下： 12345678127.0.0.1:6379&gt; psetex age 30000 23OK127.0.0.1:6379&gt; get age\"23\"127.0.0.1:6379&gt; ttl age(integer) 22127.0.0.1:6379&gt; pttl age(integer) 17430 setnxsetnx 是set if not exists 的简写，set命令在执行时，如果key已经存在，则新值会覆盖掉旧值，而对于setnx来说，如果key已经存在，则不做任何操作，如果key不存在，则效果等同于set命令。如下： 1234567891011121314127.0.0.1:6379&gt; set name ooyhaoOK127.0.0.1:6379&gt; setnx name zhangsan(integer) 0127.0.0.1:6379&gt; get name\"ooyhao\"127.0.0.1:6379&gt;127.0.0.1:6379&gt;127.0.0.1:6379&gt; get age(nil)127.0.0.1:6379&gt; setnx age 23(integer) 1127.0.0.1:6379&gt; get age\"23\" msetnxmsetnx 兼具了setnx和mset的特性，但是msetnx在执行时，如果有一个key存在，则所有的都不会执行。如下： 12345678910127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set name ouYangOK127.0.0.1:6379&gt; msetnx name ooyhao age 23(integer) 0127.0.0.1:6379&gt; get name\"ouYang\"127.0.0.1:6379&gt; get age(nil) 由上面的例子可以看出，由于name之前已经存在了，所以在执行msetnx的时候。age没有设置成功。 setrangesetrange 用来覆盖一个已经存在的key的value。如下： 12345678127.0.0.1:6379&gt; set str helloworldOK127.0.0.1:6379&gt; get str\"helloworld\"127.0.0.1:6379&gt; setrange str 5 redis(integer) 10127.0.0.1:6379&gt; get str\"helloredis\" 但是如果已经存在的key所对应的value的长度小于offset。则不足的地方用0来补齐。如下： 123456127.0.0.1:6379&gt; set newStr helloredisOK127.0.0.1:6379&gt; setrange newStr 20 --java(integer) 26127.0.0.1:6379&gt; get newStr\"helloredis\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00--java\" strlenstrlen 命令用来计算key的value的长度。如下： 1234127.0.0.1:6379&gt; set name ouYangHaoOK127.0.0.1:6379&gt; strlen name(integer) 9 关于redis的字符串类型就先介绍到这里，如果需要更加详细的文档，可以移步官方文档： http://www.redis.cn/commands.html#generic 本文部分参考自：http://www.javaboy.org/2019/0615/redis-string.html","link":"/2020/02/22/db/redis/3.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bstring/"},{"title":"5.redis 数据类型之list列表","text":"redis 数据类型之list列表 列表简介Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 列表操作命令lpushLPUSH key value1[value2] lpush 即 left push. 将一个或多个值value插入到列表key的表头，如果有多个value值。那么各个value值按从左到右的顺序依次插入到表头。如下： 12127.0.0.1:6379&gt; lpush name shangsan lisi wangwu(integer) 3 返回的是列表元素的个数。 lpushxLPUSHX key value Redis Lpushx 将一个值插入到已存在的列表头部，列表不存在时操作无效。 lrangeLRANGE key start stop 返回列表key中指定区间内的元素，区间以偏移量start 和 stop指定。下标(index)参数start和stop都以0为底，即0 表示的第一个元素，1表示列表的第二元素。依次类推。我们也可以使用负数下标，以-1表示列表的最后一个元素，-2 表示列表的倒数第二个元素，依次类推。如下： 12345678910111213127.0.0.1:6379&gt; lpush name shangsan lisi wangwu(integer) 3127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"lisi\"3) \"shangsan\"127.0.0.1:6379&gt; lrange name 0 -21) \"wangwu\"2) \"lisi\"127.0.0.1:6379&gt; lrange name 0 21) \"wangwu\"2) \"lisi\"3) \"shangsan\" rpushRPUSH key value1 [value2] rpush即 right push. rpush与lpush的功能一致，不同的是rpush的中的value值是按照从右到左的顺序依次插入。如下： 123456789127.0.0.1:6379&gt; rpush name tom peter john(integer) 6127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"lisi\"3) \"shangsan\"4) \"tom\"5) \"peter\"6) \"john\" rpushxRPUSHX key value Redis Rpushx 命令用于将一个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。 rpoprpop 即 right pop. rpop命令可以移除并返回列表key的尾元素。如下： 123456789101112131415127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"lisi\"3) \"shangsan\"4) \"tom\"5) \"peter\"6) \"john\"127.0.0.1:6379&gt; rpop name\"john\"127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"lisi\"3) \"shangsan\"4) \"tom\"5) \"peter\" lpoplpop 和 rpop类似。不同的是lpop移除并返回列表key的头元素。如下： 1234567891011121314127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"lisi\"3) \"shangsan\"4) \"tom\"5) \"peter\"127.0.0.1:6379&gt;127.0.0.1:6379&gt; lpop name\"wangwu\"127.0.0.1:6379&gt; lrange name 0 -11) \"lisi\"2) \"shangsan\"3) \"tom\"4) \"peter\" lindexlindex命令可以返回列表key中，下标为index的元素。正数下标0表示第一个元素，也可以使用负数下标。-1 表示倒数第一个元素，如下： 1234567891011127.0.0.1:6379&gt; lrange name 0 -11) \"lisi\"2) \"shangsan\"3) \"tom\"4) \"peter\"127.0.0.1:6379&gt; lindex name 0\"lisi\"127.0.0.1:6379&gt; lindex name -1\"peter\"127.0.0.1:6379&gt; lindex name -2\"tom\" ltrimLTRIM key start stop ltrim 命令可以对一个列表进行修剪，即让列表只保留指定区间内的元素。不在指定区间之内的元素都将被删除。下标与之前介绍的写法都一致。如下： 123456789127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"lisi\"3) \"zhangsan\"127.0.0.1:6379&gt; ltrim name 0 1OK127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"lisi\" llenllen 获取列表的长度 1234127.0.0.1:6379&gt; lpush name zhangsan lisi wangwu(integer) 3127.0.0.1:6379&gt; llen name(integer) 3 lset通过索引设置列表的值 1234567127.0.0.1:6379&gt; lpush name zhangsan lisi wangwu127.0.0.1:6379&gt; lset name 1 ooyhaoOK127.0.0.1:6379&gt; lrange name 0 -11) \"wangwu\"2) \"ooyhao\"3) \"zhangsan\" blpopBLPOP key1 [key2] timeout 说明：移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止. blpop 是阻塞式列表的弹出原语。它是命令lpop的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被blpop命令阻塞。当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。同时，在使用该命令时也需要指定阻塞的时长，时长单位为秒，在该时长内如果没有元素可供弹出，则阻塞结束。返回的结果是 key 和 value 的组合，如下： 123456789127.0.0.1:6379&gt; blpop name 101) \"name\"2) \"wangwu\"127.0.0.1:6379&gt; blpop name 101) \"name\"2) \"lisi\"127.0.0.1:6379&gt; blpop name 10(nil)(10.06s) 最后，brpop, bpoplpush, brpoplpush 都是相应命令的阻塞版本。 更加详细的文档可以查看：https://www.runoob.com/redis/redis-lists.html 或官网 本文部分参考自：http://www.javaboy.org/2019/0615/redis-list-set.html","link":"/2020/02/22/db/redis/5.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist/"},{"title":"7.redis 数据类型之hash 哈希","text":"redis 数据类型之hash 哈希 哈希简介hash 是一个string 类型的field和value的映射表，hash特别适合用于存储对象。redis中每个hash可以存储2^32 -1 个键值对(40多亿)。 Hash 命令集合hsetHSET key field value hset 命令用于为哈希表中字段赋值。如果哈希表不存在，一个新的哈希表被创建并进行hset操作。 如果字段已经存在于哈希表中，旧值将被覆盖。 12127.0.0.1:6379&gt; hset stu1 name zhangsan(integer) 1 hmsetHMSET key field1 value1 [field2 value2] hmset 命令用于同时将多个field-value(字段-值)对设置到哈希表中。此命令会覆盖哈希表中已经存在的字段。如果哈希表不存在，会创建一个空的哈希表，并执行hmset命令操作。 12127.0.0.1:6379&gt; hmset stu1 name ooyhao age 23 sex maleOK hsetnxHSETNX key field value hsetnx 命令用于为哈希表中不存在的字段赋值。如果哈希表不存在，一个新的哈希表被创建并进行hset操作。 如果字段已经存在于哈希表中，则操作无效。 如果key不存在，一个新的哈希表被创建并执行hsetnx命令。 1234567891011121314151617181920127.0.0.1:6379&gt; hgetall stu11) \"name\"2) \"ooyhao\"3) \"age\"4) \"18\"5) \"sex\"6) \"female\"127.0.0.1:6379&gt; hsetnx stu1 name ouYang(integer) 0127.0.0.1:6379&gt; hsetnx stu1 salary 7500(integer) 1127.0.0.1:6379&gt; hgetall stu11) \"name\"2) \"ooyhao\"3) \"age\"4) \"18\"5) \"sex\"6) \"female\"7) \"salary\"8) \"7500\" hgetHGET key field hget 命令用于返回哈希表中执行字段的值。 12345678127.0.0.1:6379&gt; hmset stu1 name ooyhao age 23 sex maleOK127.0.0.1:6379&gt; hget stu1 name\"ooyhao\"127.0.0.1:6379&gt; hget stu1 age\"23\"127.0.0.1:6379&gt; hget stu1 sex\"male\" hmgetHMGET key field1 [field2] hmget 命令用于返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在与哈希表中，则返回一个nil值。 1234127.0.0.1:6379&gt; hmget stu1 name age salary1) \"ooyhao\"2) \"23\"3) (nil) hgetallHGETALL key hgetall 命令用于返回哈希表中，所有的字段和值。在返回值中，紧跟着每个字段名(field name)之后的是字段的值(value).左右返回值的长度是哈希表大小的两倍。 1234567127.0.0.1:6379&gt; hgetall stu11) \"name\"2) \"ooyhao\"3) \"age\"4) \"23\"5) \"sex\"6) \"male\" hdelHDEL key field1 [field2] hdel 命令用于删除指定哈希表中的一个或多个字段。不存在的字段将被忽略。 12345678910127.0.0.1:6379&gt; hkeys stu11) \"name\"2) \"age\"3) \"sex\"4) \"salary\"127.0.0.1:6379&gt; hdel stu1 sex salary(integer) 2127.0.0.1:6379&gt; hkeys stu11) \"name\"2) \"age\" hincrbyHINCRBY key field increment hincrby 命令用于为哈希表中的字段值加上指定的增量值。增量也可以是负数，相当于对指定字段进行减法操作。 如果哈希表的key不存在，一个新的哈希表被创建并执行hincrby操作。 如果指定的字段不存在，那么在执行命令前，字段的值被初始化为0. 对一个存储字符串值的字段执行hincrby 命令将造成一个错误，本操作的值被限制在64位(bit)有符号数字表示之内。 12345678910127.0.0.1:6379&gt; hincrby stu1 age 1(integer) 19127.0.0.1:6379&gt; hincrby stu1 age 1(integer) 20127.0.0.1:6379&gt; hincrby stu1 age -1(integer) 19127.0.0.1:6379&gt; hincrby stu1 age -2(integer) 17127.0.0.1:6379&gt; hincrby stu1 name 1(error) ERR hash value is not an integer hincrbyfloatHINCRBYFLOAT key field increment hincrbyfloat 命令用于为哈希表中的字段值加上浮点数增量值。如果指定的字段不存在，那么在执行命令前，该字段会被初始化为0. 12345678127.0.0.1:6379&gt; hkeys stu11) \"name\"2) \"age\"3) \"sex\"127.0.0.1:6379&gt; hincrbyfloat stu1 salary 10.5\"10.5\"127.0.0.1:6379&gt; hincrbyfloat stu1 salary 1\"11.5\" hexistsHEXISTS key field hexists 命令用于查看哈希表中的指定字段是否存在。 123456127.0.0.1:6379&gt; hdel stu1 salary(integer) 1127.0.0.1:6379&gt; hexists stu1 name(integer) 1127.0.0.1:6379&gt; hexists stu1 salary(integer) 0 hlenHLEN key hlen 命令用于获取哈希表中字段的数量。 12127.0.0.1:6379&gt; hlen stu1(integer) 3 hkeysHKEYS key hkeys 命令用于获取哈希表中的所有域(field). 1234127.0.0.1:6379&gt; hkeys stu11) \"name\"2) \"age\"3) \"sex\" hvalsHVALS key hvals 命令返回哈希表所有的字段的值。 1234127.0.0.1:6379&gt; hvals stu11) \"ooyhao\"2) \"23\"3) \"male\" 本文参考自菜鸟教程:https://www.runoob.com/redis/redis-hashes.html 更多请移步官网","link":"/2020/02/22/db/redis/7.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/"},{"title":"6.redis 数据类型之set 集合","text":"redis 数据类型之set 集合 集合简介 Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 集合操作命令saddSADD key member1 [member2] 向集合添加一个或多个成员 12127.0.0.1:6379&gt; sadd set 1 2 3 4 5 1(integer) 5 通过上面的返回值可以看出，其实存储进去的只有5个值，所以也可以看出set集合是不可重复的。 smembersSMEMBERS key 上面使用了sadd添加命令，往集合中添加了数据。下面我们将集合的成员查询出来： 123456127.0.0.1:6379&gt; smembers set1) \"1\"2) \"2\"3) \"3\"4) \"4\"5) \"5\" scardSCARD key 通过scard命令，可以获取集合的成员个数。如下： 12127.0.0.1:6379&gt; scard set(integer) 5 sismemberSISMEMBER key member 判断member元素是否是集合key的成员。如果元素是集合中的成员，则返回1，否则返回0。如下： 1234127.0.0.1:6379&gt; sismember set 1(integer) 1127.0.0.1:6379&gt; sismember set 9(integer) 0 spopSPOP key [count] spop命令用于移除集合中的指定key的一个或多个随机元素。移除后会返回移除的元素。 12345678910127.0.0.1:6379&gt; sadd num 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; spop num 11) \"3\"127.0.0.1:6379&gt; spop num 21) \"4\"2) \"5\"127.0.0.1:6379&gt; smembers num1) \"1\"2) \"2\" 通过执行结果可以看出，已经将返回的元素删除了。 srandmemberSRANDMEMBER KEY [count] 如果count为正数，且小于集合基数，那么命令返回一个包含count个元素的数组，数据中的元素各不相同。如果count大于等于集合基数，那么返回整个集合。 如果count为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为count的绝对值。 123456789101112131415161718192021222324127.0.0.1:6379&gt; sadd num 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; srandmember num 21) \"3\"2) \"2\"127.0.0.1:6379&gt; srandmember num 21) \"2\"2) \"1\"127.0.0.1:6379&gt; srandmember num 51) \"1\"2) \"2\"3) \"3\"4) \"4\"5) \"5\"127.0.0.1:6379&gt; srandmember num 61) \"1\"2) \"2\"3) \"3\"4) \"4\"5) \"5\"127.0.0.1:6379&gt; srandmember num -31) \"5\"2) \"5\"3) \"4\" sremSREM key member1 [member2] srem 命令用于移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。 12345678127.0.0.1:6379&gt; sadd num 1 2 3 4 5(integer) 0127.0.0.1:6379&gt; srem num 1 2 6(integer) 2127.0.0.1:6379&gt; smembers num1) \"3\"2) \"4\"3) \"5\" 返回值即被成功移除的元素的数量，不包含的元素忽略。 smoveSMOVE SOURCE DESTINATION MEMBER smove 命令将指定成员member元素从source集合中移动到destination集合中。smove是原子性操作。 如果source集合不存在或是不包含指定的member元素，则smove命令不执行任何操作，仅返回0. 否则,member元素从source集合中被移除，并添加到destination集合中取。 当destination集合中已经包含member元素时，smove命令只是简单地将source集合中的元素删除而已。 当source或destination不是集合类型时，返回错误。 1234567891011121314151617127.0.0.1:6379&gt; smembers num1) \"3\"2) \"4\"3) \"5\"127.0.0.1:6379&gt; smove num newNum 3 4(error) ERR wrong number of arguments for 'smove' command127.0.0.1:6379&gt; smove num newNum 3(integer) 1127.0.0.1:6379&gt; smove num newNum 3(integer) 0127.0.0.1:6379&gt; smove num newNum 4(integer) 1127.0.0.1:6379&gt; smembers num1) \"5\"127.0.0.1:6379&gt; smembers newNum1) \"3\"2) \"4\" 同时通过执行命令可以看出，执行smove命令时，只允许一次move一个元素。 sinterSINTER key1 [key2] sinter 命令返回给定所有集合的交集。不存在的集合key视为空集。当给定集合中有一个空集时，结果也为空集（根据集合运算定律）。 1234567127.0.0.1:6379&gt; sadd num1 1 2 3 4(integer) 4127.0.0.1:6379&gt; sadd num2 3 4 5 6(integer) 4127.0.0.1:6379&gt; sinter num1 num21) \"3\"2) \"4\" sinterstoreSINTERSTORE destination key1 [key2] sinterstore 命令将给定集合之间的交集存储在给定的destination集合中。如果指定的集合已经存在了，则将其覆盖。 12345127.0.0.1:6379&gt; sinterstore num3 num1 num2(integer) 2127.0.0.1:6379&gt; smembers num31) \"3\"2) \"4\" sdiffSDIFF key1 [key2] sdiff 命令返回给定集合之间的差集。不存在的集合key将视为空集。 差集的结果来自前面的first_key, 而不是后面的other_key。如下： 123456127.0.0.1:6379&gt; sdiff num1 num21) \"1\"2) \"2\"127.0.0.1:6379&gt; sdiff num2 num11) \"5\"2) \"6\" sdiffstoreSDIFFSTORE destination key1 [key2] sdiffstore 命令将给定的集合之间的差集存储到指定的destination集合中。如果指定的集合key已经存在，则会被覆盖。 12345678910127.0.0.1:6379&gt; sdiffstore num4 num1 num2(integer) 2127.0.0.1:6379&gt; smembers num41) \"1\"2) \"2\"127.0.0.1:6379&gt; sdiffstore num4 num2 num1(integer) 2127.0.0.1:6379&gt; smembers num41) \"5\"2) \"6\" sunionSUNION key1 [key2] sunion 命令返回给定集合的并集。不存在的集合key被视为空集。 1234567127.0.0.1:6379&gt; sunion num1 num21) \"1\"2) \"2\"3) \"3\"4) \"4\"5) \"5\"6) \"6\" sunionstoreSUNIONSTORE destination key1 [key2] sunionstore 命令将给定的集合的并集存储在指定的集合destination中。如果指定集合destination已经存在，则覆盖。 1234567891011127.0.0.1:6379&gt; sadd num5 11127.0.0.1:6379&gt; sunionstore num5 num1 num2(integer) 6127.0.0.1:6379&gt; smembers num51) \"1\"2) \"2\"3) \"3\"4) \"4\"5) \"5\"6) \"6\" 部分参考自菜鸟教程：https://www.runoob.com/redis/redis-sets.html","link":"/2020/02/22/db/redis/6.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bset/"},{"title":"9.Redis 发布订阅模式","text":"Redis 发布订阅模式 简介Redis发布订阅(pub/sub) 是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接受消息。 Redis客户端可以订阅任意数量的频道。 下图展示了频道channel 1 ， 以及订阅这个频道的三个客户端 – client2， client5， client1之间的关系： 当有新消息通过publish命令发送到频道channel1时，这个消息就会被发送给订阅它的三个客户端： 实例下面我们通过实验来实现以下： 首先打开两个窗口，用来模拟两个客户端，并且同时订阅channel1频道。 再打开一个窗口，用来模拟发布者发送消息。 发布者截图： 订阅者截图： 命令集合publishPUBLISH channel message publish 命令用于将信息发布到指定的频道中去。 12127.0.0.1:6379&gt; publish c2 \"hello redis!\"(integer) 1 subscribeSUBSCRIBE channel [channel ...] subscribe 命令用于订阅给定的一个或多个频道的信息。 1234567891011127.0.0.1:6379&gt; subscribe c1 c2 c3Reading messages... (press Ctrl-C to quit)1) \"subscribe\"2) \"c1\"3) (integer) 11) \"subscribe\"2) \"c2\"3) (integer) 21) \"subscribe\"2) \"c3\"3) (integer) 3 psubscribePSUBSCRIBE pattern [pattern ...] psubscribe 命令订阅一个或多个符合给定模式的频道。每个模式以 * 作为通配符，比如 it* 匹配所有以it开头的频道(itenews, it.news, it.blog, it.tweets等等)。news.* 匹配所有以new.开头的频道(news.it, news.global.today等等)。 发布端： 12127.0.0.1:6379&gt; publish news.it \"message news it\"(integer) 1 订阅端： 123456789127.0.0.1:6379&gt; psubscribe news.*Reading messages... (press Ctrl-C to quit)1) \"psubscribe\"2) \"news.*\"3) (integer) 11) \"pmessage\"2) \"news.*\"3) \"news.it\"4) \"message news it\" 可以看出，使用psubscribe 可以按模式规则进行订阅。 unsubscribeUNSUBSCRIBE [channel [channel ...]] unsubscribe 命令用于退订给定的一个或多个频道的信息。 punsubscribePUNSUBSCRIBE [pattern [pattern ...]] punsubscribe 命令用于退订所有给定模式的频道。 注意： redis中的发布订阅系统在某些场景下还是非常好用的，但是也有一些问题需要注意：由于网络在传输过程中可能会遭遇到断线等意外情况，断线后需要重新连接，然而这会导致断线期间的数据丢失。 好了，Redis的发布订阅模式就到这里了。更加详细的文档请移步官网。 redis官网：http://www.redis.cn/commands.html#pubsub 参考自： https://www.runoob.com/redis/redis-pub-sub.html http://www.javaboy.org/2019/0615/redis-pub-sub.html","link":"/2020/02/22/db/redis/9.redis%E4%B9%8B%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"},{"title":"SpringBoot 整合 Hessian","text":"Hessian简介Hessian是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。但是它的参数和返回值都需要实现Serializable接口 Hessian使用 Hessian分为服务端和客户端。 服务端则负责提供服务，客户端则消费服务。但是服务器和客户端不是绝对的。 使用springboot整合Hessian 共有模块接口1234public interface HelloWorldService { List&lt;User&gt; insertUserAndGetAll(User user);} User实体12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ooyhao.hessianserver.javahessianserver.bean;import java.io.Serializable;public class User implements Serializable { private String username; private Integer age; private String email; public User() { } public User(String username, Integer age, String email) { this.username = username; this.age = age; this.email = email; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; }} 服务端依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hessian --&gt; &lt;dependency&gt; &lt;groupId&gt;com.caucho&lt;/groupId&gt; &lt;artifactId&gt;hessian&lt;/artifactId&gt; &lt;version&gt;4.0.38&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springboot-mvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ooyhao.hessian&lt;/groupId&gt; &lt;artifactId&gt;java-hessian-common&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意：如果不实现Serializable接口，会出现以下错误，所以，接口的返回值和参数都必须实现Serializable接口。 ServiceImpl123456789101112131415161718@Servicepublic class HelloWorldServiceImpl implements HelloWorldService { @Override public List&lt;User&gt; insertUserAndGetAll(User user) { List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { User u = new User(); u.setUsername(\"Tom\"+i); u.setAge(10+i); u.setEmail(i+\"123456@163.com\"); users.add(u); } users.add(user); return users; }} config文件1234567891011121314@Configurationpublic class HessianConfig { @Autowired private HelloWorldService helloWorldService; @Bean(name = \"/hessianService\") public HessianServiceExporter hessianService(){ HessianServiceExporter exporter = new HessianServiceExporter(); exporter.setService(helloWorldService); exporter.setServiceInterface(HelloWorldService.class); return exporter; }} 客户端依赖123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hessian --&gt; &lt;dependency&gt; &lt;groupId&gt;com.caucho&lt;/groupId&gt; &lt;artifactId&gt;hessian&lt;/artifactId&gt; &lt;version&gt;4.0.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ooyhao.hessian-server&lt;/groupId&gt; &lt;artifactId&gt;java-hessian-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ooyhao.hessian&lt;/groupId&gt; &lt;artifactId&gt;java-hessian-common&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 上述依赖可以看出：客户端需要依赖服务端，所以，需要将服务端打包成jar。 config文件12345678910@Configurationpublic class HessianConfig { @Bean public HessianProxyFactoryBean helloClient(){ HessianProxyFactoryBean factoryBean = new HessianProxyFactoryBean(); factoryBean.setServiceUrl(\"http://localhost:8080/hessianService\"); factoryBean.setServiceInterface(HelloWorldService.class); return factoryBean; }} 调用服务123456789101112131415@RestControllerpublic class HelloWorldController { @Autowired private HelloWorldService helloWorldService; @RequestMapping(\"/test\") public List&lt;User&gt; test(){ User u = new User(); u.setEmail(\"625194999@qq.com\"); u.setAge(23); u.setUsername(\"ooyhao\"); return helloWorldService.insertUserAndGetAll(u); }} 效果","link":"/2020/01/29/middleWare/hessian/SpringBoot%E6%95%B4%E5%90%88Hessian/"},{"title":"String 类","text":"String 类 部分参考自：https://www.cnblogs.com/ysocean/p/8571426.html#_label0 定义String类是一个不可变类。其一旦被赋值，就不能别修改了。 我们先来看一下源码： 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { private final char value[]; private int hash;} 我们都知道String类是一个不可变类。首先String类是被final修饰的类，不能被任何类继承，而且由于内部属性value数组也被final修饰，一旦被创建之后，包含在这个对象中的字符序列是不可改变的，包括该类后续的所有方法都是不能修改该对象的，直至该对象被销毁，这是我们需要特别注意的（该类的一些方法看似改变了字符串，其实内部都是创建一个新的字符串）。 通过上面的代码可以看到，String内部其实是一个字符数组char[] ，这里使用的JDK版本是8.x的。在后面的版本改为了byte[]数组，网上说9.x之后改的。我没有下载9.x，看的是11.x，内部确实改为了byte[]. 网上扯来了一张图： 看完String类的基本特点之后，我们看一下方法： 构造方法String类的构造方法有很多，我们来看一下： 无参构造方法： 123public String() { this.value = \"\".value;} 字符串构造方法： 1234public String(String original) { this.value = original.value; this.hash = original.hash;} 以及利用字符数组，字节数组 和 StringBuffer 以及 StringBuilder来创建。 示例： 123456String str0 = new String();String str1 = new String(\"abc\");String str2 = new String(new char[]{'a', 'b', 'c'});String str3 = new String(new byte[]{1, 2, 3});String str4 = new String(new StringBuilder());String str5 = new String(new StringBuffer()); 除了上面的示例，还有一些特殊处理的。比如取数组的某个区间创建字符串。 常用的普通方法获取长度和判空的方法123456public int length() { return value.length;}public boolean isEmpty() { return value.length == 0;} 获取当前字符串中指定位置的字符说明：通过其源码可以看出，其实就是获取value数组第index位置上的字符。由于数组下标从0开始，所以这里的index也是从0开始的。 123456public char charAt(int index) { if ((index &lt; 0) || (index &gt;= value.length)) { throw new StringIndexOutOfBoundsException(index); } return value[index];} 获取字符串的字节数组123public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {}public byte[] getBytes(Charset charset) {}public byte[] getBytes() {} 比较字符串是否相同通过方法名即可知道equalsIgnoreCase是忽略大小写的，则equals是区分大小写的比较，即A 和 a 是false 12public boolean equals(Object anObject) {}public boolean equalsIgnoreCase(String anotherString) {} 比较字符串大小，返回值是int12public int compareTo(String anotherString) {}public int compareToIgnoreCase(String str) {} 以xx开头，以xx结尾实用场景： startsWith：比如判断某一类路径，不走拦截器拦截，以/static开头的静态文件不拦截。 endsWith：比如获取所有的pdf文件，那就需要判断是否是以.pdf结尾的。 123public boolean startsWith(String prefix, int toffset) {}public boolean startsWith(String prefix) {}public boolean endsWith(String suffix) {} 获取指定元素的下标获取指定字符，指定字符串第一次出现的位置，最后一次出现的位置。 12345678public int indexOf(int ch) {}public int indexOf(int ch, int fromIndex) {}public int lastIndexOf(int ch) {}public int lastIndexOf(int ch, int fromIndex) {}public int indexOf(String str) {}public int indexOf(String str, int fromIndex) {}public int lastIndexOf(String str) {}public int lastIndexOf(String str, int fromIndex) {} 这里需要注意，我们的方法中只提供 int和String类型的参数，但是我们可以传入char类型的，这里就涉及到了类型转换问题： 1234567String str = \"abcda\";System.out.println(str.indexOf('a')); //0System.out.println(str.lastIndexOf('a')); //4System.out.println(str.indexOf(98)); //1System.out.println(str.lastIndexOf(99)); //2System.out.println(str.indexOf(\"bc\")); //1System.out.println(str.lastIndexOf(\"bc\")); //1 类型转换：左边的类型可以自动类型转换为右边的类型，反过来则需要强制类型转换。 byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double char -&gt; int -&gt; long -&gt; float -&gt; double 子串subString12345678910111213141516171819202122232425public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);}public String substring(int beginIndex, int endIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex &gt; value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);} 可以看出，subString方法是获取指定区间的字符数组新创建String或是返回当前字符串本身。 字符串拼接12345678910public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);} 通过方法可以知道，方法体直接调用的是length方法，所以传入的参数不能为空，否则会抛出空指针异常。字符串拼接，会返回一个新的字符串对象，不会修改原来数据。 字符串替换具体实现先不看，直接看返回值，可以看出，同样是方法当前对象或是重新构建一个新的对象。 解释： replace: 单个字符替换，将所有相同的字符全部替换 replaceFirst: 见名知意，替换第一个相同的字符串 replaceAll:同样，将所有相同的字符串全部替换，只是replaceFirst和replaceAll支持正则表达式。 replace：则是CharSequence类型的参数。下面是CharSequence的实现类。 1234public String replace(char oldChar, char newChar) {}public String replaceFirst(String regex, String replacement) {}public String replaceAll(String regex, String replacement) {}public String replace(CharSequence target, CharSequence replacement) {} 我们看其中一个方法； 说明：从源码我们可以知道，返回值是一个新的对象或是本身，同时会把所有相同的对象全部替换。 1234567891011121314151617181920212223242526public String replace(char oldChar, char newChar) { if (oldChar != newChar) { int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) { if (val[i] == oldChar) { break; } } if (i &lt; len) { char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) { buf[j] = val[j]; } while (i &lt; len) { char c = val[i]; buf[i] = (c == oldChar) ? newChar : c;//一直遍历到最后，所以会把相同的串全部替换 i++; } return new String(buf, true); } } return this;} 判断字符串是否满足格式1public boolean matches(String regex) {} 可以看出，接受一个正则表达式串，来判断当前字符串是否满足格式。 判断字符串是否包含指定子串1public boolean contains(CharSequence s) {} 分割字符串12public String[] split(String regex, int limit) {}public String[] split(String regex) {} 转换大小写1234public String toLowerCase(Locale locale) {}public String toLowerCase() {}public String toUpperCase(Locale locale) {}public String toUpperCase() {} 去除空白符同样没有修改原有的字符，调用的是subString方法，用来获取子串，也是新创建的字符串对象。 12345678910111213public String trim() { int len = value.length; int st = 0; char[] val = value; while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) { st++; } while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) { len--; } return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;} 加分隔符并返回字符串12public static String join(CharSequence delimiter, CharSequence... elements) {}public static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements) {} 实例： 123456789List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(\"AA\");stringList.add(\"BB\");stringList.add(\"CC\");String join = String.join(\"|\", stringList);System.out.println(join);// AA|BB|CCSystem.out.println(String.join(\"@\",\"A\",\"B\",\"C\"));// A@B@C 获取字符串的字节数组123456public char[] toCharArray() { // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result;} 其他类型转为字符串1234567891011public static String valueOf(Object obj) {}public static String valueOf(char data[]) {}public static String valueOf(char data[], int offset, int count) {}public static String copyValueOf(char data[], int offset, int count) {}public static String copyValueOf(char data[]) {}public static String valueOf(boolean b) {}public static String valueOf(char c) {}public static String valueOf(int i) {}public static String valueOf(long l) {}public static String valueOf(float f) {}public static String valueOf(double d) {} 功能就是将传入的参数转为字符串，这里不详细说。 注意：我们基本把String中的方法都看遍了，可以发现，String内部都没有去修改原有字符串的内容，由于字符串是不可变类，我们也不法修改String的内容，所以转替换，转大小写，删空白符等操作，都是通过新建String对象来实现的。 String为什么是不可变类上面我们介绍了如何保证String类是不可变类：①利用final关键字修饰String类，这样String就不能被继承，就无法被继承修改。②利用final修改属性value，就意味着value属性一旦初始化，就不可以修改。 但是我们都知道value属性是一个数组，虽然我们不能修改value属性的引用，但是我们可以修改数组中具体的某个下标元素，如下： 12final int val[] = {1,23,3};val[1] = 20;//[1, 20, 3] 也就是说，要实现真正的不可变类String，并不会仅仅因为这两个final关键字修饰。通过上面我们分析的普通方法可以知道，所以设计到修改字符串的方法，都是构建了新的字符串实例之后返回的，也就是JDK设计者在设计的时候，已经保证了所提供的方法是不会修改value数组的数据的。所以，综合上述三个条件，才能实现真正的不可变类。如下： final修饰类：保证String类无法被继承，从而无法通过重写方法来修改原有String类的方法功能。 final修饰value：保证value属性一旦被初始化，其引用就是固定的，不能修改。 方法不修改value数组的具体元素：保证在使用String提供的方法时，都不会修改String内部的数据。 String类为什么要设计成不可变类 部分引用：https://www.cnblogs.com/ysocean/p/8571426.html 原因： 安全 hashcode缓存的需要 实现字符串常量池（效率高） 安全如果字符串可变的话，可能会引发安全问题，比如数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket变成中，主机和端口都是以字符串的形式传入的。因为字符串是不可变的，所以它的值是不可以变的，否则黑客可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。 hashcode缓存的需要首先我们需要先看一下String类的hashcode的计算方法： 12345678910111213private int hash; // Default to 0public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} 可以看到，hashcode只在第一次进行计算，后续调用这个对象时，直接返回缓存在对象中的hash值。hashcode的计算与value有关，若String可变，那么hashcode也需要随之进行计算，针对于Map，Set等容器，他们的键值需要保证唯一性和一致性，因此，String的不可变性使其比其他对象更加适合当容器的键值对。 实例：如果我们不用String类型的不可变类来存，而使用StringBuilder这种可变类来操作，往HashSet中存值，如下： 12345678public static void main(String[] args) { StringBuilder sb1 = new StringBuilder(\"AA\"); StringBuilder sb2 = new StringBuilder(\"AA\"); HashSet&lt;StringBuilder&gt; set = new HashSet&lt;&gt;(); set.add(sb1); set.add(sb2); System.out.println(set);//[AA, AA]} 可以看出，想StringBuilder这种没有重写hashcode方法，调用的Object的。把sb1和sb2进行了区分，这对于我们来说就相当于存储了相同的值。 实现字符串常量池这个原因是非常主要的，只有保证了字符串类的不可变性，才有实现字符串常量池的必要性。 常量池：Java运行时会维护一个String Pool（String池），也叫“字符串缓存池”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。 ①、字面量创建字符串或者纯字符串（常量）拼接字符串会现在字符串池中找，看是否有相等的对象，没有的话就在字符串池创建该对象；有的话则直接用池中的引用，避免重复创建对象。 ②、new关键字创建时，直接在堆中创建一个新的对象，变量所引用的都是这个新对象的地址，但是如果new关键字创建的字符串内容在常量池中存在了，那么会由堆再指向常量池中对应的字符；但是反过来，如果通过new关键字创建的字符串对象在常量池中没有，那么通过new关键字创建的字符串对象是不会额外在常量池中维护的。 ③、使用包含变量表达式来创建String对象，则不仅会检查维护字符串池，还会在堆区创建这个对象，最后是指向堆内存的对象。 我们先来看一个题目： 123456789String str1 = \"hello\";String str2 = \"hello\";String str3 = new String(\"hello\");System.out.println(str1==str2); System.out.println(str1==str3);System.out.println(str2==str3);System.out.println(str1.equals(str2));System.out.println(str1.equals(str3));System.out.println(str2.equals(str3)); 首先，str1是字面量创建对象的，所以会先看字符串常量池中查看有没有”hello”对象，发现没有，会先在字符串常量池中创建，再将其引用返回，而此时str2创建时，字符串常量池中已经存在了，所以就直接返回”hello”对象的引用。当str3通过new对象创建时，会先在堆中创建对象，然后查询常量池，发现里面存在了”hello”对象，于是将其指向字符串常量池中的对象。 我们再来看一个题目： 123456789public static void main(String[] args]{ String str1 = \"hello\"; String str2 = \"helloworld\"; String str3 = str1+\"world\"; String str4 = \"hello\"+\"world\"; System.out.println(str2==str3); System.out.println(str2==str4); System.out.println(str3==str4);} 上面的结果是什么呢？ 我们先看一下反编译之后的结果： 123456789public static void main(String[] args) { String str1 = \"hello\"; String str2 = \"helloworld\"; String str3 = str1 + \"world\"; String str4 = \"helloworld\"; System.out.println((str2 == str3)); System.out.println((str2 == str4)); System.out.println((str3 == str4));} 首先 str1 是利用字符串字面量来创建对象。str2也是。可以看出，str4编译器能够明确这两个是不变的，就进行优化了，而str3中带有str1，编译器是无法确定里面的值的。 对于str1，内存操作步骤是： 先查询字符串常量池用存不存在”hello”对象。 存在，直接返回字符串常量池中”hello”对象的引用 不存在，在字符串常量池中创建”hello”对象，并返回其引用。 str2 依旧如此。那么此时字符串常量池中已经有&quot;hello&quot;对象和&quot;helloworld&quot;对象了。当执行到str3时，由于此时不是字面量创建了，str3会先在堆内存中创建一个String对象，再去查询str1+world拼接后的”helloworld”对象是否存在于字符串常量池中，如果存在，则直接将str3中的对象指向常量池中”helloworld”对象的。如果不存在，则只会在堆中创建。 而当执行str4时，其实与str2的效果一样，同样是直接查询常量池。如图： 至此，我们再回来看这个题目： 123456789public static void main(String[] args]{ String str1 = \"hello\"; String str2 = \"helloworld\"; String str3 = str1+\"world\"; String str4 = \"hello\"+\"world\"; System.out.println(str2==str3);//false System.out.println(str2==str4);//true System.out.println(str3==str4);//false} 可能看到这，会有这样的疑惑，堆中创建了对象怎么再指向常量池呢？ 参考自：https://segmentfault.com/a/1190000009888357 字符串对象内部是用字符数组存储的，那么看下面的例子: 12345678String m = \"hello,world\";String n = \"hello,world\";String u = new String(m);String v = new String(\"hello,world\");System.out.println(m == n);System.out.println(m == u);System.out.println(m == v);System.out.println(u == v); 会分配一个11长度的char数组，并在常量池分配一个由这个char数组组成的字符串，然后由m去引用这个字符串。String m = &quot;hello,world&quot; 用n去引用常量池中的字符串对象，所以和m引用的是同一个对象。 在堆中生成一个新的字符串，但是其内部的字符数组是引用m内部的字符数组。 同样会生成一个新的字符串，但内部的字符数组引用常量池中的m的字符数组，意思是和u是同样的字符数组。 图示：情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系) 综上，所以题目结果为： 1234System.out.println(m == n);//trueSystem.out.println(m == u);//falseSystem.out.println(m == v);//falseSystem.out.println(u == v);//false 结论： m和n是同一个对象。 m,u,v都是不同的对象 m,n,u,v都使用了同样的字符数组，并且用equals判断的话也会返回true。 上面说到了m,n,u,v都是使用了同样的字符数组，但是我们使用正常的方式又获取不到value属性，那么我们使用反射来看一下具体的地址和值。 123456789101112131415161718192021public static void main(String[] args) throws Exception { String m = \"hello,world\"; String n = \"hello,world\"; String u = new String(m); String v = new String(\"hello,world\"); Field value = String.class.getDeclaredField(\"value\"); value.setAccessible(true); printMsg(m, value); printMsg(n, value); printMsg(u, value); printMsg(v, value);}private static void printMsg(String m,Field value) throws IllegalAccessException { Object o = value.get(m); System.out.println(\"字符数组地址：\"+o); System.out.println(\"字符串地址：\"+System.identityHashCode(m)); System.out.println(\"字符数组内容：\"+Arrays.toString((char[])o)); System.out.println(\"-------------------------------------\");} 结果如图： 可以看到获取到m,n,u,v四个对象中的char[] value数组的地址都是相同的。m和n的地址也是一样的 可变的StringString类的字符数组真的修改不了吗？String对象真的是一个绝对的不可变对象吗？不！下面我们来看一下，如果真的需要修改，如何修改String对象。 定义一个字符串String str = &quot;hello&quot;; 如果将其值修改为Hello;这里说的是真正的修改，str的地址不能变。 修改实例： 1234567891011121314public static void main(String[] args) throws Exception { String str = \"hello\"; //获取所有的value属性 Field value = String.class.getDeclaredField(\"value\"); //设置为可访问 value.setAccessible(true); //获取属性值 Object o = value.get(str); //转为字符数组 char[] val = (char[]) o; //修改字符数组 val[0] = 'H'; System.out.println(str);//Hello} 如上所示，可以进行字符串内容的修改，但是需要使用到反射技术。但是一般不会进行这样的操作，所以可以说String类是不可变的类。","link":"/2020/04/08/%E5%9F%BA%E7%A1%80/String/"},{"title":"解决maven下载jar包失败，生成lastUpdate文件","text":"解决maven下载jar包失败，生成lastUpdate文件 在maven的settings.xml配置文件中，修改mirror 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 保存之后，右键你的项目，maven-&gt;update一下就好了 参考自：https://blog.csdn.net/weixin_41110459/article/details/81154488","link":"/2020/02/29/tools/idea/%E8%A7%A3%E5%86%B3maven%E4%BE%9D%E8%B5%96%E7%94%9F%E6%88%90lastUpdate%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/"},{"title":"二、Mybatis配置文件","text":"​在第一节中我们看到了Mybatis的部分配置信息，这些信息是基础信息，足以先将Mybatis拿来玩弄一下，但是在把玩一番之后，我们知道了Mybatis的基本使用方法，但是对于配置文件的详细信息和结果映射、动态Sql等好东西并没有好好研究，下面几节将一一进行介绍。 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 配置文件结构123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt; 注意：这个配置文件的标签元素是有顺序的，需要按顺序配置。如下： 12configuration:properties -&gt; settings? -&gt; typeAliases -&gt; typeHandlers -&gt; objectFactory -&gt; objectWrapperFactory -&gt; reflectorFactory -&gt; plugins -&gt; environments -&gt; databaseIdProvider -&gt; mappers 我们回头看第一节中的配置文件也可以看出这个顺序，虽然其中有一些没有配置。 propertiesdb.properties: 12345678jdbc.driver= com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://120.79.167.88:3306/mybatis? useUnicode=true &amp;characterEncoding=UTF-8 &amp;allowMultiQueries=true &amp;autoReconnect=true&amp;useSSL=falsejdbc.username = rootjdbc.password = root properties标签： 1234&lt;!--引入properties的属性文件--&gt;&lt;properties resource=\"mybatis.properties\"&gt; &lt;property name=\"username\" value=\"root\"/&gt;&lt;/properties&gt; 我们可以直接读取文件，也可以补充属性文件中没有的属性。 如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载： 在 properties 元素体内指定的属性首先被读取。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。 settings12345678&lt;!--设置使用驼峰命名--&gt;&lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"logPrefix\" value=\"##Mybatis##\"/&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; settings一般是一些配置，所以我们看一下官网的介绍： 一个配置完整的 settings 元素的示例如下： 1234567891011121314151617&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; typeAliases类型别名就是为Java类型设置一个短的名字。它只和XML配置相关，存在的意义仅在于用来减少类全限定名的冗余。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Bus\" type=\"com.ooyhao.mybatis3.bean.Bus\"/&gt; &lt;typeAlias alias=\"Car\" type=\"com.ooyhao.mybatis3.bean.Car\"/&gt; &lt;typeAlias alias=\"Subway\" type=\"com.ooyhao.mybatis3.bean.Subway\"/&gt; &lt;typeAlias alias=\"User\" type=\"com.ooyhao.mybatis3.bean.User\"/&gt; &lt;typeAlias alias=\"Role\" type=\"com.ooyhao.mybatis3.bean.Role\"/&gt; &lt;typeAlias alias=\"Card\" type=\"com.ooyhao.mybatis3.bean.Card\"/&gt;&lt;/typeAliases&gt; 如上所述配置计较麻烦，我们可以配置一个包，让其所有都遵循这个规则： 12345&lt;!--设置别名--&gt;&lt;!-- mybatis自动扫描包中的po类，自动定义别名，别名是类名(首字母大写或小写都可以,一般用小写) --&gt;&lt;typeAliases&gt; &lt;package name=\"com.ooyhao.mybatis3.bean\"/&gt;&lt;/typeAliases&gt; 我们还可以在此基础上使用注解修改默认取的别名： 12@Alias(\"card\")public class Card implements Serializable {} ​ 这是一些为常见的 Java 类型内建的相应的类型别名。它们都是不区分大小写的，注意对基本类型名称重复采取的特殊命名风格。 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator environmentsMyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中 使用相同的 SQL 映射。有许多类似的使用场景。 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单： 环境元素定义了如何配置环境: 123456789101112131415&lt;!--配置环境--&gt;&lt;environments default=\"development\"&gt; &lt;!--可以用来配置不同环境的参数，例如：开发，测试，生产--&gt; &lt;environment id=\"development\"&gt; &lt;!--事务管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--数据源--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 这里关键的点： 默认使用的环境ID（比如：default=”development”） 每个environment元素定义的环境ID（比如：id=”development”） 事务管理器的配置（比如：type=”JDBC”） 数据源的配置（比如：type=”POOLED”） 默认的环境和环境 ID 是自解释的，因此一目了然。 你可以对环境随意命名，但一定要保证默认的环境 ID 要匹配其中一个环境 ID。 事务管理器（TransactionManager） 在Mybatis中有两种类型的事务管理器（也就是type=”[JDBC|MANAGED]”）: JDBC - 这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域 MANAGED - 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如: 123&lt;transactionManager type=\"MANAGED\"&gt; &lt;property name=\"closeConnection\" value=\"false\"/&gt;&lt;/transactionManager&gt; 提示:如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 ​ 数据源（dataSource） dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 许多 MyBatis 的应用程序会按示例中的例子来配置数据源。虽然这是可选的，但为了使用延迟加载，数据源是必须配置的。 有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）： UNPOOLED 这个数据源的实现只是每次被请求时打开和关闭连接。虽然有点慢，但对于在数据库连接可用性方面没有太高要求的简单应用程序来说，是一个很好的选择。 不同的数据库在性能方面的表现也是不一样的，对于某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形 driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式 JNDI – 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用 mappers既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。 但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如： 1234567&lt;!--mapper xml文件--&gt;&lt;mappers&gt; &lt;!--&lt;package name=\"mapper\"/&gt;--&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;mapper resource=\"mapper/RoleMapper.xml\"/&gt; &lt;mapper resource=\"mapper/VehicleMapper.xml\"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/UserMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/RoleMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/VehicleMapper.xml\"/&gt;&lt;/mappers&gt; 总结：这节主要介绍一下Mybatis的全局配置文件中的常见配置，如果需要完整了解的可以参考官方文档。 源码地址： https://gitee.com/ooyhao/JavaRepo_Public/tree/master/Mybatis","link":"/2020/01/18/SSM/mybatis/2Mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"title":"五、Mybatis参数传递","text":"Mybatis参数传递 概述​ 参数传递在Mybatis中也是非常重要的。存在诸多情况，如下所介绍的单个参数，多个参数，对象，集合和数组等。 1234567891011121314151.单个的参数Mybatis不会做特殊处理 #{这里随便写什么都可以} 它都能把这里面的值取到2.传入对象POJO(普通的java类).. #{对象的属性名称}3.多个参数。Mybatis会做特殊处理。会把传入的参数自动封装成Map类型 Map 的key值就是从param1...paramN .. map.put(\"param1\",name) map.put(\"param2,id\") @param(\"name\") 可以使用这个注解 来自定义Map封装数据的key值。4.直接传入Map5.Collection(集合)类型(List,Set) ,数组。 Mybatis也会做特殊处理。。 如果是List或者Set 封装到map中 如果是数组 map.put(\"array\",你传入的数组) 单个参数Mapper接口的方法： 1List&lt;User&gt; findUsersByUsername(String username); Mapper.xml文件： 12345678&lt;select id=\"findUsersByUsername\" resultType=\"user\"&gt; select &lt;include refid=\"Base_Column_List\"/&gt; from tb_user &lt;where&gt; username = #{value} &lt;/where&gt;&lt;/select&gt; 注意： ​ 其中方法名和id一致，#{}中的参数名与方法中的参数名k可以不一致， 映射结果的时候，select 后的字段列表要和bean中的属性名一致， 如果不一致的可以用 as 来补充，特殊的也可以再mybatis中启用驼峰，比如create_time 和 createTime; 多个参数方法1：使用方法参数下标Mapper接口的方法： 1List&lt;User&gt; findUsersByUsernamePassword1(String username, String password); 对应的Mapper.xml: 123456789&lt;!--方法1.1--&gt;&lt;select id=\"findUsersByUsernamePassword1\" resultType=\"user\" &gt; select * from tb_user where username = #{arg0} and password = #{arg1}&lt;/select&gt;&lt;!--方法1.2--&gt;&lt;select id=\"findUsersByUsernamePassword1\" resultType=\"user\" &gt; select * from tb_user where username = #{0} and password = #{1}&lt;/select&gt; 注意： 有 些版本在使用上有不同，我使用的是 org.mybatis:mybatis:3.5.2版本，需要使用方法1.1。 方法2：使用注解 @Param 别名Mapper接口的方法： 12List&lt;User&gt; findUsersByUsernamePassword2(@Param(\"username\") String username, @Param(\"password\") String password); 对应的Mapper.xml文件： 12&lt;select id=\"findUsersByUsernamePassword2\" resultType=\"user\"&gt; select * from tb_user where username = #{username} and password = #{password}&lt;/select&gt; 方法3：使用实体Mapper接口的方法： 12345678910111213List&lt;User&gt; findUsersByUsernamePassword3(User user);// 调用方式@Testpublic void testFindUsersByUsernamePassword3(){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername(\"admin\"); user.setPassword(\"admin\"); List&lt;User&gt; users = mapper.findUsersByUsernamePassword3(user); System.out.println(users); sqlSession.close();} Mapper.xml文件： 123&lt;select id=\"findUsersByUsernamePassword3\" resultType=\"user\" parameterType=\"user\"&gt; select * from tb_user where username = #{username} and password = #{password}&lt;/select&gt; 方法4：使用MapMapper接口的方法： 123456789101112131415161718/*根据username和password查询*/List&lt;User&gt; findUsersByUsernamePassword(Map map);//-----调用方式@Testpublic void testFindUsersByUsernamePassword() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"username\", \"admin\"); map.put(\"password\", \"admin\"); List&lt;User&gt; users = mapper.findUsersByUsernamePassword(map); System.out.println(users); sqlSession.close();}/*其中Map是mybatis自己配置好的直接使用就行。map中key的名字就是在#{}使用的个，map如何封装就不用了管了*/ 对应Mapper.xml文件： 123&lt;select id=\"findUsersByUsernamePassword\" resultType=\"user\" &gt; select * from tb_user where username = #{username} and password = #{password}&lt;/select&gt; 注意： ​ 这里使用Map来读取参数，需要注意的是，使用Map可以像实体那样访问，这里的key就像实体的属性名。 方法5：使用实体和@ParamMapper接口的方法： 1List&lt;User&gt; findUsersByUsernamePassword4(@Param(\"user\") User user); 对应Mapper.xml文件： 1234&lt;select id=\"findUsersByUsernamePassword4\" resultType=\"user\"&gt; select * from tb_user where username = #{user.username} and password = #{user.password}&lt;/select&gt; 注意： ​ 如果使用注解结合实体的方式来传参数的话，那么就需要使用实体.属性名的方式来读取参数。 方法6：使用Map和@ParamMapper接口的方法： 1List&lt;User&gt; findUsersByUsernamePassword5(@Param(\"map\") Map map); 对应的Mapper.xml文件： 1234&lt;select id=\"findUsersByUsernamePassword5\" resultType=\"user\"&gt; select * from tb_user where username = #{map.username} and password = #{map.password}&lt;/select&gt; 使用方法和方法5类似，不再赘述。 可迭代对象注意：如果使用接口Collection , 在Mapper.xml文件中，直接使用 collection. 传递List前面的动态SQL中使用到了传递List的情况，这小节主要把几种迭代对象都使用一遍。 Mapper接口方法： 1List&lt;User&gt; findUsersByIds(List&lt;Integer&gt; id); 对应的Mapper.xml文件： 12345678910&lt;!--select * from tb_user WHERE id in ( ? , ? , ? ) --&gt;&lt;select id=\"findUsersByIds\" resultType=\"user\"&gt; select * from tb_user &lt;where&gt; id in &lt;foreach collection=\"list\" item=\"ite\" open=\"(\" separator=\",\" close=\")\"&gt; #{ite} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 注意：List集合可以使用list，也可以使用collection。 使用SetMapper接口的方法： 1List&lt;User&gt; findUsersByIds1(Set&lt;Integer&gt; ids); 对应的Mapper.xml文件 123456&lt;select id=\"findUsersByIds2\" resultType=\"user\"&gt; select * from tb_user where id in &lt;foreach collection=\"collection\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; #{item} &lt;/foreach&gt;&lt;/select&gt; 注意：Set集合没有像List那样，Set只能使用collection。 传递数组Mapper接口的方法： 1List&lt;User&gt; findUsersByIds2(Integer[] ids); 对应的Mapper.xml文件 1234567&lt;select id=\"findUsersByIds1\" resultType=\"user\"&gt; select * from tb_user where id in &lt;foreach collection=\"array\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; #{item} &lt;/foreach&gt;&lt;/select&gt; 传递Map使用Map来做保存操作: 1void saveUserByMap1(Map&lt;String,Object&gt; map); 对应的Mapper.xml文件： 1234&lt;select id=\"saveUserByMap1\"&gt; insert into tb_user (user_id,username,password) values (#{user_id},#{username},#{password});&lt;/select&gt; 单元测试： 12345678910@Testpublic void testSaveUserByMap1(){UserMapper mapper = sqlSession.getMapper(UserMapper.class);Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"user_id\",\"root\"); map.put(\"username\",\"root\"); map.put(\"password\",\"root\"); mapper.saveUserByMap1(map); sqlSession.close(); } 传递List-Map这里使用List和Map结合使用实现批量操作 Mapper接口文件的方法： 1void saveUserByMap(List&lt;Map&lt;String,Object&gt;&gt; listMap); 对应的Mapper.xml文件： 1234567&lt;!--insert into tb_user (user_id,username,password)values (?,?,?) , (?,?,?) --&gt;&lt;select id=\"saveUserByMap\"&gt; insert into tb_user (user_id,username,password)values &lt;foreach collection=\"collection\" item=\"item\" separator=\",\"&gt; (#{item.userId},#{item.username},#{item.password}) &lt;/foreach&gt;&lt;/select&gt; 单元测试： 123456789101112131415161718@Testpublic void testSaveUserByMap(){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;Map&lt;String,Object&gt;&gt; list = new ArrayList&lt;&gt;(); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"userId\",\"mybatis1\"); map.put(\"username\",\"mybatis1\"); map.put(\"password\",\"mybatis1\"); Map&lt;String,Object&gt; map1 = new HashMap&lt;&gt;(); map1.put(\"userId\",\"mybatis2\"); map1.put(\"username\",\"mybatis2\"); map1.put(\"password\",\"mybatis2\"); list.add(map); list.add(map1); mapper.saveUserByMap(list); sqlSession.close();} 源码地址： https://gitee.com/ooyhao/JavaRepo_Public/tree/master/Mybatis","link":"/2020/01/18/SSM/mybatis/5Mybatis%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"title":"六、一级缓存和二级缓存","text":"一级缓存和二级缓存 本文参考了下文： https://www.cnblogs.com/happyflyingpig/p/7739749.html\\ 一级缓存​ Mybatis 对缓存提供了支持，在没有配置的情况下，Mybatis默认只开启一级缓存，一级缓存其实就是依托于SqlSession，即使用同一个SqlSession操作下，如果Sql语句和参数都没有变化，SqlSession第一次会发送SQL，再缓存没有失效的情况下，后面的查询，就会直接去二级缓存中查找，不再像数据库发送SQL查询。 图片来源于上述链接博文： 为什么要使用一级缓存，不用多说也知道个大概。但是还有几个问题我们要注意一下。 1、一级缓存的生命周期有多长？ ​ a、MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 b、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。 c、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。 d、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用 2、怎么判断某两次查询是完全相同的查询？ mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。 2.1 传入的statementId 2.2 查询时要求的结果集中的结果范围 2.3 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ） 2.4 传递给java.sql.Statement要设置的参数值 一级缓存验证我们依托于前面的示例， Role: 12345678910111213141516@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class Role{ private Integer id; private String roleName; private String description; private Integer status; private Date createTime; private String createUser; private Date modifyTime; private String modifyUser;} RoleMapper: 123public interface RoleMapper { Role findById(Integer id);} 下面是测试一级缓存的方法： 123456789101112131415161718192021public class AppTest { SqlSession sqlSession = null; @Before public void init(){ String resource = \"mybatis.configuration.xml\"; InputStream inputStream = AppTest.class.getClassLoader().getResourceAsStream(resource); sqlSession = new SqlSessionFactoryBuilder().build(inputStream).openSession(true); } @Test public void testFindRoleById(){ RoleMapper mapper = sqlSession.getMapper(RoleMapper.class); Role role1 = mapper.findById(1); Role role2 = mapper.findById(1); System.out.println(role1); System.out.println(role2); sqlSession.close(); }} 测试结果： 二级缓存Mybatis的二级缓存是SqlSessionFactory层面的，一级缓存是SqlSession层面的。 默认情况下，只启用了本地的会话缓存，也就是一级缓存，基于SqlSession的 ，但是如果需要开启二级缓存的话，只需要在Mapper.xml文件中添加一行： 1&lt;cache/&gt; 基本上就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 二级缓存验证RoleMapper.xml： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.ooyhao.mybatis4.mapper.RoleMapper\"&gt; &lt;!--开启二级缓存--&gt; &lt;cache /&gt; &lt;resultMap id=\"base_map_4\" type=\"role\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/&gt; &lt;result column=\"description\" jdbcType=\"VARCHAR\" property=\"description\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findById\" resultMap=\"base_map_4\"&gt; select * from tb_role where id = #{id} &lt;/select&gt;&lt;/mapper&gt; 如xml文件所述，我们仅在RoleMapper文件下添加&lt;cache/&gt; 用于开启当前namespace 的缓存。 单元测试方法： (需要注意，我们需要将自动提交关闭，即openSession()的参数设置为false，或不填，否则无法进行缓存) 12345678910111213141516171819202122232425@Testpublic void testFindRoleByIdWithCache(){ //二级缓存是在SqlSessionFactory层面的。 String resource = \"mybatis.configuration.xml\"; InputStream stream = AppTest.class.getClassLoader().getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //创建SqlSessionFactory SqlSessionFactory build = builder.build(stream); SqlSession sqlSession1 = build.openSession(); RoleMapper mapper = sqlSession1.getMapper(RoleMapper.class); Role role1 = mapper.findById(1); System.out.println(role1); RoleMapper mapper1 = sqlSession1.getMapper(RoleMapper.class); Role role = mapper1.findById(1); System.out.println(role); sqlSession1.commit(); SqlSession sqlSession2 = build.openSession();//创建了一个新的session。 RoleMapper roleMapper = sqlSession2.getMapper(RoleMapper.class); Role role2 = roleMapper.findById(1); System.out.println(role2); sqlSession2.commit();} 此时测试结果为：(报未序列化异常) 所以，我们需要为Role对象加上Serializable接口。 如果我们标注为缓存是只读的话，那么不序列化也不会保错： 1&lt;cache readOnly=\"true\" /&gt; 测试结果： 这是启用二级缓存之后的执行结果，可以发现查询了3次，但是实际仅仅只发送了一次SQL，我们可以看第二次的Cache Hit Ratio 是0.3333，即三分之一，我们总共查询了三次，在二级缓存中的命中的次数是一次，所以是0.333. 我们像下面这样，增加一次查询： 12345678910111213141516171819202122232425262728293031323334public class AppTest { @Test public void testFindRoleByIdWithCache(){ //二级缓存是在SqlSessionFactory层面的。 String resource = \"mybatis.configuration.xml\"; InputStream stream = AppTest.class.getClassLoader().getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //创建SqlSessionFactory SqlSessionFactory build = builder.build(stream); SqlSession sqlSession1 = build.openSession(); RoleMapper mapper = sqlSession1.getMapper(RoleMapper.class); Role role1 = mapper.findById(1); System.out.println(role1); RoleMapper mapper1 = sqlSession1.getMapper(RoleMapper.class); Role role = mapper1.findById(1); System.out.println(role); sqlSession1.commit(); SqlSession sqlSession2 = build.openSession(); RoleMapper roleMapper = sqlSession2.getMapper(RoleMapper.class); Role role2 = roleMapper.findById(1); System.out.println(role2); sqlSession2.commit(); SqlSession sqlSession3 = build.openSession(); RoleMapper roleMapper3 = sqlSession3.getMapper(RoleMapper.class); Role role3 = roleMapper3.findById(1); System.out.println(role3); sqlSession3.commit(); }} 执行结果如下： 二级缓存详述我们知道了如何操作二级缓存，下面我们对二级缓存进行更加详细的了解。 1&lt;cache/&gt; 这个简单语句的效果如下: 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 这些属性可以通过 cache 元素的属性来修改。比如： 12345678910111213141516171819202122&lt;!--开启二级缓存--&gt;&lt;!--开启本mapper的namespace下的二级缓存--&gt;&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" readOnly=\"true\" size=\"512\" /&gt;&lt;resultMap id=\"base_map_4\" type=\"role\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/&gt; &lt;result column=\"description\" jdbcType=\"VARCHAR\" property=\"description\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt;&lt;/resultMap&gt;&lt;!--可以通过设置useCache来规定这个sql是否开启缓存，ture是开启，false是关闭--&gt;&lt;select id=\"findById\" resultMap=\"base_map_4\" useCache=\"true\" &gt; select * from tb_role where id = #{id}&lt;/select&gt; ​ 这个更高级的配置创建了一个FIFO(first in first out) 缓存，每隔60秒刷新，最多可以存储结果对象或列表的512个引用，而且返回的对象被认为是只读的，因此对他们进行修改可能会在不同线程中的调用者产生冲突。 可用的清楚策略有： LRU -最近最少使用：移除最长时间不被使用的对象。（默认） FIFO -先进先出：按对象进入缓存的顺序来移除它们。 SOFT - 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK - 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。 size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。 readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。 提示： 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。 总结： ​ 至此，我们学习了Mybatis的基础知识了，当然，如果我们需要深入理解Mybatis，我们还有很多要学习，所以，学习Mybatis，我们才刚刚开始。后面，我们学习一下如何和Spring整合操作。 源码地址： https://gitee.com/ooyhao/JavaRepo_Public/tree/master/Mybatis","link":"/2020/01/18/SSM/mybatis/6Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"},{"title":"八、Mybatis整合Spring操作DB","text":"Mybatis整合Spring操作DB：​ 这一节我们主要看一下如何使用Spring整合Mybatis操作，同时也是基于操作方面的，对于其Spring如何操作Mybatis的，还需要后续的学习。虽然之前的Spring in action 4 中涉及到了SSM整合，但是在学习spring之后，再次整合Spring加Mybatis，会体会到不一样的感觉。 项目结构图 项目的POM依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-mybatis&lt;/artifactId&gt; &lt;groupId&gt;com.ooyhao.mybatis&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring-mybatis-01&lt;/artifactId&gt; &lt;name&gt;spring-mybatis-01&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis整合spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.8.0-beta0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.8.0-beta0&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--jackson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0.pr3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.0.pr3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.0.pr3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ POM依赖也需要注意，所以我把完整的POM依赖贴出来，有的时候项目没问题，可能就是依赖搞错了导致项目运行不了、 Mybatis的全局配置1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--属性配置文件--&gt; &lt;!--&lt;properties resource=\"application.properties\"/&gt;--&gt; &lt;!--设置--&gt; &lt;settings&gt; &lt;!--&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--&lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;--&gt; &lt;/settings&gt; &lt;!--别名--&gt; &lt;!--&lt;typeAliases&gt; &lt;package name=\"com.ooyhao.mybatis.bean\"/&gt; &lt;/typeAliases&gt;--&gt; &lt;!--Spring中配置--&gt; &lt;!--&lt;environments default=\"dev\"&gt; &lt;environment id=\"dev\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;--&gt; &lt;!--Mapper xml文件--&gt; &lt;!--&lt;mappers&gt; &lt;mapper resource=\"mapper/RoleMapper.xml\"/&gt; &lt;/mappers&gt;--&gt;&lt;/configuration&gt; ​ 可以看出，这里只是配置了一下开启驼峰命名，因为这一项在配置类中配置无效（测试结果），所以在配置文件中保留了这一项，其他的均可以通过配置类来配置。 properties文件1234567891011# 配合数据源jdbc.driver= com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://120.79.167.88:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;useSSL=falsejdbc.username = rootjdbc.password = root#配置Mybatis参数mybatis.configuration = mybatis-configuration.xmlmybatis.mapperLocations = mapper/*.xmlmybatis.typeAliasesPackage = com.ooyhao.mybatis.bean Spring配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.ooyhao.mybatis.config;import com.alibaba.druid.pool.DruidDataSource;import org.apache.ibatis.logging.stdout.StdOutImpl;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;/** * 描述: * 类【AppConfig】 * * @author ouYangHao * @create 2019-09-20 16:58 */@Configuration //标注为一个配置类@PropertySource(value = \"classpath:application.properties\") //加载属性文件@ComponentScan(basePackages = \"com.ooyhao.mybatis\") //组件扫描@MapperScan(basePackages = {\"com.ooyhao.mybatis.mapper\"}) //mapper文件的扫描@EnableTransactionManagement //开启事务管理public class AppConfig { @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.driver}\") private String driverClassName; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password; @Value(\"${mybatis.configuration}\") private String mybatisConfiguration; @Value(\"${mybatis.mapperLocations}\") private String mybatisMapperLocations; @Value(\"${mybatis.typeAliasesPackage}\") private String mybatisTypeAliasesPackage; /*配置数据源*/ @Bean public DataSource dataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(url); druidDataSource.setDriverClassName(driverClassName); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; } /*Mybatis的全局配置*/ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) throws Exception { SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); /*配置Mybatis的全局配置文件*/ ClassPathResource resource = new ClassPathResource(mybatisConfiguration); sqlSessionFactoryBean.setConfigLocation(resource); /*配置Mapper.xml文件的路径*/ PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource[] resources = resolver.getResources(mybatisMapperLocations); sqlSessionFactoryBean.setMapperLocations(resources); /*配置别名包*/ sqlSessionFactoryBean.setTypeAliasesPackage(mybatisTypeAliasesPackage); /*设置数据源，位置有要求，需要在下面几项之前*/ sqlSessionFactoryBean.setDataSource(dataSource); /*配置驼峰命名*/ sqlSessionFactoryBean.getObject().getConfiguration() .setMapUnderscoreToCamelCase(true); /*配置日志类*/ sqlSessionFactoryBean.getObject().getConfiguration() .setLogImpl(StdOutImpl.class); /*设置开启缓存*/ sqlSessionFactoryBean.getObject().getConfiguration().setCacheEnabled(true); return sqlSessionFactoryBean; } /*配置数据源事务管理器，需要将数据源注入*/ @Bean public DataSourceTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; }} 提示：配置说明如注释； RoleMapper 文件1234public interface RoleMapper { Role findById(Integer id); void deleteById(Integer id);} RoleMapper XML123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.ooyhao.mybatis.mapper.RoleMapper\"&gt; &lt;!--开启二级缓存--&gt; &lt;!--开启本mapper的namespace下的二级缓存--&gt; &lt;cache eviction=\"FIFO\" flushInterval=\"60000\" readOnly=\"true\" size=\"512\" /&gt; &lt;resultMap id=\"base_map\" type=\"role\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/&gt; &lt;result column=\"description\" jdbcType=\"VARCHAR\" property=\"description\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;/resultMap&gt; &lt;!--可以通过设置useCache来规定这个sql是否开启缓存，ture是开启，false是关闭--&gt; &lt;select id=\"findById\" resultMap=\"base_map\" useCache=\"true\" &gt; select * from tb_role where id = #{id} &lt;/select&gt; &lt;delete id=\"deleteById\"&gt; delete from tb_role where id = #{id} &lt;/delete&gt;&lt;/mapper&gt; RoleService12345678910111213141516171819@Servicepublic class RoleService { @Autowired private RoleMapper roleMapper;// @Transactional public Role findById(Integer id){ roleMapper.findById(id); return roleMapper.findById(id); } @Transactional public void deleteById(Integer id){ roleMapper.deleteById(id); int i = 1/0; }} 单元测试类123456789101112131415161718192021222324public class AppTest { AnnotationConfigApplicationContext context = null; @Before public void init(){ context = new AnnotationConfigApplicationContext(AppConfig.class); } @Test public void testFindById() { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); RoleService bean = context.getBean(RoleService.class); Role role = bean.findById(1); System.out.println(role); } @Test public void testDeleteById(){ RoleService service = context.getBean(RoleService.class); service.deleteById(7); }} 这里顺便测试一下Mapper的一级缓存和二级缓存： 当我们在查询Service上不使用事务注解的时候： 测试结果如下： 可以看出，这种情况下我们走的是二级缓存，即，在此情况下，一级缓存是没有生效的。 当我们在查询Service上加上事务时： 测试结果如下： ​ 可以看出此时走的是一级缓存，因为二级缓存的击中率都是0，但是查询了两次，只发送一次SQL，所以此时可以看出是查询的一级缓存。 总结： ​ 至此，Spring的基础和Mybatis的基础就完整的过了一遍了，将Mybatis的各种基础用法，动态SQL，结果映射都使用了一遍，同时前面的Spring中也将Spring的基础再次熟悉了一遍，比如自动装配，AOP，同时知道了如何不使用Web.xml和其他配置文件的情况下，搭建起一个web项目。 源码地址： https://gitee.com/ooyhao/JavaRepo_Public/tree/master/Mybatis","link":"/2020/01/18/SSM/mybatis/8Mybatis%E6%95%B4%E5%90%88Spring/"},{"title":"四、Mybatis动态SQL","text":"Mybatis动态SQL 概念摘自官网：https://mybatis.org/mybatis-3/zh/dynamic-sql.html ​ MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 ​ 虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。 ​ 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 动态sql语句标签主要包括下面这几种： if choose…when…otherwise trim foreach bind if 标签当我们需要做一些判断的时候，可以使用到if标签，如下： 1234567891011&lt;select id=\"findUsersByUsernamePassword\" resultType=\"user\" &gt; select * from tb_user &lt;where&gt; &lt;if test=\"username != null\"&gt; username = #{username} &lt;/if&gt; &lt;if test=\"password != null\"&gt; and password = #{password} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 所对应的Mapper接口方法： 12/*根据username和password查询*/List&lt;User&gt; findUsersByUsernamePassword(User user); 我们可以直接使用对象中的属性来取值。如果此时我们加了@Param(&quot;user&quot;) 12/*根据username和password查询*/List&lt;User&gt; findUsersByUsernamePassword(@Param(\"user\") User user); 对应的取值xml： 1234567891011&lt;select id=\"findUsersByUsernamePassword\" resultType=\"user\" &gt; select * from tb_user &lt;where&gt; &lt;if test=\"user.username != null\"&gt; username = #{user.username} &lt;/if&gt; &lt;if test=\"user.password != null\"&gt; and password = #{user.password} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 解释：上述示例中，sql拼接结果如下： username 为null，password 不为null 1select * from tb_user where password = ? username 不为null，password为null 1select * from tb_user where username = ? username 不为null，password不为null 1select * from tb_user where username = ? and password = ? username 为null，password为null 1select * from tb_user 注意： 123&lt;if test=\"id != null and userId != '' and username =='2'\"&gt; refusalreason=#{remark,jdbcType=VARCHAR}&lt;/if&gt; mybatis是用OGNL表达式来解析的，在OGNL的表达式中，’2’会被解析成字符，java是强类型的，char 和一个string 会导致不等，所以if标签中的sql不会被解析。 if标签里，判断相等或不相等 1单个字符需要加.toString()，如：auditidentified =='2'.toString() if标签里，判断相等或不相等 1多个字符不需要加toString()，如：auditidentified !='2155' choose 标签​ 有时我们不希望用到所有的条件，比如用户有记录有id，user_id, username这几个属性，但是查询的时候希望有优先级，比如id存在的时候，只按id查询，如果id不存在，但是user_id存在，则按照user_id查询，如果前面两者都不存在，则按照username查询。 语句模板： 12345&lt;choose&gt; &lt;when test = \"a\"&gt;A&lt;/when&gt; &lt;when test = \"b\"&gt;B&lt;/when&gt; &lt;otherwise&gt;C&lt;/otherwise&gt;&lt;/choose&gt; 语句解释： 123456789解释：（只会执行一个条件,也必定会有一个条件执行） 这个语句相当Java中的 switch...case...default switch ==&gt; choose:定义语句范围 case ==&gt; when :满足当前条件 test 时执行 default ==&gt; otherwise :当前面的所有when都不满足的时候，使用otherwise的语句即：当表达式a计算结果为true时，则执行语句A, choose结束 当表达式b计算结果为true时，则执行语句B, choose结束 当前面的when都不满足时，执行C。choose结束。 示例语句如下： 12345678910111213141516&lt;select id=\"findUsersByIdOrUserIdOrUsername\" resultType=\"user\"&gt; select * from tb_user &lt;where&gt; &lt;choose&gt; &lt;when test=\"id != null\"&gt; id = #{id} &lt;/when&gt; &lt;when test=\"userId != null\"&gt; user_id = #{userId} &lt;/when&gt; &lt;otherwise&gt; username = #{username} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 对应的Mapper接口方法： 12345/*查询，如果有id不为空，则直接按id查询，如果id为空，则按userId查询，否则按username查询*/List&lt;User&gt; findUsersByIdOrUserIdOrUsername( @Param(\"id\") Integer id, @Param(\"userId\") String userId, @Param(\"username\") String username); ​ 注意的同学可以发现，这里与之前的传参方法不同。后面将会有一篇专门介绍参数传递问题。这里先不细说。 trim 标签与trim相关的标签还有set和where标签，这是用来我们解决sql拼接的问题，之前自己手动凭借SQL的时候，需要非常注意 and，or和逗号问题，对应and|or，我们会在sql之前使用where 1 = 1,如下： 1select * from tb_user where 1 = 1 and ... 我们看一下下面这个sql: 123456789&lt;select id=\"findUsersByUsernamePassword\" resultType=\"user\" &gt; select * from tb_user where &lt;if test=\"username != null\"&gt; username = #{username} &lt;/if&gt; &lt;if test=\"password != null\"&gt; and password = #{password} &lt;/if&gt;&lt;/select&gt; 当我username为空，password不为空时，处理之后就会生成如下sql： 1select * from tb_user where and password = ? 上面这个sql就是一个错误的sql，但是mybatis中的动态sql帮我们提供了方法，下面我们看一下trim标签： 1234567&lt;trim prefix=\"\" prefixOverrides=\"\" suffix=\"\" suffixOverrides=\"\"&gt;&lt;/trim&gt;&lt;!-- 解释：prefix: 前缀,即在当前使用trim标签的最开头处添加指定元素。suffix: 后缀,即在当前使用trim标签的最结束处添加指定元素。prefixOverrides: 在最前面将元素指定的数据移除掉。suffixOverrides: 在最后面将元素指定的数据移除掉。--&gt; 所以我们使用trim标签来解决上面标签产生的问题，如下： 1234567891011&lt;select id=\"findUsersByUsernamePassword\" resultType=\"user\" &gt; select * from tb_user &lt;trim prefix=\"where\" prefixOverrides=\"and |or\"&gt; &lt;if test=\"username != null\"&gt; username = #{username} &lt;/if&gt; &lt;if test=\"password != null\"&gt; and password = #{password} &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 注意：and后面的空格是必要添加的(官网介绍)。但是我测试的空格没有影响，为了规避问题，建议加上空格。 mybatis鉴于上述使用环境非常常见，将其封装为where标签，以及set标签，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;select id=\"findUsersByUsernamePassword\" resultType=\"user\" &gt; select * from tb_user &lt;where&gt; &lt;if test=\"username != null\"&gt; username = #{username} &lt;/if&gt; &lt;if test=\"password != null\"&gt; and password = #{password} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;update id=\"updateUserByUser\" &gt; update tb_user &lt;set&gt; &lt;if test=\"userId != null\"&gt; user_id = #{userId}, &lt;/if&gt; &lt;if test=\"username != null\"&gt; username = #{username}, &lt;/if&gt; &lt;if test=\"password != null\"&gt; password = #{password}, &lt;/if&gt; &lt;if test=\"email != null\"&gt; email = #{email}, &lt;/if&gt; &lt;if test=\"phone != null\"&gt; phone = #{phone}, &lt;/if&gt; &lt;if test=\"gender != null\"&gt; gender = #{gender}, &lt;/if&gt; &lt;if test=\"birthday != null\"&gt; birthday = #{birthday}, &lt;/if&gt; &lt;if test=\"status != null\"&gt; status = #{status}, &lt;/if&gt; &lt;if test=\"createTime != null\"&gt; create_time = #{createTime}, &lt;/if&gt; &lt;if test=\"createUser != null\"&gt; create_user = #{createUser}, &lt;/if&gt; &lt;if test=\"modifyUser != null\"&gt; modify_user = #{modifyUser}, &lt;/if&gt; &lt;if test=\"modifyTime != null\"&gt; modify_time = #{modifyTime}, &lt;/if&gt; &lt;/set&gt; where id = #{id}&lt;/update&gt; foreach标签​ 这个标签对我们来说从名字上，其实就知道是用来干啥的了。对，foreach标签就是用来循环迭代一些可迭代的元素，如，list，set，map，数组等。 试想以下，当我们需要根据多个id批量查询的时候，我们使用java代码需要如何操作： 1234567891011121314151617181920public void test() { String sql = \" select * from tb_user where id in \"; List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(1); ids.add(2); ids.add(3); ids.add(4); String idSql = \"(\"; for (int i = 0; i &lt; ids.size(); i++) { if (i == ids.size() - 1) { idSql += ids.get(i) +\")\"; }else{ idSql += ids.get(i) + \",\"; } } sql += idSql; System.out.println(sql);}//select * from tb_user where id in (1,2,3,4); 可以看出，拼接这个sql非常繁琐，但是Mybatis提供的foreach可以很简单的实现,在此之前，我们看一下foreach标签： 1&lt;foreach collection=\"\" index=\"\" item=\"\" open=\"\" separator=\"\" close=\"\" &gt;&lt;/foreach&gt; 注意： 你可以将任何可迭代对象 如 List、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时。 collection 属性的书写方式，List -&gt; list/collection,Set-&gt;collection,[]数组 -&gt; array,Map -&gt; map. index 是当前迭代的次数，item 的值是本次迭代获取的元素。 当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 open表示拼接最前的元素 close表示拼接在最后的元素 separator表示遍历的各个元素之间的分隔符。 使用foreach实现： 123456789&lt;select id=\"findUsersByIds\" resultType=\"user\"&gt; select * from tb_user &lt;where&gt; id in &lt;foreach collection=\"list\" item=\"ite\" open=\"(\" separator=\",\" close=\")\"&gt; #{ite} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 对应的mapper接口的方法： 1List&lt;User&gt; findUsersByIds(List&lt;Integer&gt; id); bind 标签bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文： 1234567891011121314151617181920&lt;select id=\"findUserById\" resultType=\"user\"&gt; &lt;bind name=\"id\" value=\" id + 1\"/&gt; select * from tb_user where id = #{id}&lt;/select&gt;&lt;!-- ==&gt; Preparing: select * from tb_user where username like ? ==&gt; Parameters: %xxx%(String)--&gt;&lt;select id=\"findUsersByLikeUsername\" resultType=\"user\"&gt; &lt;bind name=\"name\" value=\" '%' +username+ '%' \"/&gt; select * from tb_user where username like #{name}&lt;/select&gt;&lt;!-- 模糊查询还可以这样 --&gt;&lt;select id=\"findUserByQueryVo\" parameterType=\"QueryVo\" resultType=\"User\"&gt; select * from tb_user where username like concat('%',#{user.username},'%')&lt;/select&gt; bind 标签比较简单，如上所示，可以将字符串进行拼接，也可以对传递进来的参数进行处理。 源码地址： https://gitee.com/ooyhao/JavaRepo_Public/tree/master/Mybatis","link":"/2020/01/18/SSM/mybatis/4Mybatis%E5%8A%A8%E6%80%81SQL/"},{"title":"手写一个简单的IOC容器","text":"手写一个简单的IOC容器 手写一个简单的IOC容器说明首先我们都知道，Spring框架中两个最重要的组件就是IOC和AOP。IOC 即 inversion of control 控制反转。Aop即 Aspect Oriented Programming 面向切面编程。那么我们这里就来手写一个简单的IOC容器。这里主要使用 xml配置的方式来实现IOC容器。 前置知识手撸一个IOC容器需要先掌握好 XML文件解析 和 Java反射知识。 行了，下面我们就开始了。 项目搭建创建项目使用普通的maven搭建一个项目。 导入依赖12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类123456789101112131415161718192021222324252627282930313233package com.ooyhao.pojo;import lombok.Data;import java.io.Serializable;@Datapublic class User implements Serializable { private byte age; private Byte ageB; private short height; private Short heightS; private int id; private Integer idI; private long weight; private Long weightL; private char sex; private Character sexC; private float salary; private Float salaryF; private double buy; private Double buyD; private boolean successB; private Boolean success; private String name;} spring配置文件12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.ooyhao.pojo.User\"&gt; &lt;property name=\"age\" value=\"2\"/&gt; &lt;property name=\"ageB\" value=\"20\"/&gt; &lt;property name=\"height\" value=\"170\"/&gt; &lt;property name=\"heightS\" value=\"1700\"/&gt; &lt;property name=\"id\" value=\"1\"/&gt; &lt;property name=\"idI\" value=\"10\"/&gt; &lt;property name=\"weight\" value=\"60\"/&gt; &lt;property name=\"weightL\" value=\"600\"/&gt; &lt;property name=\"sex\" value=\"m\"/&gt; &lt;property name=\"sexC\" value=\"f\"/&gt; &lt;property name=\"salary\" value=\"7500.5\"/&gt; &lt;property name=\"salaryF\" value=\"9000.5\"/&gt; &lt;property name=\"buy\" value=\"10.05\"/&gt; &lt;property name=\"buyD\" value=\"100.5\"/&gt; &lt;property name=\"success\" value=\"false\"/&gt; &lt;property name=\"successB\" value=\"true\"/&gt; &lt;property name=\"name\" value=\"欧阳\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 自定义ApplicationContext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 简单手写一个IOC容器 */public class MyApplicationContext implements ApplicationContext { private static Map&lt;String,Object&gt; beansContainer = new HashMap&lt;&gt;(); public MyApplicationContext(String path){ //构造器中处理 //处理ClassPath下的文件。 ClassPathResource resource = new ClassPathResource(path); //利用DOM4J解析XML文件 SAXReader reader = new SAXReader(); try { //读取xml文件,获取到文档 Document document = reader.read(resource.getInputStream()); //根目录beans Element beansElement = document.getRootElement(); //迭代beans获取多个bean Iterator&lt;Element&gt; beansIter = beansElement.elementIterator(); while(beansIter.hasNext()){ //单个bean Element beanElement = beansIter.next(); //id String id = beanElement.attributeValue(\"id\"); //完整的类名 String className = beanElement.attributeValue(\"class\"); //通过className反射出一个对象 Class&lt;?&gt; aClass = Class.forName(className); //获取无参数的构造器 Constructor&lt;?&gt; constructor = aClass.getConstructor(); //利用无参数的构造器创建实例 Object o = constructor.newInstance(); //迭代bean获取property Iterator&lt;Element&gt; beanIter = beanElement.elementIterator(); while (beanIter.hasNext()){ Element property = beanIter.next(); //属性名 String fieldName = property.attributeValue(\"name\"); //属性值 String fieldValue = property.attributeValue(\"value\"); //根据属性名获取属性对象 Field field = aClass.getDeclaredField(fieldName); //属性的类型 Class&lt;?&gt; fieldType = field.getType(); //拼接set方法名 String setMethodName = \"set\" + fieldName.substring(0,1).toUpperCase()+ fieldName.substring(1); //获取方法对象 Method method = aClass.getMethod(setMethodName, fieldType); Object val = fieldValue; switch (fieldType.getName()){ case \"int\": case \"java.lang.Integer\": val = Integer.valueOf(fieldValue); break; case \"boolean\": case \"java.lang.Boolean\": val = Boolean.valueOf(fieldValue); break; case \"char\": case \"java.lang.Character\": val = fieldValue.charAt(0); break; case \"long\": case \"java.lang.Long\": val = Long.valueOf(fieldValue); break; case \"double\": case \"java.lang.Double\": val = Double.valueOf(fieldValue); break; case \"float\": case \"java.lang.Float\": val = Float.valueOf(fieldValue); break; case \"byte\": case \"java.lang.Byte\": val = Byte.valueOf(fieldValue); break; case \"short\": case \"java.lang.Short\": val = Short.valueOf(fieldValue); break; } method.invoke(o,val); } beansContainer.put(id,o); } } catch (DocumentException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } } public Object getBean(String s) throws BeansException { Object o = beansContainer.get(s); return o; } public &lt;T&gt; T getBean(Class&lt;T&gt; aClass) throws BeansException { Collection&lt;Object&gt; values = beansContainer.values(); Iterator&lt;Object&gt; iterator = values.iterator(); while (iterator.hasNext()){ Object next = iterator.next(); if (next.getClass().equals(aClass)) { return (T) next; } } return null; } //部分未实现功能此处省略} 上述部分就是实现简单的IOC重点内容。主要是基于 XML解析和发射知识。 项目测试项目测试代码 123ApplicationContext context = new MyApplicationContext(\"spring.xml\");User o = context.getBean(User.class);System.out.println(JSONObject.toJSONString(o)); 测试结果 12345678910111213141516171819{ \"age\": 2, \"ageB\": 20, \"buy\": 10.05, \"buyD\": 100.5, \"height\": 170, \"heightS\": 1700, \"id\": 1, \"idI\": 10, \"name\": \"欧阳\", \"salary\": 7500.5, \"salaryF\": 9000.5, \"sex\": \"m\", \"sexC\": \"f\", \"success\": false, \"successB\": true, \"weight\": 60, \"weightL\": 600} 注意：这里只是实现了一个简单的IOC容器，并且只是实现了 java的简单类型和 包装类型，以及String类型的注入。","link":"/2020/02/25/SSM/spring/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%88%9D%E7%BA%A7%E7%9A%84IOC%E5%AE%B9%E5%99%A8/"},{"title":"十、Spring发送eMail","text":"Spring发送eMail 邮件发送准备导入mail以及spring context的依赖支持。 POM文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-19-01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-19-01 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入SpringMVC依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--hibernate参数校验依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.0.Alpha3&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合Thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;mchange-commons-java&lt;/artifactId&gt; &lt;version&gt;0.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dbcp 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-19-01&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 配置JavaMailSender1234567891011121314151617@ComponentScan(basePackages = \"com.ooyhao.spring\", useDefaultFilters = true, excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class), @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = RestController.class) })public class RootConfig { @Bean public JavaMailSender javaMailSender() { JavaMailSenderImpl mailSender = new JavaMailSenderImpl(); mailSender.setHost(\"smtp.163.com\"); mailSender.setUsername(\"ooyhao1996@163.com\"); mailSender.setPassword(\"163mailcode\"); mailSender.setDefaultEncoding(\"utf-8\"); return mailSender; }} 项目结构图 发送简单邮件12345678910111213141516171819@Servicepublic class SendMailService { @Autowired private JavaMailSender mailSender; /** * 发送简单邮件消息 */ public void sendSimpleMail(){ SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(\"ooyhao1996@163.com\"); message.setTo(\"3459649791@qq.com\",\"625194996@qq.com\"); message.setSubject(\"起床了\"); message.setText(\"起床啦\"); message.setSentDate(new Date()); mailSender.send(message); }} 发送带有附件的邮件12345678910111213141516171819202122@Servicepublic class SendMailService { @Autowired private JavaMailSender mailSender; public void sendMailWithAttachment() throws MessagingException { MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true); helper.setFrom(\"ooyhao1996@163.com\"); helper.setTo(\"625194996@qq.com\"); helper.setSentDate(new Date()); helper.setSubject(\"带有附件的邮件\"); helper.setText(\"这是一封具有附件的邮件\"); /*可以携带多个附件*/ ClassPathResource resource1 = new ClassPathResource(\"images/123.png\"); helper.addAttachment(\"123.png\",resource1); ClassPathResource resource2 = new ClassPathResource(\"images/456.png\"); helper.addAttachment(\"456.png\",resource2); mailSender.send(mimeMessage); }} 发送HTML邮件1234567891011121314151617181920212223242526272829@Servicepublic class SendMailService { @Autowired private JavaMailSender mailSender; /*发送一封HTML邮件*/ public void sendHtmlMail() throws MessagingException { MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true); helper.setFrom(\"ooyhao1996@163.com\"); helper.setTo(\"625194996@qq.com\"); helper.setSentDate(new Date()); helper.setSubject(\"HTML邮件\"); helper.setText(\"&lt;!DOCTYPE html&gt;\\n\" + \"&lt;html&gt;\\n\" + \"&lt;head&gt;\\n\" + \"\\t&lt;title&gt;HTML邮件&lt;/title&gt;\\n\" + \"&lt;/head&gt;\\n\" + \"&lt;body&gt;\\n\" + \"\\t&lt;h1&gt;这是一份HTML邮件&lt;/h1&gt;\\n\" + \"\\t&lt;img src=\\\"cid:logo\\\"&gt;\\n\" + \"&lt;/body&gt;\\n\" + \"&lt;/html&gt;\",true); ClassPathResource resource = new ClassPathResource(\"res/images/logo.png\"); helper.addInline(\"logo\",resource); mailSender.send(mimeMessage); }} 发送模板邮件使用模板邮件发送时，需要配置模板解析器和模板引擎。 123456789101112131415161718192021222324252627@Beanpublic ClassLoaderTemplateResolver emailTemplateResolver(){ ClassLoaderTemplateResolver resolver = new ClassLoaderTemplateResolver(); resolver.setPrefix(\"mail/\"); resolver.setTemplateMode(TemplateMode.HTML); resolver.setCharacterEncoding(\"utf-8\"); return resolver;}/*配置*/@Beanpublic SpringResourceTemplateResolver templateResolver(){ SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setTemplateMode(TemplateMode.HTML); resolver.setSuffix(\"/WEB-INF/templates/\"); resolver.setSuffix(\".html\"); resolver.setCharacterEncoding(\"utf-8\"); return resolver;}@Beanpublic SpringTemplateEngine templateEngine(Set&lt;ITemplateResolver&gt; templateResolvers){ SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setTemplateResolvers(templateResolvers); return engine;} 1234567891011121314151617181920212223242526@Servicepublic class SendMailService { @Autowired private JavaMailSender mailSender; @Autowired private SpringTemplateEngine springTemplateEngine; /*发送一封使用Thymeleaf模板生成的邮件*/ public void sendTemplateHTML() throws MessagingException { MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true); helper.setFrom(\"ooyhao1996@163.com\"); helper.setTo(\"625194996@qq.com\"); helper.setSentDate(new Date()); helper.setSubject(\"HTML邮件\"); Context context = new Context(); context.setVariable(\"firstTitle\",\"这是一封模板生成的邮件\"); context.setVariable(\"secondTitle\",\"模板邮件|ouyanghao\"); context.setVariable(\"src\",\"https://ooyhao.gitee.io/vuepress-blog/logo.png\"); String emailText = springTemplateEngine.process(\"emailTemplate.html\", context); helper.setText(emailText,true); mailSender.send(mimeMessage); }} HTML模板 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text=\"${firstTitle}\"&gt;一级标题&lt;/h1&gt; &lt;h2 th:text=\"${secondTitle}\"&gt;二级标题&lt;/h2&gt; &lt;img th:src=\"${src}\"&gt;&lt;!--这里需要填写公网地址，localhost无法显示 --&gt;&lt;/body&gt;&lt;/html&gt; ​ 发送HTML(Thymeleaf)模板邮件时，需要注意一些细节，比如上述代码中的图片显示，则需要用一张外网可以访问到的图片，否则邮件中无法正常显示。 总结： ​ 本节重要是练习如何使用Spring中的简单方法来实现邮件发送。并且包含了简单邮件、附件邮件、HTML邮件以及模板邮件。","link":"/2020/01/29/SSM/spring4x/10Spring%E5%8F%91%E9%80%81EMail/"},{"title":"十一、SSM + Redis","text":"这里我们先介绍一下如何整合Redis，后面再整合一个SSM+redis的项目，无spring配置文件。 SpringDataRedisSpringDataRedis提供了两个模板： RedisTemplate StringRedisTemplate RedisTemplate 的很多功能是以子API的形式提供的，他们区分了单个值和集合值的场景； 方法 子API接口 描述 opsForValue() ValueOperations&lt;K,V&gt; 操作具有简单值得条目 opsForList() ListOperations&lt;K,V&gt; 操作具有list的值的条目 opsForSet() SetOperations&lt;K,V&gt; 操作具有set的值的条目 opsForZSet() ZSetOperations&lt;K,V&gt; 操作具有ZSet值（排序的set）的条目 opsForHash() HashOperations&lt;K,V&gt; 操作具有hash的条目 boundValueOps(K) BoundValueOperations&lt;K,V&gt; 以绑定指定key的方式，操作具有简单值的条目 boundListOps(K) BoundListOperations&lt;K,V&gt; 以绑定指定key的方式，操作具有List值的条目 boundSetOps(K) BoundSetOperations&lt;K,V&gt; 以绑定指定key的方式，操作具有Set值的条目 boundZSetOps(K) BoundZSetOperations&lt;K,V&gt; 以绑定指定key的方式，操作具有ZSet值(排序的Set)的条目 boundHashOps(K) BoundHashOperations&lt;K,V&gt; 以绑定指定key的方式，操作具有Hash值的条目 使用key和value的序列化器 当某个条目保存到Redis key-value存储的时候，key和value都会使用Redis的序列化器(Serializer)进行序列化。SpringDataRedis提供了多个这样的序列化器，包括： GenericToStringSerializer：使用Spring转换服务进行序列化； JacksonJsonRedisSerializer：使用Jackson1，将对象序列化为JSON； Jackson2JsonRedisSerializer：使用Jackson2，将对象序列化为JSON； JdkSerializationRedisSerializer：使用Java序列化； OxmSerializer：使用Spring O/X映射的编排器和解排器（marshaler和unmarshaler）实现序列化，用于XML序列化。 StringRedisSerializer：序列化String类型的key和value。 这些序列化器都实现了RedisSerializer接口，如果其中没有符合需求的序列化器，那么可以自行创建。 下面看一个列子： 例如：假设当使用RedisTemplate的时候，我们希望将Product类型的value序列化为json，而key是String类型。RedisTemplate的setKeySerializer()和setValueSerializer()方法就需要如下所示了： 12345678@Beanpublic RedisTemplate&lt;String,Product&gt; redisTemplate(RedisConnectionFactory cf){ RedisTemplate&lt;String,Product&gt; redis = new RedisTemplate&lt;String,Product&gt;(); redis.setConnectionFactory(cf); redis.setKeySerializer(new StringRedisSerializer()); redis.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Product&gt;(Product.class)) return redis;} 在这里，我们设置RedisTemplate在序列化key的时候，使用StringRedisSerializer，并且设置了在序列化Product的时候，使用的是Jackson2JsonRedisSerializer。 项目整合项目结构 InitWebApplication12345678910111213141516171819202122232425262728293031323334353637public class InitWebApplication extends AbstractAnnotationConfigDispatcherServletInitializer { /*加载applicationContext.xml/rootConfig*/ @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[]{ RootConfig.class }; } /*加载springmvc.xml/ servletConfig.java*/ @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class[]{ ServletConfig.class }; } /*DispatcherServlet 的servletMapping*/ @Override protected String[] getServletMappings() { return new String[]{ \"/\" }; } /*添加编码过滤器*/ @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setForceEncoding(true); filter.setEncoding(\"utf-8\"); return new Filter[]{ filter }; }} 这个文件的作用主要是替代了原有传统web项目中web.xml文件的角色 RootConfigRootConfig 则替代了原有的applicationContext.xml文件 123456789101112131415package com.ooyhao.spring.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * 描述: * 类【RootConfig】 * * @author ouYangHao * @create 2019-09-12 15:01 */@Configuration@ComponentScan(basePackages = \"com.ooyhao.spring\") //组件扫描public class RootConfig {} ServletCofig.xml123456789101112@Configuration@EnableWebMvc@ComponentScan(basePackages = \"com.ooyhao.spring.controller\")public class ServletConfig implements WebMvcConfigurer { /*开启静态文件映射处理*/ @Override public void configureDefaultServletHandling( DefaultServletHandlerConfigurer configurer) { configurer.enable(); }} DataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154@Configuration@MapperScan(basePackages = \"com.ooyhao.spring.mapper\") //扫描Mybatis的Mapper接口@EnableTransactionManagement //开启事务管理@PropertySource(value = \"classpath:application.properties\")public class DataSourceConfig { @Value(\"${dataSource.maxActive}\") private Integer dataSourceMaxActive; @Value(\"${dataSource.maxWait}\") private Integer dataSourceMaxWait; @Value(\"${dataSource.minIdle}\") private Integer dataSourceMinIdle; @Value(\"${dataSource.initialSize}\") private Integer dataSourceInitialSize; @Value(\"${dataSource.url}\") private String dataSourceUrl; @Value(\"${dataSource.username}\") private String dataSourceUsername; @Value(\"${dataSource.password}\") private String dataSourcePassword; @Value(\"${dataSource.driverClassName}\") private String dataSourceDriverClassName; @Value(\"${mybatis.typeAliasesPackage}\") private String mybatisTypeAliasesPackage; @Value(\"${mybatis.configLocation}\") private String mybatisConfigLocation; @Value(\"${mybatis.mapperLocations}\") private String mybatisMapperLocations; @Value(\"${redis.maxTotal}\") private Integer redisMaxTotal; @Value(\"${redis.maxWaitMillis}\") private Integer redisMaxWaitMillis; @Value(\"${redis.minIdle}\") private Integer redisMinIdle; @Value(\"${redis.maxIdle}\") private Integer redisMaxIdle; @Value(\"${redis.hostName}\") private String redisUsername; @Value(\"${redis.password}\") private String redisPassword; @Value(\"${redis.port}\") private Integer redisPort; /*配置Druid数据源*/ @Bean public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setMaxActive(dataSourceMaxActive); dataSource.setMaxWait(dataSourceMaxWait); dataSource.setMinIdle(dataSourceMinIdle); dataSource.setInitialSize(dataSourceInitialSize); dataSource.setUrl(dataSourceUrl); dataSource.setUsername(dataSourceUsername); dataSource.setPassword(dataSourcePassword); dataSource.setDriverClassName(dataSourceDriverClassName); return dataSource; } /*配置事务*/ @Bean public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){ DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } /*配置Mybatis的SQLSessionFactoryBean*/ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) throws Exception { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setTypeAliasesPackage(mybatisTypeAliasesPackage); bean.getObject().getConfiguration().setCacheEnabled(true); bean.getObject().getConfiguration().setMapUnderscoreToCamelCase(true);//测试无效 bean.getObject().getConfiguration().setLogImpl(Slf4jImpl.class); bean.getObject().getConfiguration().setLogPrefix(\"###SPRING###MYBATIS###\"); /*读取Mybatis的配置文件*/ bean.setConfigLocation(new ClassPathResource(mybatisConfigLocation)); /*适用于通配符情况，读取Mybatis的Mapper文件*/ PathMatchingResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver(); Resource[] resources = resourcePatternResolver.getResources(mybatisMapperLocations); bean.setMapperLocations(resources); return bean; } /*配置SpringJDBCTemplate*/ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ return new JdbcTemplate(dataSource); } @Bean public JedisClientConfiguration poolConfig() { JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(20); config.setMaxWaitMillis(3000); config.setMinIdle(5); config.setMaxIdle(8); JedisClientConfiguration.JedisPoolingClientConfigurationBuilder builder= (JedisClientConfiguration.JedisPoolingClientConfigurationBuilder) JedisClientConfiguration.builder(); builder.poolConfig(config); return builder.build(); } @Bean public RedisStandaloneConfiguration standaloneConfiguration() { RedisStandaloneConfiguration configuration = new RedisStandaloneConfiguration(); configuration.setHostName(\"120.79.167.88\"); configuration.setPassword(\"\"); configuration.setPort(6379); return configuration; } @Bean public JedisConnectionFactory connectionFactory() { return new JedisConnectionFactory(standaloneConfiguration(),poolConfig()); } @Bean public RedisTemplate redisTemplate() { RedisTemplate redisTemplate = new RedisTemplate(); redisTemplate.setConnectionFactory(connectionFactory()); //可以设置序列化的类型 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); return redisTemplate; }} 开启事务管理 @EnableTransactionManagement 加载配置文件 @PropertySource(value = “classpath:application.properties”) 配置了Mybatis的数据源，使用的是alibaba的Druid数据源 配置了事务管理 DataSourceTransactionManager 整合mybatis SqlSessionFactoryBean 将DataSource注入到了JdbcTemplate 整合redis 这里需要配合配置文件application.properties. 1234567891011121314151617181920212223# 配置数据源dataSource.maxActive = 20dataSource.maxWait = 5dataSource.minIdle = 5dataSource.initialSize = 5dataSource.url = jdbc:mysql://120.79.167.88:3306/spring_in_action?useUnicode=true&amp;amp;characterEncoding=utf-8dataSource.username = rootdataSource.password = rootdataSource.driverClassName = com.mysql.jdbc.Driver# 配置mybatismybatis.typeAliasesPackage = com.ooyhao.spring.beanmybatis.configLocation = mybatis/config/mybatis-config.xmlmybatis.mapperLocations = mybatis/mapper/*.xml# 配置redisredis.maxTotal = 20redis.maxWaitMillis = 3000redis.minIdle = 5redis.maxIdle = 8redis.hostName = 120.79.167.88redis.password =redis.port = 6379 mybatis-config.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--驼峰命名法，即：create_time 与 createTime自动映射--&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; &lt;!-- 类型别名 --&gt; &lt;!--已在配置类中配置--&gt; &lt;!-- &lt;typeAliases&gt; &lt;package name=\"com.ooyhao.spring.bean\"/&gt; &lt;/typeAliases&gt; --&gt;&lt;/configuration&gt; mapUnderscoreToCamelCase 驼峰命名法在java配置中没有生效。 剩下的就是简单的Bean，dao，service，controller了。","link":"/2020/01/29/SSM/spring4x/11.SSM+redis/"},{"title":"01.SpringBoot基础","text":"SpringBoot基础 1.@Configuration，@ComponentScan，@Bean实体类对象 123456@Datapublic class User { private String username; private String password; private Integer age;} 模拟连接数据库取数据的DAO对象 1234567891011121314public class UserDAO { public List&lt;User&gt; queryUserList(){ List&lt;User&gt; result = new ArrayList&lt;User&gt;(); // 模拟数据库的查询 for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setUsername(\"username_\" + i); user.setPassword(\"password_\" + i); user.setAge(i + 1); result.add(user); } return result; }} Service对象 1234567891011@Servicepublic class UserService { @Autowired // 注入Spring容器中的bean对象 private UserDAO userDAO; public List&lt;User&gt; queryUserList() { // 调用userDAO中的方法进行查询 return this.userDAO.queryUserList(); }} SpringConfig 123456789@Configuration //通过该注解来表明该类是一个Spring的配置，相当于一个xml文件@ComponentScan(basePackages = \"com.ooyhao.springboot.javaconfig\") //配置扫描包public class SpringConfig { @Bean // 通过该注解来表明是一个Bean对象，相当于xml中的&lt;bean&gt; public UserDAO getUserDAO(){ return new UserDAO(); // 直接new对象做演示 }} 注意： SpringConfig.class原本是一个普通的class,但是加上@Configuration之后，相当于是之前spring的一个xml文件。 加上@ComponentScan之后，就相当于在spring xml文件配置了包扫描。而通过@Bean则相当于在xml文件中配置了一个Bean元素。所以springboot可以通过java程序配置来代替配置文件。 测试文件 1234567891011121314151617public class Test { public static void main(String[] args) { // 通过Java配置来实例化Spring容器 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); // 在Spring容器中获取Bean对象 UserService userService = context.getBean(UserService.class); // 调用对象中的方法 List&lt;User&gt; list = userService.queryUserList(); for (User user : list) { System.out.println(user); } // 销毁该容器 context.destroy(); }} 注意：之前使用spring是使用ClassPathXmlApplitionContext对象来读取xml文件的。现在是使用AnnotationConfigApplicationContext来读取配置类的。注解配置。 2.@PropertySource读取配置文件1234567891011121314151617/** * @author ooyhao */@Configuration //通过该注解来表明该类是一个Spring的配置，相当于一个xml文件@ComponentScan(basePackages = \"com.ooyhao.springboot.javaconfig\") //配置扫描包@PropertySource(value={\"classpath:db.properties\"},ignoreResourceNotFound = true)public class SpringConfig { @Value(\"${jdbc.url}\") private String url; @Bean // 通过该注解来表明是一个Bean对象，相当于xml中的&lt;bean&gt; public UserDAO getUserDAO(){ return new UserDAO(); // 直接new对象做演示 }} 注意：使用注解，@PropertySource进行关联配置文件，如何需要配置多个配置文件的话，那就这样写，value={“classpath:db.properties”,”abc.properties”}，如果配置文件不存在时，我们可以使用ignoreResourceNotFound属性进行配置，获取值就跟spring是一个样的，使用@Value注解获得值 3.通过使用注解配置的方式配置数据源jdbc.properties文件 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=truejdbc.username=rootjdbc.password=123456 SpringConfig文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration //通过该注解来表明该类是一个Spring的配置，相当于一个xml文件@ComponentScan(basePackages = \"com.ooyhao.springboot.javaconfig\") //配置扫描包@PropertySource(value={\"classpath:db.properties\"},ignoreResourceNotFound = true)public class SpringConfig { @Value(\"${jdbc.driverClassName\") private String driverClassName; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password; @Bean // 通过该注解来表明是一个Bean对象，相当于xml中的&lt;bean&gt; public UserDAO getUserDAO(){ return new UserDAO(); // 直接new对象做演示 } @Bean(destroyMethod = \"close\") public DataSource dataSource() { BoneCPDataSource boneCPDataSource = new BoneCPDataSource(); // 数据库驱动 boneCPDataSource.setDriverClass(driverClassName); // 相应驱动的jdbcUrl boneCPDataSource.setJdbcUrl(url); // 数据库的用户名 boneCPDataSource.setUsername(username); // 数据库的密码 boneCPDataSource.setPassword(password); // 检查数据库连接池中空闲连接的间隔时间，单位是分，默认值：240，如果要取消则设置为0 boneCPDataSource.setIdleConnectionTestPeriodInMinutes(60); // 连接池中未使用的链接最大存活时间，单位是分，默认值：60，如果要永远存活设置为0 boneCPDataSource.setIdleMaxAgeInMinutes(30); // 每个分区最大的连接数 boneCPDataSource.setMaxConnectionsPerPartition(100); // 每个分区最小的连接数 boneCPDataSource.setMinConnectionsPerPartition(5); return boneCPDataSource; }} 测试文件 1234567@Testpublic void test2(){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class); DataSource bean = applicationContext.getBean(DataSource.class); System.out.println(bean);} 小结：这里不用过多的解释，首先通过@Value注解读取properties文件中的值。然后通过在@Bean对象的方法中构建一个对象，通过对应的set方法将相应的参数设置进去即可。测试跟在xml文件中Bean标签和property标签一直。通过类的class文件获得。 4.Springboot第一个程序springboot不是一个新的技术，只是在spring的基础之上集成后了很多开发技术，使得我们开发起来更加的轻松。 pom文件中需要添加 1234567891011121314151617&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--不需要写版本号，在parent中已经有了定义--&gt;&lt;/dependency&gt;&lt;!--启动插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; HelloApplication文件 12345678910111213141516@Controller //springmvc中的Controller@SpringBootApplication //Springboot的应用@Configurationpublic class HelloApplication {//作为SpringBoot的入口类 @RequestMapping(\"hello\") //路由路径 @ResponseBody //消息转发器，输出结果 public String hello(){ return \"hello world！\"; } //入口方法。 public static void main(String[] args) { SpringApplication.run(HelloApplication.class, args); }} 说明： 1.@SpringBootApplication:springboot项目的核心注解，主要目的是开启自动配置。 2.@Configuration：这是一个spring的配置类 3.@Controller：标明这是一个springmvc的controller控制器 4.main方法:在main方法中启动一个应用，即：这个应用的入口。 效果图： 自定义banner 只需要在resources文件夹下新建一个banner.txt文件，再将自己喜欢的banner复制进去，重启程序即可看到效果。 取消Banner显示 12345678//入口方法。public static void main(String[] args) { //SpringApplication.run(HelloApplication.class, args); //关闭Banner SpringApplication springApplication = new SpringApplication(HelloApplication.class); springApplication.setBannerMode(Banner.Mode.OFF); springApplication.run(args);} 5.springboot HelloWorld1.创建一个maven工程2.添加springboot的依赖12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--不需要写版本号，在parent中已经有了定义--&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.编写一个主程序123456@SpringBootApplication //标注一个主程序，说明这是一个spring boot应用public class HelloWorldMainApplication { public static void main(String[] args) { SpringApplication.run(HelloWorldMainApplication.class,args); }} ###4.编写一个controller 123456789@Controllerpublic class HelloController { @RequestMapping(value = \"/hello\") @ResponseBody public String hello(){ return \"hello world\"; }} 5.运行主程序测试6.简化部署(导入maven插件) 123456789&lt;!--可以将应用打包成jar包--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行。 6.Hello world探究1.pom文件1.导入的依赖1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/parent&gt;它的父项目是：&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;它来真正管理spring boot应用里面的所有依赖版本。 Spring boot的版本仲裁中心。以后我们导入依赖默认是不需要写版本。（没有在dependencies里面管理的依赖自然需要声明版本号） 2.启动器1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--不需要写版本号，在parent中已经有了定义--&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-boot-starter web spring-boot-starter:spring-boot场景启动器 。帮我们导入了web模块正常运行所依赖的组件。 spring boot 将所有的功能场景都抽取出来，做成一个个starter（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。 2.主程序类，主入口类 @SpringBootApplication: Spring Boot应用，标注在某个类上，说明这个类是springboot的主配置类，springboot就应该运行这个类的main方法类启动springboot应用。 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { @SpringBootConfiguration：sprintboot的配置类。 ​ 标注在某个类上，表示这是一个springboot的配置类。 ​ @Configuration: 配置类上类标注这个注解； ​ 配置类—– 配置文件。 @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，springboot帮我们自动配置；@EnableAutoConfiguration告诉springboot开启自动配置功能。这样自动配置才能生效。 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class) ；spring的底层注解，给容器中导入一个组件。导入的组件由AutoConfigurationPackages.Registrar.class ​ 将主配置类，（@SpringBootApplication标注的类）的所在包及其子包里面的所有组件扫描到spring容器；","link":"/2020/02/29/SSM/springboot/1.SpringBoot%E5%9F%BA%E7%A1%80/"},{"title":"02.SpringBoot配置","text":"SpringBoot基础配置 注意：默认都是先读取application.properties文件中的配置的。（即如果application.properties文件中有相对应的配置的话，就直接读取其中的。别的文件不会进行读取覆盖） 配置文件，分为 properties 和 yaml / yml yaml 配置是有序的，properties配置是无序的， 自定义的yaml目前暂时不支持使用注解直接注入到SpringBoot项目中。也就是只能使用 application.yaml 2.1 配置文件值注入1.使用@ConfigurationProperties方式获取类型安全注入 配置文件, application.yaml 12345678910111213141516171819stu: username: admin password: admin enable: true age: 23person: last-name: 张三 age: 23 boss: true birth: 1996/03/24 dog: dogName: 小白 dogAge: 1 maps: {code: 200, msg: success } students: - name: harry age: 20 - name: tom age: 23 JavaBean 12345678910111213141516171819/** * 将配置文件中配置的属性的值映射到组件中 * @ConfigurationProperties 告诉SpringBoot将本类中的所有属性和配置文件中相 * 关的配置进行绑定 * prefix 配置文件中哪个下面的所有属性进行一一映射 * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能。 */@ConfigurationProperties(prefix = \"person\")@Component@Datapublic class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Student&gt; students; private Dog dog;} 测试结果：(转为了JSON) 123456789101112131415161718192021222324{ \"age\": 23, \"birth\": 827596800000, \"boss\": true, \"dog\": { \"dogAge\": 1, \"dogName\": \"小白\" }, \"lastName\": \"张三\", \"maps\": { \"code\": 200, \"msg\": \"success\" }, \"students\": [ { \"age\": 20, \"name\": \"harry\" }, { \"age\": 23, \"name\": \"tom\" } ]} 我们可以导入配置文件处理器，以后编写配置文件就有提示了.没生效时，重新编译一下项目。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 读取properties文件中获取中文时，如果出现了中文乱码，则需要进行相应的设置 2.只用@Value进行获取 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定 支持（lastName与last-name） 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复制类型封装（map） 支持 不支持 复杂类型封装不支持map但是支持list 配置文件yml与properties文件它们都能获得到值； 如果只是在某个业务逻辑中需要获得以下配置文件中的某项值，使用@Value 如果专门编写了一个javabean来和配置文件进行映射，我们就直接使用@ConfigurationProperties 3.配置文件数据校验12345678910111213141516171819202122232425262728293031/** * 将配置文件中配置的属性的值映射到组件中 * @ConfigurationProperties 告诉SpringBoot将本类中的所有属性和配置文件中相 * 关的配置进行绑定 * prefix 配置文件中哪个下面的所有属性进行一一映射 * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能。 *///@ConfigurationProperties(prefix = \"person\")@Component@Validatedpublic class Person { /** * &lt;bean class=\"Person&gt; * &lt;perperty name=\"lastName\" value=\"字面量/${key}/#{SpEL}\"&gt;&lt;/perperty&gt; * &lt;/bean&gt; */// @Value(\"${person.last-name}\")// @Email private String lastName;// @Value(\"#{10*2}\") private Integer age;// @Value(\"false\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public Person() {}} 4.@PropertySource&amp;@ImportResource@PropertySource：加载指定的配置文件； person.properties文件 123456789person.last-name=李四person.age=12person.boss=falseperson.birth=2018/12/12person.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=小狗person.dog.age=12 person 123456789101112131415@ConfigurationProperties(prefix = \"person\")@PropertySource(value = {\"classpath:person.properties\"})@Componentpublic class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public Person() {}} 通过使用@PropertySource注解来指定配置文件，通过@ConfigurationProperties的prefix属性来指定前缀 @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效 SpringBoot里面没有spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来，@ImportResource标注在一个配置类上。 1234567@ImportResource(locations = {\"classpath:beans.xml\"})//导入Spring的配置文件@SpringBootApplicationpublic class SpringBoot02ConfigApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot02ConfigApplication.class, args); }} 但是SpringBoot不推荐这样使用。 1&lt;bean id=\"helloService\" class=\"com.ooyao.springboot.service.HelloService\"&gt;&lt;/bean&gt; SpringBoot推荐给容器添加组件的方式：推荐使用全注解的方式 1.配置类===配置文件 2.使用@Bean给容器添加组件 使用@Configuration注解来标注一个配置类。用@Bean注解来标志一个组件。 123456789@Configurationpublic class MyAppConfig {//将方法的返回值添加到容器中；容器中的组件默认的id就是方法名 @Bean public HelloService helloService(){ return new HelloService(); }} 2.2 配置文件占位符1.随机数12345${random.value}${random.int}${random.long}${random.int(10)}${random.int[1024,65536)} 2.占位符12345678person.last-name=张三${random.uuid}person.age=${random.int}person.boss=falseperson.birth=2018/12/12person.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.name:hi}_dog 2.3 ProfileProfile是Spring对不同环境提供不同配置功能的支持，可以通过激活，指定参数等方式快速切换环境。 1.多profile文件形式，​ 格式：application-{profile}.properties/yml:application-dev.properties,application-prod.properties 1spring.profiles.active=test 可以采用 properties文件或是 yaml 文件类型。 分别以 dev test prod 来代表三种不通的环境，将相应环境的配置信息放在相应的配置文件中。如果在三个配置文件中存在相同的配置信息，则可以统一放在application.yaml 或 application.properties文件中。 2.多profile文档块模式1234567891011121314151617server: port: 8081spring: profiles: active: dev ---server: port: 8088spring: profiles: dev---server: port: 8089spring: profiles: prod 上面最终监听的端口号是8088 使用spring.profiles来指定文档块的属性，使用spring.profiles.active指定读取哪个文档块 3.激活方式​ -命令行：–spring.profiles.active=prod -配置文件 spring.profiles.active=dev 1spring.profiles.active=dev/prod -jvm参数 -Dspring.profiles.active=dev 2.4配置文件加载位置springboot启动会扫描以下位置的application.properties/yml文件作为springboot的默认配置文件 1234-file:./config/ 当前项目的文件路径的config目录下 [1]-file:./ 当前项目的文件路径下 [2]-classpath:./config/ 当前项目的类路径下的config目录下 [3]-classpath:./ 当前项目类路径下 [4] 以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容 如下图示 我们也可以通过配置spring.config.location来改变默认配置 12在项目启动的时候可以指定配置文件的路径。使用下列命令。java -jar *.jar --spring.config.location=G:/application.properties 项目打包好之后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定配置文件和默认加载的这些配置文件会共同起作用，形成互补配置。 2.5外部配置加载顺序1.命令行参数 所有的配置都可以在命令行上进行指定 1java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 优先加载带profile 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档","link":"/2020/02/29/SSM/springboot/2.SpringBoot%E9%85%8D%E7%BD%AE/"},{"title":"08.SpringBoot之异常处理","text":"SpringBoot之异常处理 定制错误页面默认异常处理机制错误页面，首先我们来看一下没有配置错误页面的时候，出现错误时是什么样。 1234567@Controllerpublic class HelloController { @GetMapping(\"/hello\") public void hello(){ int i = 1 / 0; }} 访问： 其实，这个页面可以看出一些错误信息，但是对于用户来说就显得不太友好了，用户并不关心甚至不知道这是什么错误，同时也不需要知道，没有意义。那么我们为了提升用户体验，需要对错误进行定制一番。 而对于其他客户端，默认返回json数据时，是这样的： 1234567{ \"timestamp\": \"2020-03-02T08:55:14.118+0000\", \"status\": 404, \"error\": \"Not Found\", \"message\": \"No message available\", \"path\": \"/book\"} 我们来看一下原理： DefaultErrorAttributes 异常处理在 ErrorMvcAutoConfiguration 错误处理的自动装配。 12345@Bean@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() { return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException());} 我们进入这个类里面看一下 getErrorAttributes()方法。帮我们在页面共享信息。 12345678public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap(); errorAttributes.put(\"timestamp\", new Date()); this.addStatus(errorAttributes, webRequest); this.addErrorDetails(errorAttributes, webRequest, includeStackTrace); this.addPath(errorAttributes, webRequest); return errorAttributes;} BasicErrorController 123456789101112131415161718192021222324252627@Controller@RequestMapping(\"${server.error.path:${error.path:/error}}\")public class BasicErrorController extends AbstractErrorController { //产生html数据，浏览器发出的请求来到这个方法处理 @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap( getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //取哪个页面作为错误处理页面，包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model); } //产生json数据，其他客户端来到这个方法处理 @RequestMapping public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { HttpStatus status = getStatus(request); if (status == HttpStatus.NO_CONTENT) { return new ResponseEntity&lt;&gt;(status); } Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); return new ResponseEntity&lt;&gt;(body, status); }} ErrorPageCustomizer 123456789101112131415161718192021222324private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered { private final ServerProperties properties; private final DispatcherServletPath dispatcherServletPath; protected ErrorPageCustomizer(ServerProperties properties, DispatcherServletPath dispatcherServletPath) { this.properties = properties; this.dispatcherServletPath = dispatcherServletPath; } @Override public void registerErrorPages(ErrorPageRegistry errorPageRegistry) { ErrorPage errorPage = new ErrorPage( this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())); errorPageRegistry.addErrorPages(errorPage); } @Override public int getOrder() { return 0; }} this.properties.getError().getPath()) 这句取到的数据就是： 1234public class ErrorProperties { @Value(\"${error.path:/error}\") private String path = \"/error\";} 此时我们回来看BacisErrorController: 123@Controller@RequestMapping(\"${server.error.path:${error.path:/error}}\")public class BasicErrorController extends AbstractErrorController {} 可以发现这里指定了默认值，当然，我们也可以通过server.error.path在application.properties文件中指定。 DefaultErrorViewResolver 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView;}private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) { //默认springboot可以找一个页面, error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可以就直接在静态资源文件夹下面找到errorViewName对应的页面。error/404 return resolveResource(errorViewName, model);}private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) { for (String location : this.resourceProperties.getStaticLocations()) { try { Resource resource = this.applicationContext.getResource(location); resource = resource.createRelative(viewName + \".html\"); if (resource.exists()) { return new ModelAndView(new HtmlResourceView(resource), model); } } catch (Exception ex) { } } return null;} 一旦系统出现4xx或者5xx之类的错误。ErrorPageCustomizer就会生效，（定错误的响应规则）就会来到/error请求，就会被BasicErrorController处理。 自定义Controller实现BasicErrorController的功能 123456789101112131415161718@Controller@RequestMapping(\"/hello\")public class HelloController { @GetMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView helloHtml(){ ModelAndView modelAndView = new ModelAndView(); System.out.println(\"处理浏览器页面请求\"); modelAndView.setViewName(\"error/404.html\"); return modelAndView; } @GetMapping public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { Map&lt;String,Object&gt; body = new HashMap&lt;&gt;(); body.put(\"message\",\"处理其他客户端请求\"); return new ResponseEntity&lt;&gt;(body, HttpStatus.OK); }} 静态页面下面我们就先利用静态页面来显示定制错误页面： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;404&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 将上述页面命名为404. 并且将其中的404改为 500,4xx,5xx , 并且改响应的文件名。页面存在 static/error目录中。 我们再次访问： 同时访问一个不存在的地址，比如localhost:8080/hello2. 会出现404. 如果我们响应的把404.html 和 500.html页面删除，显示的就是5xx.html 和 4xx.html。 动态页面这里我们使用thymeleaf 来做动态错误页面定制，这样，我们可以定制通用的页面。 引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 定制动态页面： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;templates-4xx&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 同样，定制400.html, 4xx.html, 500.html, 5xx.html.放在 resources/templates/error 目录下。运行可以达到同样的效果，并且可以使用thymeleaf进行定制。 如果静态页面和动态页面都存在呢？或者是动态页面有404.html，静态没有404.html，或是静态页面有404.html，动态页面没有404.html呢？以及4xx.html? 经测试：优先使用精确的(404.html) ,没有则使用通用的(4xx.html)。优先使用动态的(templates/error),没有再使用静态的(static/error); 即完整的错误页面查找方式应该是这样：发生500错误–&gt;查找动态 500.html –&gt;查找静态 500.html –&gt; 查找动态 5xx.html–&gt;查找静态 5xx.html 定制异常数据我们可以通过注解@ControllerAdvice 和 @ExceptionHandler注解来处理异常。如下： 自定义异常处理&amp;返回定制Json数据123456789101112@ControllerAdvicepublic class MyExceptionHandler { //浏览器,客户端返回的都是json数据 @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; }} 转发/error进行自适应响应结果处理1234567891011121314151617@ExceptionHandler(UserNotExistException.class)public String handleException(Exception e){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return \"forward:/error\";}@ExceptionHandler(UserNotExistException.class)public String handleException(Exception e, HttpServletRequest request){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码。 request.setAttribute(\"javax.servlet.error.status_code\",500);//要想进行自适应需要设置状态码 map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return \"forward:/error\";} 前面我们已经可以看到一些错误基本数据： 1234567{ \"timestamp\": \"2020-03-02T08:55:14.118+0000\", \"status\": 404, \"error\": \"Not Found\", \"message\": \"No message available\", \"path\": \"/book\"} 那么我们如何修改默认的数据呢？ 将定制数据携带出去出现错误以后，会来到/error请求，会被BasicErrorController处理；响应出去可以获得的数据是由getErrorAttributes得到的（是在AbstractErrorController（ErrorController）规定的方法） ​ 1）完全类编写一个errorcontroller的实现类，或继承AbstractErrorController，放在容器中 ​ 2）页面上能用的数据，或者是json返回能用的数据，都是errorAttributes.getErrorAttributes获得的。 ​ 容器中DefaultErrorAttributes.getErrorAttributes默认进行数据处理的， 123456789101112@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, includeStackTrace); map.put(\"author\",\"ooyhao\"); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyy-MM-dd HH:mm:ss\"); map.put(\"timestamp\",simpleDateFormat.format(new Date())); return map; }} 测试及结果：","link":"/2020/03/04/SSM/springboot/8.SpringBoot%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"一、Windows上安装单机版Nacos","text":"Windows上安装单机版Nacos Nacos官网：https://nacos.io/zh-cn/ 下载Nacos到github (https://github.com/alibaba/nacos)下载安装程序,点击releases，选择需要下载的版本。zip包。 解压安装包下载并解压，文件目录如下： 部署Nacos我们可以参考官网：https://nacos.io/zh-cn/docs/deployment.html 创建数据库1CREATE DATABASE nacos_devtest; 初始化数据库初始化Sql位于conf目录下的 nacos-mysql.sql 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info *//******************************************/CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(20) DEFAULT NULL COMMENT 'source ip', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_aggr *//******************************************/CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) NOT NULL COMMENT 'group_id', `datum_id` varchar(255) NOT NULL COMMENT 'datum_id', `content` longtext NOT NULL COMMENT '内容', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_beta *//******************************************/CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `beta_ips` varchar(1024) DEFAULT NULL COMMENT 'betaIps', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(20) DEFAULT NULL COMMENT 'source ip', `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_tag *//******************************************/CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `tag_id` varchar(128) NOT NULL COMMENT 'tag_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(20) DEFAULT NULL COMMENT 'source ip', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_tag';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_tags_relation *//******************************************/CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT 'id', `tag_name` varchar(128) NOT NULL COMMENT 'tag_name', `tag_type` varchar(64) DEFAULT NULL COMMENT 'tag_type', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_tag_relation';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = group_capacity *//******************************************/CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `group_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='集群、各Group容量信息表';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = his_config_info *//******************************************/CREATE TABLE `his_config_info` ( `id` bigint(64) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00', `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00', `src_user` text, `src_ip` varchar(20) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='多租户改造';/******************************************//* 数据库全名 = nacos_config *//* 表名称 = tenant_capacity *//******************************************/CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `tenant_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Tenant ID', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='租户容量信息表';CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `kp` varchar(128) NOT NULL COMMENT 'kp', `tenant_id` varchar(128) default '' COMMENT 'tenant_id', `tenant_name` varchar(128) default '' COMMENT 'tenant_name', `tenant_desc` varchar(256) DEFAULT NULL COMMENT 'tenant_desc', `create_source` varchar(32) DEFAULT NULL COMMENT 'create_source', `gmt_create` bigint(20) NOT NULL COMMENT '创建时间', `gmt_modified` bigint(20) NOT NULL COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='tenant_info';CREATE TABLE users ( username varchar(50) NOT NULL PRIMARY KEY, password varchar(500) NOT NULL, enabled boolean NOT NULL);CREATE TABLE roles ( username varchar(50) NOT NULL, role varchar(50) NOT NULL);INSERT INTO users (username, password, enabled) VALUES ('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', TRUE);INSERT INTO roles (username, role) VALUES ('nacos', 'ROLE_ADMIN'); 此时，我们数据库已经初始化准备好了。 修改数据库配置打开conf目录下的application.properties文件，添加下面内容： 123456spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_devtest? characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=root 启动Nacos进入 bin目录中，双击startup.sh，启动Nacos。 访问Nacos服务登录此时我们访问：localhost:8848/nacos.会出现登录界面：使用nacos/nacos，进行登录。 服务列表如图所示，我们可以看到服务列表，但是由于我们没有注册任何的服务生产者和服务消费者，所以此时的列表是空的。 至此，在Windows上安装单机版Nacos就完成了。So Easy！","link":"/2020/01/18/SSM/springcloudalibaba/0.1.Windows%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Nacos/"},{"title":"十九、Sentinel规则之熔断降级规则","text":"除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。 降级策略我们通常用以下几种方式来衡量资源是否处于稳定的状态： 平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。 异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。 异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。 注意：异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常（BlockException）不生效。为了统计异常比例或异常数，需要通过 Tracer.trace(ex) 记录业务异常。示例： 降级演示平均响应时间RT初始化降级规则： 12345678910111213141516171819public static void main(String[] args) { SpringApplication.run(SentinelDegradeRuleApplication.class, args); initDegradeRuleForRT();}public static void initDegradeRuleForRT(){ List&lt;DegradeRule&gt; rules = new ArrayList&lt;&gt; (); DegradeRule rule = new DegradeRule(); //设置资源名 rule.setResource(\"echo\"); //设置40毫秒 rule.setCount(40); //阈值类型为平均响应时间 rule.setGrade(RuleConstant.DEGRADE_GRADE_RT); //时间窗口设置为5秒 rule.setTimeWindow(5); rules.add(rule); DegradeRuleManager.loadRules(rules);} 程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243@RestControllerpublic class EchoController { @Autowired private EchoService echoService; @GetMapping(\"/echo/{str}\") public String echo(@PathVariable String str){ SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); for (int i = 1; i &lt;= 10; i++) { try { String echo = echoService.echo(str); System.out.println(\"第\"+i+\"次： echo:\"+echo+\" | 时间:\"+dateFormat.format(new Date())); TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } return \"访问成功\"; }}//Servicepublic interface EchoService { String echo(String str);}//ServiceImpl@Servicepublic class EchoServiceImpl implements EchoService { @Override @SentinelResource(value = \"echo\",blockHandler = \"handleBlockException\") public String echo(String str) { try { TimeUnit.MILLISECONDS.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } return \"返回值:\"+str; } public String handleBlockException(String str, BlockException ex){ return \" 服务降级处理：\"+str+\" 异常为：\"+ex.getClass().getSimpleName(); }} 访问： 12345678910第1次： echo:返回值:123 | 时间:2019-10-23 14:13:02:809第2次： echo:返回值:123 | 时间:2019-10-23 14:13:02:859第3次： echo:返回值:123 | 时间:2019-10-23 14:13:02:910第4次： echo:返回值:123 | 时间:2019-10-23 14:13:02:960第5次： echo:返回值:123 | 时间:2019-10-23 14:13:03:010第6次： echo: 服务降级处理：123 异常为：DegradeException | 时间:2019-10-23 14:13:03:049第7次： echo: 服务降级处理：123 异常为：DegradeException | 时间:2019-10-23 14:13:03:049第8次： echo: 服务降级处理：123 异常为：DegradeException | 时间:2019-10-23 14:13:03:050第9次： echo: 服务降级处理：123 异常为：DegradeException | 时间:2019-10-23 14:13:03:050第10次： echo: 服务降级处理：123 异常为：DegradeException | 时间:2019-10-23 14:13:03:050 通过程序可以看出，平均响应时间(RT)是先计算前5次的请求的平均处理时间，如果超过了预定的阈值时间(count)，那么在接下来的时间范围/窗口(timeWindow)后直接进行服务降级，抛出DegradeException. 等待timeWindow过后，又会重新计算RT。 我们看一下实时监控： 异常比例初始化规则： 1234567891011121314public static void initDegradeRuleForExceptionRatio(){ List&lt;DegradeRule&gt; rules = new ArrayList&lt;&gt;(); DegradeRule rule = new DegradeRule(); //资源名 rule.setResource(\"echo\"); //阈值类型：异常比例 rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO); //阈值 rule.setCount(0.5); //时间窗口为5秒 rule.setTimeWindow(5); rules.add(rule); DegradeRuleManager.loadRules(rules);} 测试程序: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//controller@RestControllerpublic class EchoController { @Autowired private EchoService echoService; @GetMapping(\"/echo/{str}\") public String echo(@PathVariable String str) { SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); for (int i = 1; i &lt;= 10; i++) { String echo = echoService.echo(str, i); System.out.println(\"第\" + i + \"次： echo:\" + echo + \" | 时间:\" + dateFormat.format(new Date())); } try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } return \"访问成功\"; }}// servicepublic interface EchoService { String echo(String str, int i);}//serviceImpl/** * @author hao.ouYang * @create 2019-10-22 11:05 */@Servicepublic class EchoServiceImpl implements EchoService { @Override @SentinelResource(value = \"echo\",blockHandler = \"handleBlockException\",fallback = \"fallbackFun\") public String echo(String str,int i) { try { TimeUnit.MILLISECONDS.sleep(150); } catch (InterruptedException e) { e.printStackTrace(); } if ( i % 2 == 1){ throw new IRuleException(); } return \"返回值:\"+str; } public String handleBlockException(String str,int i, BlockException ex){ return \" 服务降级处理：\"+str+\" 参数i:\"+i+\" 异常为：\"+ex.getClass().getSimpleName(); } public String fallbackFun(String str,int i, Throwable throwable){ return \" 服务降级处理：\"+str+\" 参数i:\"+i+\" 异常为：\"+throwable.getClass().getSimpleName(); }} 测试结果： 总结：一秒内要保证访问数量超过5次，否则不会出发异常比例的服务熔断降级。比例超过预定的0.5之后就会触发降级 异常数异常数是统计1分钟时间的内，所以当时间窗口包含在统计时间内，可能一分钟之后又会立即进入统计时间范围中 。 1234567891011121314public static void initDegradeRuleForExceptionCount(){ List&lt;DegradeRule&gt; rules = new ArrayList&lt;&gt;(); DegradeRule degradeRule = new DegradeRule(); //设置异常数阈值 degradeRule.setCount(5); //阈值类型：异常数 degradeRule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT); //资源名称 degradeRule.setResource(\"echo\"); //时间窗口 degradeRule.setTimeWindow(10); rules.add(degradeRule); DegradeRuleManager.loadRules(rules);}","link":"/2020/01/18/SSM/springcloudalibaba/16.sentinel%E8%A7%84%E5%88%99%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E8%A7%84%E5%88%99/"},{"title":"五、Ribbon实现负载均衡","text":"Ribbon实现负载均衡 官方文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.2.0.M3/reference/html/#spring-cloud-ribbon 概述下面是截取官方文档的两段话，我们可以大概看一下： Ribbon是什么：Ribbon是一个客户端负载均衡器。提供了大量的Http和Tcp客户端行为。Feign已经使用了Ribbon，所以，如果使用@FeignClient ，这一部分也被采用。Feign后面也会介绍到。 这一部分使用到了Nacos服务注册中心，所以需要先准备好注册中心，前面有介绍。 项目结构 父级依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.ooyhao&lt;/groupId&gt; &lt;artifactId&gt;nacos-feign-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;modules&gt; &lt;module&gt;nacos-feign-service-provider-1&lt;/module&gt; &lt;module&gt;nacos-feign-service-provider-2&lt;/module&gt; &lt;module&gt;nacos-feign-service-provider-3&lt;/module&gt; &lt;module&gt;nacos-feign-service-consumer&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;0.9.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 负载均衡是面向同一服务的集群使用的，所以我们一般都是将同一服务部署到不同的主机上，即拥有不同Ip、相同或不同端口，本地测试，用端口来标识不同的服务。 服务提供者依赖123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.ooyhao&lt;/groupId&gt; &lt;artifactId&gt;nacos-feign-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;groupId&gt;com.ooyhao&lt;/groupId&gt; &lt;artifactId&gt;nacos-feign-service-provider-1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置文件下面是三个服务的不同的配置文件： 配置文件一 123456789101112server:# 服务端口 port: 8071spring:# 项目/服务 名 application: name: feign-service-provider cloud: nacos: discovery:# 注册中心地址：端口 server-addr: 127.0.0.1:8848 配置文件二 123456789101112server:# 服务端口 port: 8072spring:# 项目/服务 名 application: name: feign-service-provider cloud: nacos: discovery:# 注册中心地址：端口 server-addr: 127.0.0.1:8848 配置文件三 123456789101112server:# 服务端口 port: 8073spring:# 项目/服务 名 application: name: feign-service-provider cloud: nacos: discovery:# 注册中心地址：端口 server-addr: 127.0.0.1:8848 其实就是指定相同的服务名，不同的端口，并且配置到注册中心，即可。 User1234567891011121314package com.ooyhao.nacosfeignserviceprovider.pojo;import lombok.AllArgsConstructor;import lombok.Data;import java.io.Serializable;@Data@AllArgsConstructorpublic class User implements Serializable { private Integer id; private String username; private String password; private Integer age;} 主程序1234567@SpringBootApplication@EnableDiscoveryClientpublic class NacosFeignServiceProvider1Application { public static void main(String[] args) { SpringApplication.run(NacosFeignServiceProvider1Application.class, args); }} 说明：这里会发现一个问题，如果没有写@enableDiscoveryClient 注解，也是可以将自身注册到注册中心去的，在网上看到，从Spring Cloud Edgware开始，@EnableDiscoveryClient 或@EnableEurekaClient 可省略，测试结果也是如此，于是我翻阅了一下Spring官方文档，看到了下面这段话，即：@EnableDiscoveryClient 不再是必须的了，你可以将DiscoveryClient的实现类置于SpringBoot项目的ClassPath中就可以注册服务。也就是说，我们只需要在POM文件中添加相关依赖，在配置文件中配置相应的配置，就可以自动实现服务注册于发现了。 https://cloud.spring.io/spring-cloud-static/spring-cloud-commons/2.2.0.M3/reference/html/#enablediscoveryclient Controller123456789101112131415161718@RestControllerpublic class IndexController { private static Map&lt;Integer,User&gt; users = new HashMap&lt;&gt;(); static { users.put(1,new User(1,\"张三\",\"provider-1\",18)); users.put(2,new User(2,\"李四\",\"provider-1\",19)); users.put(3,new User(3,\"王五\",\"provider-1\",20)); } @GetMapping(\"/user/{id}\") public User user(@PathVariable(\"id\") Integer id){ System.out.println(\"provider 1 rec\"); return users.get(id); }} 这里需要修改下不同的服务的password，用于后续观察负载均衡的效果。 服务消费者依赖123456789101112131415server: port: 8080spring: application: name: feign-service-consumer cloud: nacos: discovery: server-addr: 127.0.0.1:8848# 配置负载均衡策略#feign-service-provider:# ribbon:# NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule UserUser对象就不再赘述了。将服务提供方的User对象复制过来即可。这里测试发现，服务提供方的User类和服务消费方的User类可以不需要放在相同的包下，这点与RabbitMQ的自动序列化和反序列化要求不同 。 Controller12345678910111213141516171819202122/** * 描述: * 类【IndexController】 * * @author ouYangHao * @create 2019-10-15 9:57 */@RestControllerpublic class IndexController { @Autowired private RestTemplate restTemplate; @GetMapping(\"/user/{id}\") public User user(@PathVariable(\"id\") Integer id){ User user = restTemplate.getForObject(\"http://feign-service-provider/user/\" + id, User.class); System.out.println(user); return user; }} 这里可以发现，使用RestTemplate进行Http接口调用的时候，使用的是服务名feign-service-provider ,而不是IP加端口的形式，这样就把IP地址与服务名的映射关系的任务交给注册中心去维护了。我们只需要知道服务名就可以，至于服务在世界何处不用关心。 主程序123456789101112131415161718192021@SpringBootApplication@EnableDiscoveryClientpublic class NacosFeignServiceConsumerApplication { @Bean public IRule iRule(){ return new RandomRule();//随机策略// return new RoundRobinRule();//轮询策略 } @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(NacosFeignServiceConsumerApplication.class, args); }} 测试随机策略这里我们先试用随机策略来测试：连续多次刷新访问下面路径： http://localhost:8080/user/1 可以看出，当前测试结果符合预定随机策略结果。 轮询策略我们将iRule方法换成轮询方式，重新启动： 1234@Beanpublic IRule iRule(){ return new RoundRobinRule();//随机策略} 测试结果： 测试结果符合轮询规则！","link":"/2020/01/18/SSM/springcloudalibaba/2.Ribbon%E5%92%8CRestTemplate%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"title":"六、Feign服务调用","text":"Feign服务调用 ​ 前一节有说到，Feign使用了Ribbon，即具有了Ribbon的负载均衡的功能。这一节主要是基于上一节的程序上，使用Feign这个伪Http客户端来进行服务调用。 Feign是一个声明式web服务客户端，它让我们写web服务客户端更加简单。使用Feign只需要创建一个接口并标相应的注解。 Feign is a declarative web service client. It makes writing web service clients easier. To use Feign create an interface and annotate it. It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders. Spring Cloud adds support for Spring MVC annotations and for using the same HttpMessageConverters used by default in Spring Web. Spring Cloud integrates Ribbon and Eureka to provide a load balanced http client when using Feign. 官方文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/2.2.0.M3/reference/html/ 程序基于上一节，即Ribbon和RestTemplate实现服务负载均衡。 服务提供方Controller12345678910111213141516171819202122232425262728293031323334353637@RestControllerpublic class IndexController { private static Map&lt;Integer,User&gt; users = new HashMap&lt;&gt;(); static { users.put(1,new User(1,\"张三\",\"provider-1\",18)); users.put(2,new User(2,\"李四\",\"provider-1\",19)); users.put(3,new User(3,\"王五\",\"provider-1\",20)); } @GetMapping(\"/echo/{str}\") public String echo(@PathVariable(\"str\") String str){ return \"provider-1 echo : \"+str; } @GetMapping(\"/user/{id}\") public User user(@PathVariable(\"id\") Integer id){ System.out.println(\"provider 1 rec\"); return users.get(id); } @GetMapping(\"/exist\") public boolean exist(User user){ System.out.println(\"provider 1 rec\"); boolean isExist = false; for (Map.Entry&lt;Integer,User&gt; userEntry : users.entrySet()){ if (userEntry.getValue().getUsername().equals(user.getUsername()) &amp;&amp; userEntry.getValue().getPassword().equals(user.getPassword())){ isExist = true; break; } } return isExist; }} 服务消费方依赖使用Feign，我们需要先导入Feign的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 主程序1234567891011121314151617181920@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class NacosFeignServiceConsumerApplication { @Bean public IRule iRule(){ return new RoundRobinRule();//轮询策略 } @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(NacosFeignServiceConsumerApplication.class, args); }} 注意：这里我们使用@EnableFeignClients 注解，来启用Feign客户端功能。重点是我们如何来使用feign调用服务。如下： Feign服务接口123456789@FeignClient(value = \"feign-service-provider\")public interface FeignService { @GetMapping(\"/echo/{str}\") String echo(@PathVariable(\"str\") String str); @GetMapping(\"/exist\") boolean exist(@SpringQueryMap User user);} 我们可以发现，这里与服务提供方的controller方法很类似，首先，声明一个接口，使用@FeignClient 注解来标注此接口为Feign客户端接口，使用value 属性来标注是哪一个服务，value指定服务名。细心的可能已经发现这里出现了一个新的注解@StringQueryMap 注解，后面会介绍到。 Controller使用Feign服务：首先将服务接口注入，其他就与普通的方法调用一样。 12345678910111213141516171819202122232425262728293031@RestControllerpublic class IndexController { @Autowired private FeignService feignService; @Autowired private RestTemplate restTemplate; @GetMapping(\"/echo/{str}\") public HashMap echo(@PathVariable(\"str\") String str) { HashMap map = new HashMap(); String echo = feignService.echo(str); System.out.println(\"message:\" + echo); map.put(\"message\", echo); return map; } //使用RestTemplate调用 @GetMapping(\"/user/{id}\") public User user(@PathVariable(\"id\") Integer id) { User user = restTemplate.getForObject(\"http://feign-service-provider/user/\" + id, User.class); System.out.println(user); return user; } @GetMapping(\"/exist\") public boolean exist(User user) { return feignService.exist(user); }} 效果图 @StringQueryMap https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/2.2.0.M3/reference/html/#feign-querymap-support The OpenFeign @QueryMap annotation provides support for POJOs to be used as GET parameter maps. Unfortunately, the default OpenFeign QueryMap annotation is incompatible with Spring because it lacks a value property. Spring Cloud OpenFeign provides an equivalent @SpringQueryMap annotation, which is used to annotate a POJO or Map parameter as a query parameter map. OpenFeign的 @QueryMap 注解提供了Get请求的POJOS的参数支持，遗憾的是，这个OpenFeign的默认QueryMap注解由于缺少value属性而不太适用。 12345@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.PARAMETER})public @interface QueryMap { boolean encoded() default false;} SpringCloudOpenFeign提供了一个相同功能的注解：@SpringQueryMap ,它可以标注PoJo或Map用来作为请求参数。 123456789@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.PARAMETER})public @interface SpringQueryMap { @AliasFor(\"encoded\") boolean value() default false; @AliasFor(\"value\") boolean encoded() default false;} 我们再回来看看Feign这个接口： 123456789@FeignClient(value = \"feign-service-provider\")public interface FeignService { @GetMapping(\"/echo/{str}\") String echo(@PathVariable(\"str\") String str); @GetMapping(\"/exist\") boolean exist(@SpringQueryMap User user);} 当我们不使用@SpringQueryMap 注解是，会抛出如下异常： 正常测试结果： Feign 日志 https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/2.2.0.M3/reference/html/#feign-logging 配置文件123logging: level: com.ooyhao.nacosfeignserviceconsumer.feignserver: debug The Logger.Level object that you may configure per client, tells Feign how much to log. Choices are: NONE, No logging (DEFAULT). BASIC, Log only the request method and URL and the response status code and execution time. HEADERS, Log the basic information along with request and response headers. FULL, Log the headers, body, and metadata for both requests and responses. Feign的日志级别有以上几种方式： NONE：没有日志，默认（性能高）。 BASIC：记录请求方法和请求路径，响应状态码和执行时间。 HEADERS：记录基本的请求和响应头信息。 FULL：记录请求/响应头，体和元数据。 123456class FooConfig{ @Bean Logger.Level level(){ return Logger.Level.FULL; }} 效果图下面是调用效果： Feign继承 https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/2.2.0.M3/reference/html/#spring-cloud-feign-inheritance 上面是从SpringCloud OpenFeign官方文档截图的，说：这显示是不明智的在Feign服务端和客户端共享一个接口，这样会提高耦合度，所以这里就做演示了。","link":"/2020/01/18/SSM/springcloudalibaba/3.Feign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"},{"title":"二十三、SpringCloud Gateway 的初体验","text":"Gateway的路由谓词工厂 相关概念(术语) 路由 (Route)： 路由是网关的基础构建模块，它是有ID，目标URI，谓词集合和过滤器集合定义。如果聚合谓词为true，则匹配路由。 谓词 (Predicate)： 这是Java8的函数谓词，输入类型是Spring Framework ServerWebExchange, 这使得开发者可以匹配HTTP请求中的所有内容，例如 header 和 参数。 过滤器 (Filter)： 这些是使用特定工厂构建的SpringFramework GatewayFilter 实例。在此，可以在发送下游请求之前或之后修改请求和响应。 路由谓词工厂SpringCloudGateway 将路由作为 Spring WebFlux HandlerMapping 基础架构的一部分进行匹配。SpringCloudGateway 包括许多内置的Route Predicate factory。所有这些谓词都与HTTP请求的不同属性匹配。多个Route Predicate工厂可以合并，也可以通过逻辑合并 and 。 1. After 路由谓词After Route Predicate Factory 采用一个参数，即日期时间。该谓词匹配在当前日期时间之后发生的请求。 2. Before 路由谓词Before Route Predicate Factory 采用一个参数，即日期时间。该谓词匹配在当前日期时间之前发生的请求。 3. Between 路由谓词Between Route Predicate Factory 采用两个参数，都是日期时间类型的，该谓词匹配在两个日期之间发生的请求。 下面是统一的配置： 12345678910spring: cloud: gateway: routes: - id: gateway-service uri: https://www.163.com predicates: # - Before= 2019-10-25T00:00:00+08:00[Asia/Shanghai] # - After= 2019-10-25T00:00:00+08:00[Asia/Shanghai] - Between= 2019-10-25T00:00:00+08:00[Asia/Shanghai],2019-10-25T18:05:00+08:00[Asia/Shanghai] 说明： 如果是时间之前的，使用Before关键字。如果是时间之后的，使用After关键字，如果要指明在两个日期之间，则使用Between 关键字，两个日期使用逗号隔开。[Asia/Shanghai] 表示使用的是以上海为基准的时间。 4. Cookie 路由谓词Cookie路由谓词工厂采用的是两个参数，一个是Cookie的名字，另外一个是合法的正则表达式。这个谓词用于匹配具有给定名称的Cookie，并且值匹配一个合法的正则表达式。 12345678spring: cloud: gateway: routes: - id: gateway-service uri: http://www.163.com predicates: - Cookie= username,kee.e 说明：这里是采用验证cookie的方式，当我们请求中携带了对应的正确的cookie信息，就可以访问成功到http://www.163.com ， 否则就会报 Not Found . 下面是使用Postman测试的结果： 错误的cookie信息： 正确的cookie信息： 如果使用gateway时， 需要取出 cookie信息，可以使用下面的方法： 1234@GetMapping(\"/resp\")public String test(@CookieValue(\"username\") String username) { return \"SUCCESS\";} 5. Header 路由谓词Header 路由谓词工厂接受两个参数：header的name和其对应的合法的正则表达式值。只有在Header部分存在name并且其value也匹配的情况下，才能通过。 12345678spring: cloud: gateway: routes: - id: gateway-service uri: http://www.163.com predicates: - Header=password,123456 测试结果如下： 如果使用Gateway，需要从Header中取出信息，可以使用下面的方法： 1234@GetMapping(value = \"/testHeader\")public String testHeader(@RequestHeader(value = \"username\") String username){ return \"username:\"+username;} 6. Host 路由谓词Host（主机）路由谓词工厂，采用一个参数：主机名模式列表。该模式带有. 作为分隔符的Ant样式的模式，谓词与Host 匹配模式的Header部分。 12345678spring: cloud: gateway: routes: - id: gateway-service uri: http://localhost:8888 predicates: - Host= localhost:9999 这里为了更好的测试，我们单创建并启动一个服务，端口为8888的，大概代码如下： 12345678910111213141516171819202122232425262728293031/** * @author hao.ouYang * @create 2019-10-25 18:08 */@RestControllerpublic class UserController { @Autowired private UserService userService; @RequestMapping(\"/user\") public User findUser(){ return userService.findUser(); }}@Servicepublic class UserService { public User findUser(){ User user = new User(1,\"admin\",\"admin\"); return user; }}@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable { private Integer id; private String username; private String password;} 测试结果如下： 上面其实是将http://localhost:9999/user 映射到了 http://localhost:8888/user 上了。 注意：当然除了我们除了上面的写法，还有一些多样化的定制。同时也支持URI模板变量 123- Host= www.ouyang.**, **.ouyang.**,**.ouyang.org# 上面的例子可以匹配 www.ouyang.club, www.ouyang.com, www.ouyangorg等。- Host= {sub}.ouyang.club 7. Method 路由谓词方法路由谓词工厂采用一个参数：用来匹配HTTP请求的类型。(GET,POST等). 12345678spring: cloud: gateway: routes: - id: gateway-service uri: http://localhost:8888 predicates: - Method= POST 以上需要匹配为POST 类型的请求才可以转发到 http://localhost:8888 上面，测试如下： 更改为POST 类型的请求： 8. Path 路由谓词PathRoutePredicateFactory 需要PathMatcher 模式路径列表和一个可选的标志位参数matchOptionalTrailingSeparator. 这是最常用的一个路由谓词。 12345678spring: cloud: gateway: routes: - id: gateway-service uri: http://localhost:8888 predicates: - Path= /path 这种使用路径来映射的方式。以上可以将http://localhost:9999/path 映射到http://localhost:8888/path 路径上，前一节也见过这个谓词，所以说这个谓词是最常用。还可以通过下面这个方式在请求路径上携带参数：（如果通过这种形式配置，在匹配命中进行路由的同时，会提取路径中对应的内容并且将键值对放在ServerWebExchange.getAttributes()集合中，Key为ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE, 这些提取出来的属性可以供GatewayFilter Factories 使用）。 12345678spring: cloud: gateway: routes: - id: gateway-service uri: http://localhost:8888 predicates: - Path= /testPath/{stri} 另一个服务的接收： 123456789@GetMapping(value = \"/path\")public String path(){ return \"path\";}@GetMapping(value = \"/testPath/{str}\")public String testPath(@PathVariable(\"str\") String str){ return \"return:\"+str;} 9. Query 路由谓词请求查询参数路由工厂QueryRoutePredicateFactory 需要一个必须的请求查询参数(Param的name)以及一个可选的正则表达式(regexp). 12345678910spring: application: name: spring-cloud-gateway cloud: gateway: routes: - id: gateway-service uri: http://localhost:8888 predicates: - Query= username 通过上述配置，我们的请求中只需要包含username参数即可匹配路由。 1curl localhost:9999/testQuery?username=1 上面的测试可以通过，但是如果把username 删除或是改成别的，就无法匹配了。 还可以将Query参数以键值对的形式来配置，这样的请求过来的时候，不仅需要匹配名字，同时参数值需要与正则表达式匹配才能走路径。 12345678910spring: application: name: spring-cloud-gateway cloud: gateway: routes: - id: gateway-service uri: http://localhost:8888 predicates: - Query= username,ad. 以上匹配需要请求满足既有username 参数，并且值需要以ad 开头的长度为3的字符串才能匹配和路由。 测试如下： 12345curl http://localhost:9999/testQuery?username=adv{\"param\":\"adv\"}curl http://localhost:9999/testQuery?username=addv{\"timestamp\":\"2019-10-27T09:15:45.580+0000\",\"path\":\"/testQuery\",\"status\":404,\"error\":\"Not Found\",\"message\":null} 8888端口服务的controller方法为： 123456@GetMapping(value = \"/testQuery\")public Map&lt;String,String&gt; testQuery(@RequestParam(\"username\") String username){ Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"param\",username); return map;} 10. RemoteAddr 路由谓词 RemoteAddrRoutePredicateFactory匹配规则采用CIDR符号（IPv4或IPv6）字符串的列表（最小值为1），例如192.168.0.1/16（其中192.168.0.1是远程IP地址并且16是子网掩码）。 123456789101112spring: application: name: spring-cloud-gateway cloud: gateway: routes: - id: gateway-service uri: http://localhost:8888 predicates: - RemoteAddr= 127.0.0.1server: port: 9999 8888端口服务的处理方法： 1234@GetMapping(value = \"/remote\")public String testRemote(){ return \"Remote\";} 测试结果： 123curl http://127.0.0.1:9999/remote# 响应结果Remote 11. Weight 路由谓词权重路由谓词工厂采用两个参数，分别为组(group)和权重(weight). 权重按组进行计算。 12345678910111213141516spring: application: name: spring-cloud-gateway cloud: gateway: routes: - id: gateway-weight-high uri: http://localhost:8888 predicates: - Weight= Group1, 8 - id: gateway-weight-low uri: http://localhost:7777 predicates: - Weight= Group1, 2server: port: 9999 接受7777和8888请求的方法： 12345678910111213141516//============port:7777 ============@GetMapping(value = \"/weight\")public Map weight() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"port\", \"7777\"); return map;}//============port:8888 ============@GetMapping(value = \"/weight\")public Map weight() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"port\", \"8888\"); System.out.println(map); return map;} 测试结果如下： 参考了： https://www.cnblogs.com/throwable/p/10807704.html","link":"/2020/01/18/SSM/springcloudalibaba/21.gateway%E8%B7%AF%E7%94%B1%E8%B0%93%E8%AF%8D/"},{"title":"十、Nacos的自动刷新和多环境管理","text":"Nacos的自动刷新和多环境管理 自动刷新所谓自动刷新，通俗说就是指当我们在Nacos配置中心管理界面修改之后，相应服务会自动读取到修改后的配置。 自动刷新的功能是默认开启的，测试如下： 修改主程序123456789101112131415@SpringBootApplicationpublic class NacosConfigSimpleApplication { public static void main(String[] args) throws InterruptedException { ConfigurableApplicationContext applicationContext = SpringApplication.run(NacosConfigSimpleApplication.class, args); //取到Spring的配置环境 while(true){ ConfigurableEnvironment environment = applicationContext.getEnvironment(); String username = environment.getProperty(\"user.name\"); String age = environment.getProperty(\"user.age\"); System.out.println(\"username:\"+username+\" | age:\"+age); TimeUnit.SECONDS.sleep(1); } }} 测试结果然后我们修改相应的配置文件的age字段的数据，可以看到Idea的控制输出信息： 关闭自动刷新12spring.cloud.nacos.config.refresh.enabled = false # 关闭动态刷新 可以通过上述配置来关闭配置自动刷新。 我们可以看看源码：[默认为true]。 1234567891011121314@Componentpublic class NacosRefreshProperties { @Value(\"${spring.cloud.nacos.config.refresh.enabled:true}\") private boolean enabled = true; public boolean isEnabled() { return enabled; } public void setEnabled(boolean enabled) { this.enabled = enabled; }} Nacos的配置类：NacosConfigProperties 1234567891011121314151617181920212223242526272829303132333435@ConfigurationProperties(NacosConfigProperties.PREFIX)public class NacosConfigProperties { public static final String PREFIX = \"spring.cloud.nacos.config\"; private String serverAddr; private String encode; private String group = \"DEFAULT_GROUP\"; private String prefix; private String fileExtension = \"properties\"; private int timeout = 3000; private String endpoint; private String namespace; private String accessKey; private String secretKey; private String contextPath; private String clusterName; private String name; private String sharedDataids; private String refreshableDataids; private List&lt;Config&gt; extConfig; private ConfigService configService; //getter &amp; setter public static class Config { private String dataId; private String group = \"DEFAULT_GROUP\"; private boolean refresh = false; //getter &amp; setter } //toString public ConfigService configServiceInstance() {...}} NacosConfig 自动配置：NacosConfigAutoConfiguration 1234@Configuration@ConditionalOnProperty(name = \"spring.cloud.nacos.config.enabled\", matchIfMissing = true)public class NacosConfigAutoConfiguration {}//即如果没有在配置文件中配置spring.cloud.nacos.config.enabled，则默认为条件满足。所以不配置，我们依旧启用了配置功能。 多环境profile管理profile粒度控制首先我们在Nocos控制页面配置两个不同环境的配置，如下： nacos-config-develop.yaml: 1current.env: develop-env nacos-config-product.yaml: 1current.env: product-env 修改主程序，增加读取环境类型的属性： 123456789101112public static void main(String[] args) throws InterruptedException { ConfigurableApplicationContext applicationContext = SpringApplication.run(NacosConfigSimpleApplication.class, args); //取到Spring的配置环境// while(true){ ConfigurableEnvironment environment = applicationContext.getEnvironment(); String username = environment.getProperty(\"user.name\"); String age = environment.getProperty(\"user.age\"); String env = environment.getProperty(\"current.env\"); System.out.println(\"username:\"+username+\" | age:\"+age +\" | env:\"+env); TimeUnit.SECONDS.sleep(1);// }} 然后在配置bootstrap.properties配置文件指定激活环境： 几种激活方式可以查看：https://blog.csdn.net/ooyhao/article/details/100939089#Profile_176 123456789spring.application.name=nacos-config# 配置文件的格式spring.cloud.nacos.config.file-extension=yaml# 禁用配置自动刷新功能#spring.cloud.nacos.config.refresh.enabled = false# 配置中心的地址:端口spring.cloud.nacos.config.server-addr=127.0.0.1:8848# 激活环境 *spring.profiles.active=develop 注意：${spring.profiles.active}当通过配置文件来指定的时候，必须放在bootstrap.properties文件中。 通过结果可以看出，读取到的配置有nacos-config.yaml和nacos-config-develop.yaml。 注意：此示例中我们通过spring.profile.active= &lt;profilename&gt; 的方式写死在配置文件中，而在真正的项目实施过程中，这个变量的值需要不同环境而有不同的值。这个时候通常的做法是通过 -Dspring.profiles.active=&lt;profile&gt; 参数指定其配置来达到环境间灵活的切换。 具体可以参考上述链接内容 总结：文件匹配规则如下（dataId），${spring.cloud.nacos.config.prefix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension} 我们可以看看源码： 加载配置源码分析NacosConfigProperties类 123456789101112131415161718192021@ConfigurationProperties(NacosConfigProperties.PREFIX)public class NacosConfigProperties { public static final String PREFIX = \"spring.cloud.nacos.config\"; private String serverAddr; private String encode; private String group = \"DEFAULT_GROUP\"; private String prefix; private String fileExtension = \"properties\"; private int timeout = 3000; private String endpoint; private String namespace; private String accessKey; private String secretKey; private String contextPath; private String clusterName; private String name; private String sharedDataids; private String refreshableDataids;} 上述删除了部分代码，但是我们可以看到，fileExtension的默认值是properties.所以，在前一节中，我们使用properties格式的配置文件时，是没有配置文件扩展类型的。 注意：上面的配置类中有prefix，并且按上述的文件匹配规则来看，我们应该加载不到nacos-config.yaml文件的，但是测试结果是加载到了这个文件，而我们并没有配置前缀，所以可以推断出，模式是使用spring.application 属性。 我们查看源码可以看到原因： NacosPropertySourceLocator类：我们粗略的看一下（源码恐怖，后续深入研究） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Order(0)public class NacosPropertySourceLocator implements PropertySourceLocator { private static final String NACOS_PROPERTY_SOURCE_NAME = \"NACOS\"; private static final String SEP1 = \"-\"; private static final String DOT = \".\"; private static final String SHARED_CONFIG_SEPARATOR_CHAR = \"[,]\"; //配置文件类型 private static final List&lt;String&gt; SUPPORT_FILE_EXTENSION = Arrays.asList(\"properties\",\"yaml\", \"yml\"); @Override public PropertySource&lt;?&gt; locate(Environment env) { //删除了部分无关内容 //spring.cloud.nacos.config.name String name = nacosConfigProperties.getName(); //spring.cloud.nacos.config.prefix String dataIdPrefix = nacosConfigProperties.getPrefix(); //如果没有配置prefix，则使用name属性作为prefix if (StringUtils.isEmpty(dataIdPrefix)) { dataIdPrefix = name; } //如果没有配置prefix,并且也没有配置name属性，则使用spring.application.name属性 //作为prefix的值 if (StringUtils.isEmpty(dataIdPrefix)) { dataIdPrefix = env.getProperty(\"spring.application.name\"); } CompositePropertySource composite = new CompositePropertySource( NACOS_PROPERTY_SOURCE_NAME); loadSharedConfiguration(composite); loadExtConfiguration(composite); //我们再看一下这个方法，如下 loadApplicationConfiguration(composite, dataIdPrefix, nacosConfigProperties, env); return composite; } private void loadApplicationConfiguration( CompositePropertySource compositePropertySource, String dataIdPrefix, NacosConfigProperties properties, Environment environment) { //spring.cloud.nacos.config.prefix String fileExtension = properties.getFileExtension(); //spring.cloud.nacos.config.group 默认DEFAULT_GROUP String nacosGroup = properties.getGroup(); //dataId=${prefix}-${profile}.${file-extension} // 上面的例子中的nacos-config.yaml loadNacosDataIfPresent(compositePropertySource, dataIdPrefix + DOT + fileExtension, nacosGroup, fileExtension, true); //加载激活了的profile的配置文件 // 上例中的nacos-config-develop.yaml for (String profile : environment.getActiveProfiles()) { String dataId = dataIdPrefix + SEP1 + profile + DOT + fileExtension; loadNacosDataIfPresent(compositePropertySource, dataId, nacosGroup, fileExtension, true); } }} 注意：通过上述代码分析，就知道为什么加载了nacos-config.yaml 和 nacos-config-develop.yaml. 多环境Group管理在没有自定义${spring.cloud.nacos.config.group} 配置的情况下，默认使用的是DEFAULT_GROUP, 如果需要自定义，可以通过下面的配置来实现： 1spring.cloud.nacos.config.group=DEVELOP_GROUP 注意：该配置必须放在bootstrap.properties文件中，并且在添加配置时的值一定要和spring.cloud.nacos.config.group 的属性值一致。 默认配置 Develop配置 测试结果123//: Loading nacos data, dataId: 'nacos-config.yaml', group: 'DEVELOP_GROUP'//: Loading nacos data, dataId: 'nacos-config-develop.yaml', group: 'DEVELOP_GROUP'username:欧阳 | age:23 | env:DEV 多环境namespace管理概述我们看一下官方时如何介绍namespace的： 用户进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的Group或Data ID的配置。Namespace的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。 在配置文件中没有自定义namespace的时候，模式使用的是Nacos上Public作为namespace，如果我们希望自定义，可以通过${spring.cloud.nacos.config.namespace} 来配置。 默认命名空间我们先看之前的默认namespace。 自定义命名空间1spring.cloud.nacos.config.namespace= dc7fb953-fab6-4f98-95b9-e777d02cd683 注意：这个配置必须放在bootstrap.properties文件中。并且spring.cloud.nacos.config.namespace 配置的是namespace Id。而不是命名空间名称。并且这个命名空间id是不用自己生成的，只要在Nacos新建一个命名空间，管理页面就会自动产生一个字符串。在配置文件中配置时要注意选择相应的namespace，否则会读不到正确的配置。 这里为了保证配置的干净，我新建一个项目来测试。 完整配置12345678# DataIdspring.application.name=nacos-config-namespace# groupspring.cloud.nacos.config.group=ouYangGroup# namespacespring.cloud.nacos.config.namespace=dc7fb953-fab6-4f98-95b9-e777d02cd683spring.cloud.nacos.config.file-extension=yamlspring.cloud.nacos.config.server-addr=192.168.1.104:8848 Nacos配置 测试结果主程序： 12345678910111213@SpringBootApplicationpublic class NacosConfigNamespaceApplication { public static void main(String[] args) { ConfigurableApplicationContext applicationContext = SpringApplication.run(NacosConfigNamespaceApplication.class, args); //环境 ConfigurableEnvironment environment = applicationContext.getEnvironment(); String username = environment.getProperty(\"user.username\"); String password = environment.getProperty(\"user.password\"); System.out.println(\"username:\"+username+\" | password:\"+password); }} 测试结果： 1username:admin | password:123456","link":"/2020/01/18/SSM/springcloudalibaba/7.Nacos%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E5%92%8C%E5%A4%9A%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/"},{"title":"十一、Nacos多配置加载和共享配置","text":"Nacos多配置加载和共享配置 中文文档：https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config 通过前两小节，我们已经掌握了Nacos作为分布式配置中心的基本功能，比如：配置读取，自动刷新，加载原则，多环境管理等。但是，在实际项目中，配置文件一般会安装实际业务进行拆分，所以会存在多个配置文件需要加载。当然，对于多个服务之间，可能会存在一些共享的配置，所以这一节我们了解一下多配置文件加载和配置共享。 多配置文件加载我们知道，配置文件的加载规则是由相面几个属性组合而成的： 12345spring.cloud.nacos.config.namespace= 默认:\"\"//空，此处填的是namespaceId,而不是名字publicspring.cloud.nacos.config.group= 默认：DEFAULT_GROUP# ${spring.cloud.nacos.config.prefix} &gt; ${spring.cloud.nacos.config.name} &gt; ${spring.application.name}spring.cloud.nacos.config.prefix= spring.cloud.nacos.config.file-extension= 默认 .properties 控制页面添加配置 具体配置如下： nacos-multi-config.yaml 12server: port: 8888 nacos-multi-config-discovery.yaml 12discovery: host: 127.0.0.1:8848 nacos-multi-config-log.yaml 12log: level: Info nacos-multi-config-db.yaml 1234567spring: datasource: username: root password: 123server: port: 7777 nacos-multi-config-redis.yaml 1234567redis: host: 127.0.0.1 username: amdin password: adminserver: port: 9999 bootstrap.properties123456789101112131415161718192021222324# 基础配置spring.application.name=nacos-multi-configspring.cloud.nacos.config.file-extension=yamlspring.cloud.nacos.config.server-addr=127.0.0.1:8848# spring.cloud.nacos.config.group=ouYangGroupspring.cloud.nacos.config.namespace=28dacdf7-263f-40af-9d31-592529746f6e# 多配置加载# 使用默认的 DEFAULT_GROUP,如果上面配置了，则按照上面配置的加载# 默认自动刷新spring.cloud.nacos.config.ext-config[0].data-id=nacos-multi-config-discovery.yaml# 不再默认的组，不会自动刷新spring.cloud.nacos.config.ext-config[1].data-id=nacos-multi-config-log.yamlspring.cloud.nacos.config.ext-config[1].group=ouYangGroup# 不再默认的组，手动启动自动刷新spring.cloud.nacos.config.ext-config[2].data-id=nacos-multi-config-db.yamlspring.cloud.nacos.config.ext-config[2].group=ouYangGroupspring.cloud.nacos.config.ext-config[2].refresh=true# 测试加载顺序spring.cloud.nacos.config.ext-config[3].data-id=nacos-multi-config-redis.yamlspring.cloud.nacos.config.ext-config[3].group=ouYangGroup 注意： 通过spring.cloud.nacos.config.ext-config[n].data-id的配置来配置多个DataId 的配置。 通过spring.cloud.nacos.config.ext-config[n].group 的配置来指定dataId所在的组，不明确指定的话使用默认的DEFAULT_GROUP 通过spring.cloud.nacos.config.ext-config[n].refresh 的配置来控制该dataId属性变更时，是否动态刷新加载，默认如果不在DEFAULT_GROUP，自动刷新是关闭的，可以通过置为true来手动开启。 测试结果 注意1: 多个DataId同时配置时，它的优先级关系是 spring.cloud.nacos.config.ext-config[n].data-id 的值越大，优先级越高，即先加载，所以可以通过结果看到server.port=8888.是因为先加载server.port=9999.再7777覆盖了9999，再8888覆盖了7777，所以最后的结果就是server.port=8888 . 注意2： spring.cloud.nacos.config.ext-config[n].data-id= 必须带上扩展名，即文件格式，支持properties，也支持yaml/yml. 此时spring.cloud.nacos.config.file-extension 的配置对自定义扩展的配置的data-id是无效的。 共享配置通过上述自定义扩展dataId，已经解决了多个应用之间配置贡献的问题，同时也支持一个应用有多个配置文件。 下面我可以通过这种简单方式来配置共享配置： 123# 共享配置spring.cloud.nacos.config.shared-dataids=common-log.yaml,common-redis.yamlspring.cloud.nacos.config.refreshable-dataids=common-log.yaml Nacos控制台 nacos-config-share.yaml 12server: port: 9999 common-log.yaml 12log: level: DEBUG common-redis.yaml 12345redis: host: 127.0.0.1 port: 6379log: level: Info 主程序测试主程序： 12345678910111213141516@SpringBootApplicationpublic class NacosConfigShareApplication { public static void main(String[] args) { ConfigurableApplicationContext applicationContext = SpringApplication.run(NacosConfigShareApplication.class, args); ConfigurableEnvironment environment = applicationContext.getEnvironment(); String port = environment.getProperty(\"server.port\"); String level = environment.getProperty(\"log.level\"); String redisHost = environment.getProperty(\"redis.host\"); String redisPort = environment.getProperty(\"redis.port\"); System.out.println(\"server.port:\"+port); System.out.println(\"log.level:\"+level); System.out.println(\"redis.host:\"+redisHost+\" | redis.port:\"+redisPort); }} 结果： 12server.port:9999log.level:Info 可以看出： 通过spring.cloud.nacos.config.share-dataids 来支持多个共享dataId的配置，多个配置文件之间用逗号隔开。 通过spring.cloud.nacos.config.refreshable-dataids 来支持哪些共享配置的Data Id在变化时，应用中是否动态刷新，能感知到最新的值，多个DataId之间用逗号隔开。如果没有明确指定的配置，默认情况下所共享的配置是不支持动态刷新。 注意： spring.cloud.nacos.config.share-dataids 的配置加载顺序是按照从左到右的，所以如果出现相同的配置时，后面的会覆盖前面的，如上述的log.level 使用spring.cloud.nacos.config.share-dataids 来配置共享配置时，需要加上后缀名，即properties,yaml/yml.此时的spring.cloud.nacos.config.file-extension 的配置对此项无效。 通过使用spring.cloud.nacos.config.refreshable-dataids 来指定哪些共享配置是需要支持自动刷新的。默认未指定的配置是不支持自动刷新的。同时也需要加上配置的后缀名 配置的优先级我们用下面的实例来测试优先级： spring cloud alibaba nacos config 目前提供了三种配置能力从Nacos拉取相关的配置。 A : 通过spring.cloud.nacos.config.shared-datadis 支持多个共享data id的配置。 B : 通过spring.cloud.nacos.config.ext-config[n].data-id 的方式支持多个扩展Data Id的配置。 C : 通过内部相关规则（应用名、应用名+profile）自动生成的DataId配置。 优先级：A &lt; B &lt; C 即，先读取C,再读取B，最后读取A。 nacos-config.yaml 12log: level: warning nacos-config-share.yaml 12log: level: error common.log.yaml 12log: level: DEBUG boostrap.properties文件 case one: 1234spring.cloud.nacos.config.file-extension=yamlspring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.config.shared-dataids=common-log.yamlspring.cloud.nacos.config.refreshable-dataids=common-log.yaml result: 1log.level:DEBUG case two: 123456spring.cloud.nacos.config.file-extension=yamlspring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.config.ext-config[0].data-id=nacos-config.yamlspring.cloud.nacos.config.ext-config[0].refresh=truespring.cloud.nacos.config.shared-dataids=common-log.yamlspring.cloud.nacos.config.refreshable-dataids=common-log.yaml result: 1log.level:warning case three: 12345678spring.application.name=nacos-share-configspring.cloud.nacos.config.prefix=nacos-config-sharespring.cloud.nacos.config.file-extension=yamlspring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.config.ext-config[0].data-id=nacos-config.yamlspring.cloud.nacos.config.ext-config[0].refresh=truespring.cloud.nacos.config.shared-dataids=common-log.yamlspring.cloud.nacos.config.refreshable-dataids=common-log.yaml result: 1log.level:error 完全关闭配置通过设置spring.cloud.nacos.config.enabled =false 来完全关闭Spring Cloud Nacos Config 配置功能。 完整配置参考 https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_more_information_about_nacos_config_starter_configurations","link":"/2020/01/18/SSM/springcloudalibaba/8.Nacos%E5%A4%9A%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE/"},{"title":"MySQL基础","text":"SQL笔记数据库相关概念 1.DB：数据库，保存一组有组织的数据的容器 2.DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 3.SQL：结构化查询语言，用于和DBMS通信的语言 基本SQL操作1.操作数据库123456-- 查询数据库show databases;-- 创建数据库create database newDatabase;-- 删除数据库drop database newDatabase; 2.操作数据表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081-- 选择指定数据库use testDB; -- 查询当前数据库下的全部数据表show tables;-- 创建表create table tb_user( id int(11) not null auto_increment primary key, name varchar(255) not null, age int(11));-- 创建表，存在则不会创建create table if not exists tb_user2( id int(11) not null auto_increment primary key, name varchar(255) not null, age int(11));-- 使用旧表创建新表(只复制表的结构，不复制表的数据)create table newTable like tb_user;-- 使用旧表（部分列）创建新的表(既复制表的结构又复制表的数据)create table newTables as select id,name,age,matching from tb_user;-- 使用就表创建新表（全部列，既复制表的结构又复制表的数据）create table newTable1 as select * from tb_user;-- 查询表的结构desc testAlter;show columns from testAlter;-- 将A表的查询结果插入到B表中。insert into tb_new_user select * from tb_user;-- 清除表中的数据-- 注意：删除表的所有行，但表的结构、列、约束、索引等不会被删除；不能用于有外建约束引用的表truncate table tb_new_user;-- 删除表如果存在drop table if exists tb_new_user2;-- 对数据表的列进行操作-- 对表的重命名alter table tb_user1 rename [TO] tb_new_user1;-- 增加列alter table tb_user add new_column varchar(255) comment '这是新增列';alter table tb_user add column new_column varchar(255) comment '这是新增列';alter table tb_user add column new_column varchar(255) not null comment '这是新增的非空列';alter table tb_user add column new_column int(11) not null default 0 comment '这是新增非空默认为0的列';-- 删除列alter table tb_user drop column newColumn;alter table tb_user drop newColumn;-- 修改列alter table tb_user change column new_column newColumn varchar(256) not null ;alter table tb_user change column new_column newColumn int(11) not null default 0 comment '修改列名';-- 添加主键Alter table tabname add primary key(col)-- 删除主键Alter table tabname drop primary key(col)-- 创建索引create [unique] index idxname on tabname(col….)-- 删除索引drop index idxname注：索引是不可更改的，想更改必须删除重新建。-- 创建视图create view viewname as select statement-- 删除视图drop view viewname选择：select * from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!排序：select * from table1 order by field1,field2 [desc]总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table1 3.select语句1.普通查询1234567-- 查询整张表的所有列select * from tb_user;-- 查询指定列select id, name from tb_user;select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc 2.distinct123-- 使用 distinict语句 (获得不同的值)（查询结果的所有列与别的记录）select distinct name,age from tb_user;select distinct name from tb_user; 3.where12-- where 子句 筛选select * from tb_user where id = 1; 4.order by123456-- 按id降序select * from tb_user order by id desc;-- 按id升序select * from tb_user order by id asc;-- 多条件排序select * from tb_user order by name,age asc; 5.and , or1234-- and 子句select * from tb_user where name = 'yanghao' and age = 21;-- or 子句select * from tb_user where name = 'yanghao1' or age = 21; 6.like12345678-- like 子句 模糊查询select * from tb_user where name like '%hao';select * from tb_user where name like 'yang%';select * from tb_user where name like '%yang%';-- ％ - 百分号表示零个，一个或多个字符-- _ - 下划线表示单个字符select * from tb_user where name like 'yanghao_'; 7.between and1234-- BETWEEN运算符是包含性的：包括开始和结束值。-- between andselect * from tb_user where id between 1 and 2;select * from tb_user where id not between 1 and 2; 8.null123-- is null ，is not null select * from tb_user where matching is null;select * from tb_user where matching is not null; 9.limit1234-- limit select * from tb_user limit 2;-- 去下标为1的开始，2条。注意与between and 进行区分select * from tb_user limit 1,2; 10.in12345678910111213-- IN 运算符select * from tb_user where id in (1,2,3);select * from tb_user where name in ('yanghao', 'lisi');-- 利用子查询的结果作为in的元素SELECT * FROM tb_user WHERE NAME IN ( SELECT NAME FROM tb_user WHERE id IN ( 2, 3 ) ); select * from tb_user; 11.case12345678-- switch（case） 语句 SELECT id, NAME, age, (CASE matching WHEN 0 THEN '零' WHEN 1 THEN '壹' WHEN 2 THEN '贰' end) AS numberFROM tb_user; 12.if1234select if(true,'yes','no') as status;-- if 函数select id,name,age,matching , if(sex = 'w','女','男') as '姓别' from tb_user; 12.group by12345-- group byselect sex, count(sex) count from tb_user group by sex;select name, count(*) count from tb_user group by name;select name,age,count(*) count from tb_user group by name,age; 13.union1234-- 并集，将多个结果连接起来select * from tb_user where name like '%hao%'unionselect * from tb_user where age = 18; 4.insert语句1234-- insert插入语句-- (两种，一种是插入全部字段，则可以简化为如下)insert into tb_user values(6,'zhangsan',18,1,1);insert into tb_user (name,age,matching, newColumn) values( 'zhangsan',20,1,1); 5.update语句12-- update 更新语句update tb_user set name = 'lisi' where id = 4; 6.delete语句12-- delete 删除语句delete from tb_user where id = 5; 7.函数12345678910-- 个数select count(*) as totalCount from tb_user;-- 总和select sum(age) as totalAge from tb_user;-- 平均值select avg(age) as avgAge from tb_user;-- 最大select max(age) as maxAge from tb_user;-- 最小select min(age) as minAge from tb_user; 8.事务123456789101112131415161718create table runoob_transaction_test ( id int(5)) engine = innodb; # 创建数据库select * from runoob_transaction_test;begin;insert into runoob_transaction_test (id) values (5);insert into runoob_transaction_test (id) values (6);commit;select * from runoob_transaction_test;begin;insert into runoob_transaction_test (id) values (7);rollback;select * from runoob_transaction_test;commit; SQL 连接(JOIN)1234INNER JOIN：如果表中有至少一个匹配，则返回行LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行FULL JOIN：只要其中一个表中存在匹配，则返回行 0.Sql 之 笛卡尔积注释：INNER JOIN 与 JOIN 是相同的。 数据库表： 首先，我们需要先明白一个概念——笛卡尔积： 1234567891011笛卡尔积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。例子：假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0),(a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。 现在来观察上面两个表形成的笛卡尔积： 1.Sql 之 inner join注释：INNER JOIN 与 JOIN 是相同的。（相当于取交集） 注释：INNER JOIN 关键字在表中存在至少一个匹配时返回行。 SQL join 用于把来自两个或多个表的行结合起来。 最简单的就是内连接，inner join. 12345678910111213-- 使用where连接SELECT p.id, p.NAME, pd.id AS _id, pd.pid, pd.price, pd.num FROM product p, product_detail pd WHERE p.id = pd.pid; 123456789101112-- inner join or join SELECT p.id, p.NAME, pd.id AS _id, pd.pid, pd.price, pd.num from product p INNER join product_detail pd on p.id = pd.pid; 以上两种方式查询的结果是一样的。（两个都相当于内连接） 总结：内连接inner join是将两个或两个以上的表连接起来，用on来连接，只用当on所限制的条件满足的时候，笛卡尔积组成的结果行才会返回。 如下图：(只有on后面的条件，p.id = pd.pid成立的时候) 2.Sql 之 left join | left outer join 注释：LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配。 123456789101112-- left join or left outer join SELECT p.id, p.NAME, pd.id AS _id, pd.pid, pd.price, pd.num from product p left join product_detail pd on p.id = pd.pid; 在左连接的基础上加上过滤条件 12345678910SELECT p.id, p.NAME, pd.id AS _id, pd.pid, pd.price, pd.num from product p left join product_detail pd on p.id = pd.pid and p.id = 1 使用where进行过滤的 注意：在使用 left jion 时，on 和 where 条件的区别如下： 1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。 2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 3.Sql 之 right join | right outer join注释：RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 12345678910select p.id,p.name,pd.id as _id,pd.pid,pd.price,pd.numfrom product pright join product_detail pdon p.id = pd.pid 加入过滤条件的有连接 on 后面接and进行过滤 1234567891011select p.id,p.name,pd.id as _id,pd.pid,pd.price,pd.numfrom product pright join product_detail pdon p.id = pd.pidand pd.pid = 1 123456789101112select p.id,p.name,pd.id as _id,pd.pid,pd.price,pd.numfrom product pright join product_detail pdon p.id = pd.pid-- and pd.pid = 1where pd.pid = 1 使用on过滤和where过滤跟上面的左连接是一样的。 4.Sql 之 full join | full outer join注释：FULL OUTER JOIN 关键字返回左表（Websites）和右表（access_log）中所有的行 （使用方式如上面两种那样，但是mysql不支持全连接） 5.Sql 之 union and union all但是可以使用union关键字来实现所谓的全连接 1234567891011121314151617181920212223242526SELECT p.id, p.NAME, pd.id AS _id, pd.pid, pd.price, pd.num FROM product as p left JOIN product_detail pd ON p.id = pd.pid UNION SELECT p.id, p.NAME, pd.id AS _id, pd.pid, pd.price, pd.num FROM product p right join product_detail pd on p.id = pd.pid; 上面是使用的是union，不显示重复行，但是如果把union换成union all 那么就会把重复行显示出来， 效果如下图：（union all） 6.Sql 之 natural join12345SELECT * FROM product NATURAL JOIN product_detail 注释：自然连接默认是匹配两个表列名相同的，然后不重复显示。 如下图，将数据库表设计改变：（改变第一个表的id名为pid） 结果如下：","link":"/2020/01/29/db/mysql/MySQL%E5%9F%BA%E7%A1%80/"},{"title":"11.Redis之RDB持久化方式","text":"Redis之RDB持久化方式 ​ Redis 相对于 Memcache 等其他的缓存产品，有一个比较明显的优势就是 Redis 不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储, Redis 的另外一大优势——持久化。​ 由于 Redis 是一个内存数据库。所谓内存数据库，就是将数据库中的内容保存在内存中，这与传统的MySQL，Oracle等关系型数据库直接将内容保存到硬盘中相比，内存数据库的读写效率比传统数据库要快的多（内存的读写效率远远大于硬盘的读写效率）。但是保存在内存中也随之带来了一个缺点，一旦断电或者宕机，那么内存数据库中的数据将会全部丢失。 为了解决这个缺点，Redis提供了将内存数据持久化到硬盘，以及用持久化文件来恢复数据库数据的功能。Redis 支持两种形式的持久化，一种是RDB快照（snapshotting），另外一种是AOF（append-only-file） 持久化简单理解就是将内存的数据移动到硬盘中，它的存在是防止电脑突然断电或者故障时数据的丢失。持久化到硬盘中后，只要硬盘不坏，下次启动的时候就可以再次将持久化到硬盘的数据快速的加载到内存中去。当然为了防止硬盘的坏掉，也有另外一种技术来支持这种容错性，那就是主从复制。RDB &amp; AOF介绍 1.RDB(默认) redis database 在指定时间间隔内，将内存中的数据作为一个快照文件(snapshot)写入到磁盘，读取的时候也是直接读取snapshot文 件到内存。 2.AOF Append Only File以日志形式记录每个写操作，启动时通过日志恢复数据。 RDB配置持久化时间策略123save 900 1save 300 10save 60 10000 说明：若不想用RDB方案，可以把 save &quot;&quot; 的注释打开，上面三个注释掉 ​ RDB 核心规则配置 save &lt;指定时间间隔&gt;&lt;执行指定次数更新操作&gt;，满足条件就将内存中的数据同步到硬盘中去。官方出厂配置默认是 900秒内有一个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。 配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。 ​ save: 这里是用来配置出发redis的RDB持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如save m n。表示m秒内数据集存在n次修改时，自动触发。bgsave（手动触发RDB持久化命令）。默认配置如下： save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存 save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存 save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存 当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的save行来停用保存功能。当然，也可以在save的最后一行写上：save “” 那么为什么需要配置这么多条规则呢？ ​ 因为Redis每个时段的读写请求肯定是不均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下出发备份。所以这里就是根据自身redis写入情况来进行合理配置。 出错是否继续写1stop-writes-on-bgsave-error yes 说明：默认值为yes。 ​ 默认情况下，如果RDB 快照被启用并且最后一个后台保存失败，redis将会停止接收写操作。这将使得用户很难意识到数据不会准确的持久化到硬盘中，另外将没有人会注意到一些灾难性的事情会发生。如果后台保存进程重新开始工作，将会自动允许写入。然而，如果你为redis服务和持久化有启用合适的监控，你可能希望禁用这个特征，以至于redis可以继续像往常一样的工作，即便是硬盘存在一些问题，权限等。 是否压缩文件1rdbcompression yes 说明：默认值为yes。 ​ 配置存储至本地数据库时是否压缩数据，默认为yes，redis采用LZF压缩方式，但会占用一点CPU的时间。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。关于压缩的配置rdbcompression yes,建议没有必须开启，毕竟redis本身就属于CPU密集型服务器，再开启压缩会带来更加多的CPU消耗，相比硬盘成本，CPU更值钱。 是否检验文件1rdbchecksum yes 说明：默认值是yes。 ​ 是否检验rdb文件；从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC的检验和。这更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭这个配置。 快照文件名1dbfilename dump.rdb 说明：指定保存RDB快照的文件名 工作目录注意：这里必须指明的是一个目录，不能是文件名 1dir ./ 说明：工作目录；默认是和当前配置文件保存在同一目录。也就是说通过此配置文件中的save方式，当实际操作满足该配置形式时就会进行RDB持久化，将当前的存储快照保存在dir配置的目录中，文件名有dbfilename决定。 手动触发手动触发Redis进行RDB持久化的命令有两种： save该命令会阻塞当前redis服务器，执行save命令期间，Redis不能处理其他命令，知道RDB过程完成为止。虽然该命令对于内存比较大的实例会造成长时间的阻塞，这是致命的缺陷，为了解决此问题，Redis提供了第二种方式。 bgsave执行该命令时，redis会在后台异步进行快照操作，快照的同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上Redis内部所有的RDB操作都是采用bgsave命令。 ps: 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。 恢复数据将备份文件(dump.rdb)移动到redis安装目录并启动服务即可，redis就会自动加载文件数据到内存中了。Redis服务器在载入RDB文件期间，会一直处于阻塞状态，知道载入工作完成为止。获取redis的安装路径可以使用config get dir命令。 停止RDB持久化有些情况下，我们只想要利用Redis的缓存功能，并不想使用Redis的持久化功能，那么这时候我们最好停掉RDB持久化。可以通过上面讲的在配置文件redis.conf中，注释掉所有的save行来停用保存功能，或者直接一个空字符串来实现停用：save &quot;&quot;也可以通过命令： redis-cli config set save &quot;&quot; . 优势与劣势 优势 RDB是一个非常紧凑（compact）的文件，它保存了redis在某一个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。 生成RDB文件的时候，Redis主进程会fork()一个子进程来处理所有的保存工作，主进程不需要进行任何磁盘IO操作。 RDB在恢复大数据集时的速度比AOF的恢复速度要快。 劣势 RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行成本过高（影响性能）。 RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题（版本不兼容）。 在一定间隔时间做一个备份，所以如果redis意外down掉的话，就会丢失最后一次快照的所有修改（数据有丢失）. 部分参考： https://www.cnblogs.com/ysocean/p/9074787.html https://blog.csdn.net/suprezheng/article/details/90679790 博主：YSOceanRDB持久化方式：https://www.cnblogs.com/ysocean/p/9114268.htmlAOF持久化方式：https://www.cnblogs.com/ysocean/p/9114267.html博主：阿飞云RDB:https://blog.csdn.net/u010648555/article/details/73433717AOF:https://blog.csdn.net/u010648555/article/details/73442336","link":"/2020/02/22/db/redis/11.redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B9%8BRDB/"},{"title":"12.Redis 之 AOF持久化方式","text":"Redis 之 AOF持久化方式 AOF简介​ Redis的持久化方式之一RDB是通过保存数据库的键值对数据来记录数据库的状态。而另一种持久化策略AOF就是通过保存Redis服务器所执行的命令来记录数据库状态的。 比如执行如下命令： 12345127.0.0.1:6379&gt; set str1 \"123\"OK127.0.0.1:6379&gt; sadd str2 \"a\" \"b\" \"c\"(integer) 3127.0.0.1:6379&gt; RDB持久化方式就是将 str1 和 str2 这两个键值对保存在RDB文件中，而AOF持久化则是将执行的 set和 sadd两个命令保存在AOF文件中。 AOF配置信息下面我们看一下【redis.conf】配置文件中关于AOF的配置信息。 开启AOF1appendonly no 说明：是否开启AOF持久化方式。no 不开启。yes开启。默认是不开启的，即：redis默认采用RDB方式持久化。 解释： ​ redis的AOF持久化方式默认是不开启的，它的出现是为了弥补RDB的不足（数据不一致），所以它采用日志的形式来记录每个写操作，并追加到文件中。redis重启会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 ​ 默认redis使用的是RDB方式持久化，这种方式在需要应用中就已经足够用了。但是redis如果中途宕机，会导致可能几分钟的数据丢失（根据save策略进行持久化）。Append Only File是另一种持久化方式，可以提供更好的持久化特征。redis会把每次写入的数据在接收后都写入【appendonly.aof】文件，如果AOF方式开启了。每次启动时redis都会先把这个文件的数据读入内存里，先忽略RDB文件。 注意：RDB和AOF可以同时开启，不会出现问题。redis会优先加载AOF，此时AOF是一种更好的持久化保证。 AOF文件名1appendfilename \"appendonly.aof\" 说明：指定AOF日志文件的文件名，默认使用”appendonly.aof” 文件位置AOF保存文件的位置和RDB保存文件的位置一样，都是通过【redis.conf】配置文件的【dir】来配置。 可以通过命令【config get dir】来获取保存路径，如下： AOF持久化策略​ 同步方法的调用，告诉操作系统去真正的写数据到硬盘中，而不是等待更多的数据在输出缓存区。一些系统会真正的刷新数据到硬盘，而另一些则是尝试尽可能快的去执行。 123# appendfsync alwaysappendfsync everysec# appendfsync no 说明：指定AOF持久化模式。 no: 不同步，仅仅让操作系统在需要的时候刷新数据，速度最快。 always：在每次写入后都同步；慢，但是最安全。 everysec：每一秒同步一次，在速度和安全方面都适中。可能丢失一秒的数据。 解释： ​ 默认的同步模式就是”everysec”，这种在速度和数据安全方面中达到一个适中。这取决于你的理解，如果你可以允许放置no来让操作系统在需要的时候去刷新到输出缓存中，也许更好的方式就是RDB。（如果你可以忍受丢失一些数据，可以使用默认的持久化方式–快照）。相反的话，可以使用一个很慢的但是比everysec更加的方式–always。 注意：如果不确定使用哪种方式，那就使用everysec 重写时是否同步1no-appendfsync-on-rewrite no 解释：fsync(同步) 。no-appendfsyc-on-rewrite 字段默认设置为no。 ​ 在AOF重写或是写入RDB文件的时候，会执行大量的IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间。 ​ 如果对延迟要求很高的应用，这个字段可以设置为yes,否则设置为no，这样对持久化特性来说这是更加安全的选择。设置为yes表示rewrite期间对新写的操作不fsync，暂时存在内存中，等rewrite完成后再写入。默认为no，建议为yes。Linux的默认fsync策略是30秒，可能丢失30秒数据。 重写配置12auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 解释： auto-aof-rewrite-percentage aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当AOF文件增加到一定的大小的时候，redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写的AOF文件大小的2倍（设置为100）时，自动启动新的日志重写进程。 auto-aof-rewrite-min-size 设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸依然很小的情况还要重写. 截断导入1aof-load-truncated yes 解释： ​ AOF文件可能在尾部不完整的,当redis启动的时候,aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后,尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象）。出现这种情况，可以选择让redis退出，或者导入尽可能多的数据。如果选择yes，当截断的aof文件被导入的时候，会发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。 混合持久化 部分参考：https://www.cnblogs.com/xiaoqiang-code/p/11748395.html ​ 重启redis恢复数据集时，很少会使用RDB来恢复内存状态，因为会丢失大量数据。通常会使用AOF日志恢复数据，但是重放AOF日志性能相对于RDB来说要慢得多，这样在Redis实例很大的情况下，启动需要花费很长时间。Redis4.0为了解决这个问题，带来了新的持久化选项—混合持久化。 1aof-use-rdb-preamble yes 说明： ​ 如果开启了混合持久化，aof在重写时，不再是单纯将内存数据转换为RESP命令写入aof文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的aof修改内存数据的命令存在一起，都写入新的AOF文件，新的AOF文件一开始不叫appendonly.aof,等到重写完成之后，新的aof文件才会进行改名，原子的覆盖原有的aof文件，完成新旧两个aof文件的替换。于是在redis重启的时候，可以先加载rdb文件，然后再重放增量的aof日志就可以完全替代之前的aof全量文件重放，因此重启效率大幅得到提高。 数据修复将appendonly设置为yes，重启redis之后就会进行AOF文件的载入。若AOF文件有损坏，例如由于某些原因，里面有些命令变成乱码。此时redis还可以重新启动吗？ ​ 在AOF文件随便加一些字符，保存后重连redis。可发行此时redis无法在重新启动。那么此时如何恢复数据呢？在redis的文件目录下有一个叫redis-check-aof的工具。使用如下命令可修复AOF文件： 1redis-check-aof.exe --fix appendonly.aof 上述命令会清除所有不符合语法的命令。 从上图可以看出，AOF文件是不正常的文件。 当启动redis的时候，会提醒用户进行修复： 使用 redis-check-aof --fix filename 命令修复 这样就可以正常启动了 AOF重写​ 由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof 来重写。 比如对于如下命令： 如果不进行 AOF 文件重写，那么 AOF 文件将保存四条 SADD 命令，如果使用AOF 重写，那么AOF 文件中将只会保留下面一条命令： 1sadd animals \"cat\" \"dog\" \"tiger\" \"panda\" \"lion\" \"pig\" 也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。 AOF 文件重写触发机制： 通过 redis.conf 配置文件中的 auto-aof-rewrite-percentage：默认值为100，以及auto-aof-rewrite-min-size：64mb 配置，也就是说默认Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。 这里再提一下，我们知道 Redis 是单线程工作，如果重写 AOF 需要比较长的时间，那么在重写 AOF 期间，Redis将长时间无法处理其他的命令，这显然是不能忍受的。Redis为了克服这个问题，解决办法是将 AOF 重写程序放到子程序中进行，这样有两个好处： 子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其他命令。 子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。 使用子进程解决了上面的问题，但是新问题也产生了：因为子进程在进行 AOF 重写期间，服务器进程依然在处理其它命令，这新的命令有可能也对数据库进行了修改操作，使得当前数据库状态和重写后的 AOF 文件状态不一致。 为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。这样将 AOF 重写对服务器造成的影响降到了最低。 AOF的优缺点 优点 AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。 AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。 AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。 缺点 对于具有相同数据的的 Redis，AOF 文件通常会比 RDB 文件体积更大。 虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。 RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。 最佳实践 参考：http://www.javaboy.org/2019/0615/redis-aof.html 如果redis只做缓存服务器，那么可以不使用任何持久化方式。 同时开启两种持久化方式，在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下，AOF文件保存的数据集要比RDB文件保存的数据集要完整。RDB的数据不完整时，同时使用两者时服务器重启也只会找AOF。那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在bug，留着做万一的手段。 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1 这一条规则。 如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设置到5G以上。默认超过原大小100%大小时重写可以改到适当的数据。 如果不Enable AOF，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO，也减少了rewrite 时带来的系统波动。代价是如果Master/Slave 同时宕掉，会丢失十几分钟的数据，启动脚本必要比较两个Master/Slave 中的RDB文件，载入较新的那个。 那么对于 AOF 和 RDB 两种持久化方式，我们应该如何选择呢？ 如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，而且使用 RDB 还可以避免 AOF 一些隐藏的 bug；否则就使用 AOF 重写。","link":"/2020/02/22/db/redis/12.redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B9%8BAOF/"},{"title":"13.Redis主从复制和哨兵模式","text":"主从复制和哨兵模式 主从复制主从复制介绍前面介绍Redis，我们都是在一台服务器上进行操作的，也就是说读和写以及备份操作都是在一台Redis服务器上进行的，那么随着项目访问量的增加，对Redis服务器的操作也越加频繁，虽然Redis读写速度都很快，但是一定程度上也会造成一定的延时，那么为了解决访问量大的问题，通常会采取的一种方式是主从架构Master/Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机 Slave 节点。接下来我们就来介绍如何进行主从架构的搭建。 PS:这里我是在一台机器上模拟多个Redis服务器，与实际生产环境中相比，基本配置都是一样，仅仅是IP地址和端口号变化。 搭建环境复制Redis将解压编译好的redis复制三份，并且重命名为 redis6379 redis6380 和 redis6381. 123[root@localhost ooyhao]# cp -r redis-5.0.7 redis6379[root@localhost ooyhao]# cp -r redis-5.0.7 redis6380[root@localhost ooyhao]# cp -r redis-5.0.7 redis6381 当然，我们也可以只将配置文件复制三份。可以起到同样的效果。 修改配置文件将前面复制的三份redis文件进行配置文件【redis.conf】的修改。 修改为后台启动运行 123456################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.、# daemonize nodaemonize yes 表示修改redis以守护线程的方式启动（后台启动） 配置PID文件路径pidfile 12345678910# If a pid file is specified, Redis writes it where specified at startup# and removes it at exit.## When the server runs non daemonized, no pid file is created if none is# specified in the configuration. When the server is daemonized, the pid file# is used even if not specified, defaulting to \"/var/run/redis.pid\".## Creating a pid file is best effort: if Redis is not able to create it# nothing bad happens, the server will start and run normally.pidfile /var/run/redis_6379.pid 表示当redis作为守护线程运行的时候，它会把pid默认写到 /var/run/redis_6379.pid 文件中。 配置端口号port 123# Accept connections on the specified port, default is 6379 (IANA #815344).# If port 0 is specified Redis will not listen on a TCP socket.port 6379 配置log文件名 1234# Specify the log file name. Also the empty string can be used to force# Redis to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile \"6379.log\" 配置RDB文件名 12# The filename where to dump the DBdbfilename dump_6379.rdb 按照上面的方式配置redis6380和redis6381。只需要将相应的6379改为6380或6381即可。 启动服务 从上图可以看出，我们的三个redis服务已经正常启动。分别监听的端口是6379,6380和6381。 启动客户端123[root@localhost src]# ./redis-cli -p 6379[root@localhost src]# ./redis-cli -p 6380[root@localhost src]# ./redis-cli -p 6381 利用上述命令，以启动三个不同的客户端，用来监听不同端口的服务。 配置主从关系 通过命令查询当前节点的角色 1info / info replication 此时在三个不同的客户端执行info replication命令，可以看到三个节点的角色(role)都是master。那么如何将6380和6381设置为6379的从节点(slave)呢？ 配置主从关系 在6380和6381客户端，执行命令slaveof 127.0.0.1 6379 12127.0.0.1:6380&gt; slaveof 127.0.0.1 6379OK 此时我们再次使用info replication 命令查询三个节点的角色状态： 6379： 6380: 6381: 通过上述截图信息，可以看出此时主节点为 127.0.0.1 6379, 而从节点为127.0.0.1 6380 和 127.0.0.1 6381 。但是，通过命令设置的主从关系，一旦服务重启，那么角色关系就不复存在了。想要永久的保存这种关系。可以通过配置配置文件【redis.conf】来实现。如下： 1234567891011121314151617181920212223################################# REPLICATION ################################## Master-Replica replication. Use replicaof to make a Redis instance a copy of# another Redis server. A few things to understand ASAP about Redis replication.## +------------------+ +---------------+# | Master | ---&gt; | Replica |# | (receive writes) | | (exact copy) |# +------------------+ +---------------+## 1) Redis replication is asynchronous, but you can configure a master to# stop accepting writes if it appears to be not connected with at least# a given number of replicas.# 2) Redis replicas are able to perform a partial resynchronization with the# master if the replication link is lost for a relatively small amount of# time. You may want to configure the replication backlog size (see the next# sections of this file) with a sensible value depending on your needs.# 3) Replication is automatic and does not need user intervention. After a# network partition replicas automatically try to reconnect to masters# and resynchronize with them.## replicaof &lt;masterip&gt; &lt;masterport&gt;replicaof 127.0.0.1 6379 修改配置文件后，分别重启三个服务。执行info replication命令后，就可以看到效果了，并且这种方式不会因为服务重启而丢失主从关系。 测试主从复制关系增量复制主节点执行命令set username ooyhao ，从节点是否可以获取到信息呢？ 答案：肯定可以的。测试如下： 主节点执行set命令： 从节点获取keys： 全量复制通过执行slaveof 127.0.0.1 6379 ，如果主节点6379以前还存在以下key-value数据。那么在执行命令之后，从节点是否可以将主节点的旧信息复制过来呢？ 答案：可以的。测试过，不再截图。 主从读写分离主节点可以执行写的命令，那么从节点是否可以执行写的命令呢？ 答案：从节点默认情况下是不可以写入的，因为配置文件中配置了 replica-read-only 配置文件： 123456789101112131415# You can configure a replica instance to accept writes or not. Writing against# a replica instance may be useful to store some ephemeral data (because data# written on a replica will be easily deleted after resync with the master) but# may also cause problems if clients are writing to it because of a# misconfiguration.## Since Redis 2.6 by default replicas are read-only.## Note: read only replicas are not designed to be exposed to untrusted clients# on the internet. It's just a protection layer against misuse of the instance.# Still a read only replica exports by default all the administrative commands# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve# security of read only replicas using 'rename-command' to shadow all the# administrative / dangerous commands.replica-read-only yes 如果将其修改为no。从节点是可以写入数据的。 注意：即使是从节点的replica-read-only修改为no，从节点写入的数据，主节点也是同步不到的。如图 从节点写入数据： 主节点读取数据： 可以看出，即使我们将配置文件中的replica-read-only设置为no，从节点可以写入数据，但是主节点也是同步不到的。 主节点宕机主节点Master宕机之后，两个节点的角色会发生变化吗？ 答案：主节点挂掉之后，从节点的角色依旧不会发生变化。 主节点宕机后恢复主节点宕机之后，马上启动主节点master。主节点是否还继续扮演master角色呢？ 答案：主节点恢复之后，又恢复其主节点master角色。 复制原理Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作。 旧版同步(旧数据同步) 当从节点发出 slaveof 命令，要求从服务器复制主服务器时，从服务器通过向主服务器发送 sync 命令来完成。该命令执行步骤： 从服务器向主服务器发送 sync 命令 收到 sync 命令的主服务器执行 bgsave 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从开始执行的所有写命令 当主服务器的 bgsave 命令执行完毕时，主服务器会将 bgsave 命令生成的 RDB 文件发送给从服务器，从服务器接收此 RDB 文件，并将服务器状态更新为RDB文件记录的状态。 主服务器将缓冲区的所有写命令也发送给从服务器，从服务器执行相应命令。 命令传播 当同步操作完成之后，主服务器会进行相应的修改命令，这时候从服务器和主服务器状态就会不一致。为了让主服务器和从服务器保持状态一致，主服务器需要对从服务器执行命令传播操作，主服务器会将自己的写命令发送给从服务器执行。从服务器执行相应的命令之后，主从服务器状态继续保持一致。 总结：通过同步操作以及命令传播功能，能够很好的保证了主从一致的特性。 但是我们考虑一个问题，如果从服务器在同步主服务器期间，突然断开了连接，而这时候主服务器进行了一些写操作，这时候从服务器恢复连接，如果我们在进行同步，那么就必须将主服务器重新生成一个RDB文件，然后给从服务器加载，这样虽然能够保证一致性，但是其实断开连接之前主从服务器状态是保持一致的，不一致的是从服务器断开连接，而主服务器执行了一些写命令，那么从服务器恢复连接后能不能只要断开连接的哪些写命令，而不是整个RDB快照呢？ 同步操作其实是一个非常耗时的操作，主服务器需要先通过bgsave 命令来生成一个 RDB 文件，然后需要将该文件发送给从服务器，从服务器接收该文件之后，接着加载该文件，并且加载期间，从服务器是无法处理其他命令的。 为了解决这个问题，Redis从2.8版本之后，使用了新的同步命令 psync 来代替 sync 命令。该命令的部分重同步功能用于处理断线后重复制的效率问题。也就是说当从服务器在断线后重新连接主服务器时，主服务器只将断开连接后执行的写命令发送给从服务器，从服务器只需要接收并执行这些写命令即可保持主从一致。 主从复制的缺点 主从复制虽然解决了主节点的单点故障问题，但是由于所有的写操作都是在 Master 节点上操作，然后同步到 Slave 节点，那么同步就会有一定的延时，当系统很繁忙的时候，延时问题就会更加严重，而且会随着从节点slave的增多而愈加严重。因此我们还需要集群来进一步提升 redis 性能。 哨兵模式哨兵模式介绍通过前面的配置，主节点Master 只有一个，一旦主节点挂掉之后，从节点没法担起主节点的任务，那么整个系统也无法运行。如果主节点挂掉之后，从节点能够自动变成主节点，那么问题就解决了，于是哨兵模式诞生了。哨兵模式就是不时地监控redis是否按照预期良好地运行（至少是保证主节点是存在的），若一台主机出现问题时，哨兵会自动将该主机下的某一个从机设置为新的主机，并让其他从机和新主机建立主从关系。 环境搭建修改配置文件配置文件是【sentinel.conf】，如果没有，则需要创建。注意：名字不能出错。 sentinel monitor 被监控机器的名字 ip port 得票数 12345678910111213141516171819# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;## Tells Sentinel to monitor this master, and to consider it in O_DOWN# (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.## Note that whatever is the ODOWN quorum, a Sentinel will require to# be elected by the majority of the known Sentinels in order to# start a failover, so no failover can be performed in minority.## Replicas are auto-discovered, so you don't need to specify replicas in# any way. Sentinel itself will rewrite this configuration file adding# the replicas using additional configuration options.# Also note that the configuration file is rewritten when a# replica is promoted to master.## Note: master name should not include special characters or spaces.# The valid charset is A-z 0-9 and the three characters \".-_\".# sentinel monitor mymaster 127.0.0.1 6379 2sentinel monitor mymaster 127.0.0.1 6379 1 分别配置【被监控机器的名字】，【IP地址】，【端口port】，【得票数】。 解释：sentinel 监控的master名字叫做mymaster，2 代表，当集群中有2个sentinel认为master挂了，才能真正认为该master已经不可用了。 但是测试时，只有一个哨兵sentinel。所以，这里设置为1. 启动哨兵使用./redis-sentinel ./sentinel.conf 命令来启动哨兵。启动效果如下： 接下来，我们关闭主机6379，看各节点之间的主从关系变化。 redis后台服务器的开启命令：./redis-server redis.conf (在redis-server redis.conf安装目录下运行) redis后台服务器的关闭命令：./redis-cli shutdown (同上) 12345678910111213127.0.0.1:6381&gt; info replication# Replicationrole:masterconnected_slaves:1slave0:ip=127.0.0.1,port=6380,state=online,offset=10056,lag=0master_replid:07d2f9797241c511275d4bf769be1c04dab5bea6master_replid2:7374d6fb11b97935b7ed4b7821fd8cc6e1125c9amaster_repl_offset:10056second_repl_offset:8410repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:10056 通过日志可以看出，6379挂掉之后，redis内部进行了重新选举，6381上位成为master节点。即使6379重启之后，也只能是slave节点，无法直接成为master节点。 注意：哨兵模式也存在单点故障的问题，如果哨兵机器挂掉了，那么就无法进行监控了，解决办法就是哨兵也建立集群，redis哨兵模式也支持集群的。","link":"/2020/02/23/db/redis/13.redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"},{"title":"8.redis 数据类型之zset","text":"redis 数据类型之zset zset简介有序集合和集合一样，也是string类型元素的集合，且不允许重复的成员。不同的是每一个元素都会关联一个double类型的分数。redis正式通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的，但分数(score)是可以相同的。集合是通过哈希表是实现的，所以添加，删除，查找的复杂度都是O(1).集合中的最大成员数为2^32-1 (4294967295,每个集合可存储40多亿个成员)。 命令集合zaddZADD key score1 member1 [score2 member2] 注意：在redis2.4之前，zadd一次只能添加一个元素。 zadd 命令用于将一个或多个成员元素及其分数值加入到有序集合中。如果当某一个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。 如果有序集合key不存在，则会创建一个空的有序集并执行zadd命令操作。当key存在但是不是有序集类型时，返回一个错误。 1234127.0.0.1:6379&gt; zadd chengji 98 zhangsan(integer) 1127.0.0.1:6379&gt; zadd chengji 99 lisi 97 wangwu 100 ooyhao(integer) 3 zcardZCARD key zcard 命令用于计算集合中元素的数量。 12127.0.0.1:6379&gt; zcard chengji(integer) 4 zcountZCOUNT key min max zcount 命令用于计算有序集合中指定分数区间的成员数量。 12127.0.0.1:6379&gt; zcount chengji 97 99(integer) 3 zincrbyZINCRBY key increment member zincrby 命令对有序集合中指定成员的分数加上增量increment。可以通过传递一个负数值increment。让分数减去相应的数值。 当key不存在，或者分数不是key的成员时。zincrby key increment member 等同于 zadd key increment member. 当key不是有序集合类型是，返回一个错误。 分数值可以是整数值或是双精度浮点值。 123456127.0.0.1:6379&gt; zincrby chengji 2 lisi\"101\"127.0.0.1:6379&gt; zincrby chengji -3 lisi\"98\"127.0.0.1:6379&gt; zincrby chengji 0.5 lisi\"98.5\" zlexcountZLEXCOUNT key min max zlexcount 命令在计算有序集合中指定字典区间内成员数量。 说明： 成员名称前需要加 [ 符号作为开头，[ 符号与成员之间不能有空格。 可以使用- 和 + 表示得分最小值和最大值 min 和 max 不能反，max放前面min放后面会导致返回结果为0. 计算成员之间的成员数量时，参数min和max的位置也计算在内。 min和max参数的含义与zrangebylex命令所描述的相同。 返回值： 有序集合中成员名称 min 和 max之间的成员数量；integer类型。 12127.0.0.1:6379&gt; zlexcount chengji - +(integer) 4 zrangeZRANGE key start stop [WITHSCORES] zrange 返回有序集中，指定区间内的成员。其中成员的位置按分数值递增（从小到大）来排序。具有相同分数值的成员按字段序（lexicographical order）来排列。 如果你需要成员按值递减（从大到小）来排列，请使用 zrevrange 命令。 下标参数start 和 stop 都以0 为底，也就是说，以0 表示有序集第一个成员，以1表示有序集第二个成员，以此类推。你也可以使用负数下标，以-1表示最后一个成员，-2 表示倒数第二个成员，以此类推。 1234567891011121314127.0.0.1:6379&gt; zrange chengji 0 -11) \"wangwu\"2) \"zhangsan\"3) \"lisi\"4) \"ooyhao\"127.0.0.1:6379&gt; zrange chengji 0 -1 withscores1) \"wangwu\"2) \"97\"3) \"zhangsan\"4) \"98\"5) \"lisi\"6) \"98.5\"7) \"ooyhao\"8) \"100\" 从大到小： 123456789127.0.0.1:6379&gt; zrevrange chengji 0 -1 withscores1) \"ooyhao\"2) \"100\"3) \"lisi\"4) \"98.5\"5) \"zhangsan\"6) \"98\"7) \"wangwu\"8) \"97\" zrangebylexZRANGEBYLEX key min max [LIMIT offset count] zrangebylex 通过字典区间返回有序集合的成员。（安装字典顺序排列） 1234567127.0.0.1:6379&gt; zrangebylex chengji - [c1) \"a\"2) \"b\"3) \"c\"127.0.0.1:6379&gt; zrangebylex chengji - (c1) \"a\"2) \"b\" zrangebyscoreZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] min 和 max 可以使用 -inf 和 +inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用zrangebyscore 命令。 zrangebyscore 返回有序集合中指定分数区别的成员列表。有序集成员按分数值递增（从小到大）次序排列。 具有相同分数值的成员按字典序来排列（该属性是有序集提供的，不需要额外的计算）。默认情况下，区间的取值使用闭区间（小于等于或大于等于），你也可以通过给参数前增加（符号来使用可选的开区间（小于或大于））。 1234567891011121314151617181920127.0.0.1:6379&gt; zrangebyscore chengji -inf +inf withscores 1) \"a\" 2) \"96\" 3) \"b\" 4) \"97\" 5) \"c\" 6) \"98\" 7) \"d\" 8) \"99\" 9) \"e\"10) \"100\"11) \"f\"12) \"101\"127.0.0.1:6379&gt; zrangebyscore chengji 97 99 withscores1) \"b\"2) \"97\"3) \"c\"4) \"98\"5) \"d\"6) \"99\" zrankzrank 返回有序集合中指定成员的排名。其中有序集合成员按分数值递增顺序排序。 1234127.0.0.1:6379&gt; zrank chengji c(integer) 2127.0.0.1:6379&gt; zrank chengji a(integer) 0 zrevrangeZREVRANGE key start stop [WITHSCORES] zrevrange 命令返回有序集中，指定区间内的成员。其中成员的位置按分数值递减（从大到小）来排列。 具有相同分数值的成员按照字段序的逆序(reverse lexicographical order) 排列，除了成员按分数值递减的次序排列这一点外，zrevrange命令的其他方面和zrange命令一直。 1234567127.0.0.1:6379&gt; zrevrange chengji 0 -11) \"f\"2) \"e\"3) \"d\"4) \"c\"5) \"b\"6) \"a\" zrevrangebyscoreZREVRANGEBYSCORE key max min [WITHSCORES] zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减（从大到小）的次序排列。具有相同分数值的成员按字典的逆序(reverse lexicographical order)排列。除了成员按分数值递减的次序排列这一点外，zrevrangebyscore命令的其他方面和zrangebyscore命令一样、 123456789127.0.0.1:6379&gt; zrevrangebyscore chengji 100 97 withscores1) \"e\"2) \"100\"3) \"d\"4) \"99\"5) \"c\"6) \"98\"7) \"b\"8) \"97\" zrevrankZREVRANK key member zrevrank 命令返回有序集中成员的排名。其中有序集成员分数值递减（从大到小）排序。排名以0位底，也就是说，分数值最大的成员排名是0.使用zrank命令可以获取成员按分数值递增（从小到大）排列的排名。 1234127.0.0.1:6379&gt; zrank chengji f(integer) 5127.0.0.1:6379&gt; zrevrank chengji f(integer) 0 zscorezscore 命令返回有序集中，成员的分数值。如果成员元素不是有序集key的成员，或key不存在，返回nil。 12127.0.0.1:6379&gt; zscore chengji ooyhao\"100\" 返回值：成员的分数值，以字符串形式表示。 zremZREM key member [member ...] zrem 命令用于移除有序集中的一个或多个成员，不存在的成员将被忽略。当key存在但不是有序集合类型时，返回一个错误。 12345678127.0.0.1:6379&gt; zrem chengji a(integer) 1127.0.0.1:6379&gt; zrange chengji 0 -11) \"b\"2) \"c\"3) \"d\"4) \"e\"5) \"f\" zremrangebylexZREMRANGEBYLEX key min max zremrangebylex 命令用于移除有序集合中给定的字典区间的所有成员。 123456789127.0.0.1:6379&gt; zremrangebylex chengji [d [f(integer) 3127.0.0.1:6379&gt; zrange chengji 0 -1 withscores1) \"a\"2) \"96\"3) \"b\"4) \"97\"5) \"c\"6) \"98\" zremrangebyrankZREMRANGEBYRANK key start stop zremrangebyrank 命令用于移除有序集中，指定排名（rank）区间内的所有元素 123456127.0.0.1:6379&gt; zremrangebyrank chengji 0 2(integer) 3127.0.0.1:6379&gt; zrange chengji 0 -11) \"d\"2) \"e\"3) \"f\" zremrangebyscoreZREMRANGEBYSCORE key min max zremrangebyscore 命令用于移除有序集中，指定分数（score）区间内的所有成员 1234567127.0.0.1:6379&gt; zremrangebyscore chengji 96 97(integer) 2127.0.0.1:6379&gt; zrange chengji 0 -11) \"c\"2) \"d\"3) \"e\"4) \"f\" sinterstoreZINTERSTORE destination numkeys key [key ...] zinterstore 命令计算给定的一个或多个有序集的交集，其中给定的key的数量必须以numkeys参数指定，并将该交集（结果集）存储到destination中。 默认情况下，结果集中某一个成员分数值是所有给定集下该成员分数值之和。 1234567891011127.0.0.1:6379&gt; zadd chengji1 97 a 98 b 99 c 101 d(integer) 4127.0.0.1:6379&gt; zadd chengji2 99 c 100 d 101 e 102 f(integer) 4127.0.0.1:6379&gt; zinterstore chengji3 2 chengji1 chengji2(integer) 2127.0.0.1:6379&gt; zrange chengji3 0 -1 withscores1) \"c\"2) \"198\"3) \"d\"4) \"201\" zunionstoreZUNIONSTORE destination numkeys key [key ...] zunionstore 命令计算给定的一个或多个有序集合的并集，其中给定key的数量必须以numkeys参数指定，并将该并集（结果集）存储到destination中。 默认情况下，结果集中某个成员的分数是所有给定集下该成员分数值之和。 123456789101112131415127.0.0.1:6379&gt; zunionstore chengji4 2 chengji1 chengji2(integer) 6127.0.0.1:6379&gt; zrange chengji4 0 -1 withscores 1) \"a\" 2) \"97\" 3) \"b\" 4) \"98\" 5) \"e\" 6) \"101\" 7) \"f\" 8) \"102\" 9) \"c\"10) \"198\"11) \"d\"12) \"201\" redis的zset集合就介绍这么多了。 本文参考自菜鸟教程:https://www.runoob.com/redis/redis-sorted-sets.html 更多请移步官网","link":"/2020/02/22/db/redis/8.redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bzset/"},{"title":"RabbitMQ","text":"RabbitMQ基础操作指南 RabbitMQ 2.收发信息的步骤1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677生产者：1.创建连接工厂ConnectionFactory factory = new ConnectionFactory();需要设置参数： .setHost(String); .setPort(int); .setUsername(String); .setPassword(String); .setVirtualHost(String);2.通过工厂对象创建连接Connection connection = factory.newConnection();3.通过连接对象创建通道Channel channel = connection.createChannel(); 3.1队列声明 /** * 声明队列，如果rabbit中没有此队列将自动创建 * param1: 队列名称 * param2: 是否持久化 * param3: 队列是否独占此连接 * param4: 队列不再使用时是否自动删除此队列 * param5: 队列参数 */ .queueDeclare(String,boolean,boolean,boolean,Map); 3.2消息发布 /** * 消息发布方法 * param1: Exchange的名称，如果没有指定名称，则使用 Default Exchange * param2: routingKey，消息的路由Key，用于Exchange（交换机）将消息转发到指定的消息队列 * param3: 消息包含的属性 * param4: 消息体 */ /** * 这里没有指定交换机，消息将发送给默认的交换机，每个队列也会绑定那个默认的交换机， * 但是不能 * 绑定显示或是解除绑定 * 默认的交换机，routingKey等于队列名称 */ .basicPublish(\"\",QUEUE,null,message.getBytes());消费者：1.创建连接工厂ConnectionFactory factory = new ConnectionFactory(); //设置RabbitMQ所在服务器的ip和端口 factory.setHost(\"127.0.0.1\"); factory.setPort(5672);2.通过工厂对象创建连接Connection connection = factory.newConnection();3.通过连接对象创建通道Channel channel = connection.createChannel(); 3.1队列声明 3.2创建消费方法 /** * 消费者接受消息调用此方法 * @param consumerTag 消费者的标签，在channel.basicConsume()去指定 * @param envelope 消息包的内容，可以从中获取消息id，消息的routingKey，交换机，消息 * 和重传标志（收到消息失败后是否需要重新发送） * @param properties * @param body * @throws IOException */ DefaultConsumer consumer = new DefaultComsumer(channel){ @Override handleDelivery(); }; 3.3进行监听 /** * 监听消息String queue，boolean autoAck，Consumer callback * 参数明细： * 1.队列名称 * 2.是否自动回复，设置为true表示消息接收到自动向mq回复接收到了， * mq接收到回复消息会删除消息， * 设置为false则需要手动回复 * 3.消费消息的方法，消费者接收到消息后调用此方法 */ channel.basicConsume(QUEUE,true,consumer); 1、发送端操作流程 1）创建连接 2）创建通道 3）声明队列 4）发送消息 2、接收端 1）创建连接 2）创建通道 3）声明队列 4）监听队列 5）接收消息 6）ack回复 3.简单队列1.模型 2.获取连接的工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ConnectionUtils { /** * 服务器地址 */ public static final String HOST = \"127.0.0.1\"; /** * 服务器端口 AMQP */ public static final Integer PORT = 5672; /** * 用户名 */ public static final String USERNAME = \"guest\"; /** * 密码 */ public static final String PASSWORD = \"guest\"; /** * 主机访问地址 */ public static final String VIRTUALHOST = \"/\"; public static Connection getConnection(){ ConnectionFactory factory = new ConnectionFactory(); factory.setHost(HOST); factory.setPort(PORT); factory.setUsername(USERNAME); factory.setPassword(PASSWORD); factory.setVirtualHost(VIRTUALHOST); Connection connection = null; try { connection = factory.newConnection(); } catch (IOException e) { e.printStackTrace(); } catch (TimeoutException e) { e.printStackTrace(); } return connection; }} 3.生产者生产消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Producer01 { //对列名称 private static final String QUEUE = \"helloworld\"; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = null; Channel channel = null; try{ ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); factory.setPort(5672); factory.setUsername(\"guest\"); factory.setPassword(\"guest\"); //rabbitmq 默认虚拟机名称为\"/\"，虚拟机相当于一个独立的mq服务器 factory.setVirtualHost(\"/\"); //创建与RabbitMQ服务的TCP连接 connection = factory.newConnection(); //创建与Exchange的通道，每个连接可以创建多个通道，每一个通道代表一个会话任务。 channel = connection.createChannel(); /** * 声明队列，如果rabbit中没有此队列将自动创建 * param1: 队列名称 * param2: 是否持久化 * param3: 队列是否独占此连接 * param4: 队列不再使用时是否自动删除此队列 * param5: 队列参数 */ channel.queueDeclare(QUEUE,true,false,false,null); String message = \"helloworld小明：\"+System.currentTimeMillis(); /** * 消息发布方法 * param1: Exchange的名称，如果没有指定名称，则使用 Default Exchange * param2: routingKey，消息的路由Key，用于Exchange（交换机）将消息转发到指定的消息队列 * param3: 消息包含的属性 * param4: 消息体 */ /** * 这里没有指定交换机，消息将发送给默认的交换机，每个队列也会绑定那个默认的交换机， * 但是不能 * 绑定显示或是解除绑定 * 默认的交换机，routingKey等于队列名称 */ channel.basicPublish(\"\",QUEUE,null, message.getBytes()); System.out.println(\"Send Message is：\"+message); }catch (Exception e){ e.printStackTrace(); }finally { if (channel != null){ channel.close(); } if (connection != null){ connection.close(); } } }} 4.消费者消费消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer01 { private static final String QUEUE = \"helloworld\"; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); //设置RabbitMQ所在服务器的ip和端口 factory.setHost(\"127.0.0.1\"); factory.setPort(5672); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); //声明队列 channel.queueDeclare(QUEUE,true,false,false,null); //定义消费方法 DefaultConsumer consumer = new DefaultConsumer(channel){ /** * 消费者接受消息调用此方法 * @param consumerTag 消费者的标签，在channel.basicConsume()去指定 * @param envelope 消息包的内容，可以从中获取消息id，消息的routingKey，交换机，消息 * 和重传标志（收到消息失败后是否需要重新发送） * @param properties * @param body * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //交换机 String exchange = envelope.getExchange(); //路由key String routingKey = envelope.getRoutingKey(); //消息id long deliveryTag = envelope.getDeliveryTag(); //消息内容 String message = new String(body,\"utf-8\"); //是否重传 boolean isRedeliver = envelope.isRedeliver(); System.out.println(\"exchange:\"+exchange); System.out.println(\"routingKey:\"+routingKey); System.out.println(\"deliveryTag:\"+deliveryTag); System.out.println(\"isRedeliver:\"+isRedeliver); System.out.println(\"message:\"+message); } }; /** * 监听消息String queue，boolean autoAck，Consumer callback * 参数明细： * 1.队列名称 * 2.是否自动回复，设置为true表示消息接收到自动向mq回复接收到了， * mq接收到回复消息会删除消息，设置为false则需要手动回复 * 3.消费消息的方法，消费者接收到消息后调用此方法 */ channel.basicConsume(QUEUE,true,consumer); }} 5.简单队列的不足耦合性高，生产者一一对应消费者（如何我想要有多个消费者消费队列中消息，这时候就不行了），队列名变更，这时候得同事变更。 4.work queues 工作队列模式1.模型 为什么会出现工作队列 simple队列是一一对应的，而且实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接受到消息之后就需要处理，可能需要花费时间，这时候队列就会积压了很多消息 2.生产者12345678910111213141516171819202122232425public class Send { /** * |-- C1 * p -- Queue -- | * |-- C2 */ public static final String QUEUE_NAME = \"test_work_queue\"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { //获取连接 Connection connection = ConnectionUtils.getConnection(); //获取Channel Channel channel = connection.createChannel(); //声明Queue(String queueName, Boolean durable, Boolean exclusive, Boolean autoDelete, Map&lt;String, Object&gt; arguments) channel.queueDeclare(QUEUE_NAME,true,false,false,null); for (int i = 0; i &lt; 50; i++) { String message = \"MQ \"+i; channel.basicPublish(\"\",QUEUE_NAME,null,message.getBytes()); System.out.println(\"send message: \"+message); Thread.sleep(i*20); } channel.close(); connection.close(); }} 3.消费者1123456789101112131415161718192021222324252627282930public class Receive1 { public static final String QUEUE_NAME = \"test_work_queue\"; public static void main(String[] args) throws IOException { //获取连接 Connection connection = ConnectionUtils.getConnection(); //获取Channel Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); DefaultConsumer consumer = new DefaultConsumer(channel){ //消息到达 触发方法 @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"[1] get message :\"+ new String(body,\"utf-8\")); try { Thread.sleep(1000*2); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\"[1] over\"); } } }; boolean autoAck = true; //监听消息String queue，boolean autoAck，Consumer callback channel.basicConsume(QUEUE_NAME,autoAck,consumer); }} 4.消费者2123456789101112131415161718192021222324252627282930public class Receive2 { public static final String QUEUE_NAME = \"test_work_queue\"; public static void main(String[] args) throws IOException { //获取连接 Connection connection = ConnectionUtils.getConnection(); //获取Channel Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); DefaultConsumer consumer = new DefaultConsumer(channel){ //消息到达 触发方法 @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"[2] get message :\"+ new String(body,\"utf-8\")); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\"[2] over\"); } } }; boolean autoAck = true; //监听消息String queue，boolean autoAck，Consumer callback channel.basicConsume(QUEUE_NAME,autoAck,consumer); }} 5.现象消费者1和消费者2处理的消息是一样的。 消费者1：偶数 消费者2：奇数 这种方式叫做轮询分发（roun-robin）结果就是：不管谁忙活着谁清闲 都不会多给一个消息任务 任务消息总是平均分配。（你一个我一个） 5.公平分发 fair depatch1.说明使用公平分发，必须关闭自动应答ack,改为手动 2.生产者12345678910111213141516171819202122232425262728293031public class Send { /** * |-- C1 * p -- Queue -- | * |-- C2 */ public static final String QUEUE_NAME = \"test_work_queue\"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { //获取连接 Connection connection = ConnectionUtils.getConnection(); //获取Channel Channel channel = connection.createChannel(); //声明Queue(String queueName, Boolean durable, Boolean exclusive, Boolean autoDelete, Map&lt;String, Object&gt; arguments) channel.queueDeclare(QUEUE_NAME,true,false,false,null); /** * 每个消费者 发送确认消息消息之前，消息队列不发送下一个消息到消费者，一次只处理一个消息 * * 限制发送给同一个消费者不得超过一条消息 */ int prefetchCount = 1; channel.basicQos(prefetchCount); for (int i = 0; i &lt; 50; i++) { String message = \"MQ \"+i; channel.basicPublish(\"\",QUEUE_NAME,null,message.getBytes()); System.out.println(\"send message: \"+message); Thread.sleep(i*20); } channel.close(); connection.close(); }} 3.消费者1123456789101112131415161718192021222324252627282930313233public class Receive1 { public static final String QUEUE_NAME = \"test_work_queue\"; public static void main(String[] args) throws IOException { //获取连接 Connection connection = ConnectionUtils.getConnection(); //获取Channel final Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); int prefetchCount = 1; channel.basicQos(prefetchCount); DefaultConsumer consumer = new DefaultConsumer(channel){ //消息到达 触发方法 @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"[1] get message :\"+ new String(body,\"utf-8\")); try { Thread.sleep(1000*2); } catch (InterruptedException e) { e.printStackTrace(); } finally { //手动回执应答 channel.basicAck(envelope.getDeliveryTag(),false); System.out.println(\"[1] over\"); } } }; boolean autoAck = false;//非自动应答 //监听消息String queue，boolean autoAck，Consumer callback channel.basicConsume(QUEUE_NAME,autoAck,consumer); }} 4.消费者2123456789101112131415161718192021222324252627282930313233public class Receive2 { public static final String QUEUE_NAME = \"test_work_queue\"; public static void main(String[] args) throws IOException { //获取连接 Connection connection = ConnectionUtils.getConnection(); //获取Channel final Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); int prefetchCount = 1; channel.basicQos(prefetchCount); DefaultConsumer consumer = new DefaultConsumer(channel){ //消息到达 触发方法 @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"[2] get message :\"+ new String(body,\"utf-8\")); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { //手动回执应答 channel.basicAck(envelope.getDeliveryTag(),false); System.out.println(\"[2] over\"); } } }; boolean autoAck = false; //监听消息String queue，boolean autoAck，Consumer callback channel.basicConsume(QUEUE_NAME,autoAck,consumer); }} 5.与work queues的差别之处5.1 生产者 5.2 消费者 6.现象消费者2处理的消息比消费者1多（能者多劳，公平分发） 6.消息应答 与 消息持久化6.1消息应答自动确认模式： ​ RabbitMQ一旦将消息分发非消费之后，就会从内存中删除这个消息 现象： ​ 这种情况下，如果杀死（kill）当前正在执行的消费者，就会丢失正在执行的消息。 12boolean autoAck = true;//自动应答channel.basicConsume(QUEUE_NAME,autoAck,consumer); 手动确认模式： 123boolean autoAck = false;//非自动应答//监听消息String queue，boolean autoAck，Consumer callbackchannel.basicConsume(QUEUE_NAME,autoAck,consumer); 如果有一个消费者挂掉，就会交付给其他消费者。RabbitMQ支持消息应答，消费者发送一个消息应答，告诉RabbitMQ这个消息我已经处理完成，RabbitMQ可以将这个消息从内存中删除了。 (message acknowledgment)消息应答模式（Ack）是打开的， false。 如果RabbitMQ挂了，消息仍然会丢失。 6.2消息持久化12345678910/** * 参数： * queue:队列的名称 * durable:能否持久化 * exclusive:是否独占连接 * autoDelete:是否自动删除 * arguments:参数 */boolean durable = true;channel.queueDeclare(QUEUE_NAME,durable,false,false,null); 我们将程序中的boolean durable = true; 改为false是不可以的，会报错。尽管代码是正确的，但是该队列应该声明定义好了，就不可以再进行修改了。（RabbitMQ不允许用不同的参数重新定义一个已经存在的队列（可以先删除再创建）） 7.Exchange(交换机，转发器)一方面是接收生产者的消息，另一方面是向队列推送消息。 匿名转发：“”; 7.1 Fanout Exchange(不处理路由键) 只需要将生产者与exchange进行bind，就会把exchange中的信息转发到与exchange绑定的所有Queue中。 123456789任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。1.可以理解为路由表的模式2.这种模式不需要RouteKey3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。 7.2 Direct Exchange 处理路径键 123456789任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。1.一般情况可以使用rabbitMQ自带的Exchange：”\"(该Exchange的名字为空字符串，下文称其为default Exchange)。2.这种模式下不需要将Exchange进行任何绑定(binding)操作3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。 7.3 Topic Exchange 123456789101112任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上1.这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。2.这种模式需要RouteKey，也许要提前绑定Exchange与Queue。3.在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。4.“#”表示0个或若干个关键字，“*”表示一个关键字。如“log.*”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。5.同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息。 性能排序：fanout &gt; direct &gt;&gt; topic。比例大约为11：10：6 8.订阅模式Publish/Subscribe(fanout)1.模型 2.解读 一个生产者，多个消费者。 每一个消费者都有自己对应的队列。 生产者没有直接把消息发送到队列 而是发送到了交换机 （转发器exchange） 每个队列都要绑定到交换机上 生产者发送的消息经过交换机到达队列 ，就能实现一个消息就可以被多个消费者消费。 1234发布订阅模式：1、每个消费者监听自己的队列。2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息 注册 –&gt; 邮件 –&gt; 短信 3.发送者1234567891011121314151617181920212223public class Send { public static final String QUEUE_NAME = \"test_queue_fanout\"; public static final String EXCHANGE_NAME = \"test_exchange_fanout\"; public static void main(String[] args) throws IOException, TimeoutException { //通过工具类获取连接 Connection connection = ConnectionUtils.getConnection(); //创建Channel Channel channel = connection.createChannel(); /** * 声明交换机 * 参数： * exchange:exchange的名字 * type:exchange的类型 */ channel.exchangeDeclare(EXCHANGE_NAME,\"fanout\");//分发 //发送消息 String message = \"hello publish/subscribe\"; channel.basicPublish(EXCHANGE_NAME,\"\",null,message.getBytes()); System.out.println(\"send message : \"+message); channel.close(); connection.close(); }} 4.exchange图示 消息去哪里了？？丢失了，因为交换机没有存储的能力，在RabbitMQ里面只有队列有存储能力。因为此时没有把交换机和相应的队列进行绑定，所以数据就丢失了。 5.发送者1234567891011121314151617181920212223public class Send { public static final String EXCHANGE_NAME = \"test_exchange_fanout\"; public static void main(String[] args) throws IOException, TimeoutException { //通过工具类获取连接 Connection connection = ConnectionUtils.getConnection(); //创建Channel Channel channel = connection.createChannel(); //声明交换机 /** * 参数： * exchange:exchange的名字 * type:exchange的类型 */ channel.exchangeDeclare(EXCHANGE_NAME,\"fanout\");//分发 //发送消息 String message = \"hello publish/subscribe\"; channel.basicPublish(EXCHANGE_NAME,\"\",null,message.getBytes()); System.out.println(\"send message : \"+message); channel.close(); connection.close(); }} 6.消费者1123456789101112131415161718192021222324252627282930public class Receive1 { public static final String QUEUE_NAME = \"test_queue_fanout_email\"; public static final String EXCHANGE_NAME = \"test_exchange_fanout\"; public static void main(String[] args) throws IOException { Connection connection = ConnectionUtils.getConnection(); final Channel channel = connection.createChannel(); //队列声明 channel.queueDeclare(QUEUE_NAME,true,false,false,null); channel.basicQos(1); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,\"\"); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"[1] receive message:\"+new String(body,\"utf-8\")); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); }finally { System.out.println(\"[1] over\"); channel.basicAck(envelope.getDeliveryTag(),false); } } }; channel.basicConsume(QUEUE_NAME,false,consumer); }} 7.消费者21234567891011121314151617181920212223242526272829public class Receive2 { public static final String QUEUE_NAME = \"test_queue_fanout_sms\"; public static final String EXCHANGE_NAME = \"test_exchange_fanout\"; public static void main(String[] args) throws IOException { Connection connection = ConnectionUtils.getConnection(); final Channel channel = connection.createChannel(); //队列声明 channel.queueDeclare(QUEUE_NAME,true,false,false,null); channel.basicQos(1); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,\"\"); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"[2] receive message:\"+new String(body,\"utf-8\")); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); }finally { System.out.println(\"[2] over\"); channel.basicAck(envelope.getDeliveryTag(),false); } } }; channel.basicConsume(QUEUE_NAME,false,consumer); }} 8.管理界面 9.Routing(direct)1.路由模型 2.生产者12345678910111213141516171819202122public class Send { //exchange name public static final String EXCHANGE_NAME = \"test_exchange_direct\"; //routing key public static final String ROUTING_KEY = \"error\"; public static void main(String[] args) throws IOException, TimeoutException { //获得连接 Connection connection = ConnectionUtils.getConnection(); //创建Channel Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME,\"direct\"); //消息 String message = \"hello direct!\"+ROUTING_KEY; //发布消息 channel.basicPublish(EXCHANGE_NAME,ROUTING_KEY,null,message.getBytes()); System.out.println(\"send message:\"+message); //资源释放 channel.close(); connection.close(); }} 3.消费者1123456789101112131415161718192021public class Receive1 { //queue name public static final String QUEUE_NAME = \"test_queue_direct_1\"; //exchange name public static final String EXCHANGE_NAME = \"test_exchange_direct\"; //routing key public static final String ROUTING_KEY = \"error\"; public static void main(String[] args) throws IOException, TimeoutException { //获得Connection Connection connection = ConnectionUtils.getConnection(); //创建Channel final Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); channel.basicQos(1); //绑定 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY); DefaultConsumer consumer = new MyDefaultConsumer(channel,\"1\"); channel.basicConsume(QUEUE_NAME,false,consumer); }} 4.消费者212345678910111213141516171819202122232425public class Receive2 { //queue name public static final String QUEUE_NAME = \"test_queue_direct_2\"; //exchange name public static final String EXCHANGE_NAME = \"test_exchange_direct\"; //routing key public static final String ROUTING_KEY1 = \"info\"; public static final String ROUTING_KEY2 = \"error\"; public static final String ROUTING_KEY3 = \"warning\"; public static void main(String[] args) throws IOException, TimeoutException { //获得Connection Connection connection = ConnectionUtils.getConnection(); //创建Channel final Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); channel.basicQos(1); //绑定 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY1); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY2); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY3); DefaultConsumer consumer = new MyDefaultConsumer(channel,\"2\"); channel.basicConsume(QUEUE_NAME,false,consumer); }} 5.MyDefaultConsumer 123456789101112131415161718192021public class MyDefaultConsumer extends DefaultConsumer { private Channel channel = null; private String name = \"\"; public MyDefaultConsumer(Channel channel,String name) { super(channel); this.channel = channel; this.name = name; } @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(name+\" receive message: \"+new String(body,\"utf-8\")); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); }finally { System.out.println(name+\" over\"); channel.basicAck(envelope.getDeliveryTag(),false); } }} 5.Exchanges图示 10.Topic(topic)1.模型 12345.“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。Goods.insert |Goods.update | ==&gt; Goods.# Goods.delete | 2.生产者1234567891011121314151617public class Send { public static final String EXCHANGE_NAME = \"test_exchange_topic\"; public static void main(String[] args) throws IOException, TimeoutException { //获得连接 Connection connection = ConnectionUtils.getConnection(); //创建Channel Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME,\"topic\"); String message = \"商品。。。\"; //发布消息 channel.basicPublish(EXCHANGE_NAME,\"goods.delete\",null,message.getBytes()); System.out.println(\"topic send message:\"+message); channel.close(); connection.close(); }} 3.消费者1123456789101112131415161718192021public class Receive1 { //queue name public static final String QUEUE_NAME = \"test_queue_topic_1\"; //exchange name public static final String EXCHANGE_NAME = \"test_exchange_topic\"; //routing key public static final String ROUTING_KEY = \"goods.add\"; public static void main(String[] args) throws IOException, TimeoutException { //获得Connection Connection connection = ConnectionUtils.getConnection(); //创建Channel final Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); channel.basicQos(1); //绑定 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY); DefaultConsumer consumer = new MyDefaultConsumer(channel,\"topic1\"); channel.basicConsume(QUEUE_NAME,false,consumer); }} 4.消费者2123456789101112131415161718192021public class Receive2 { //queue name public static final String QUEUE_NAME = \"test_queue_topic_2\"; //exchange name public static final String EXCHANGE_NAME = \"test_exchange_topic\"; //routing key public static final String ROUTING_KEY = \"goods.#\"; public static void main(String[] args) throws IOException, TimeoutException { //获得Connection Connection connection = ConnectionUtils.getConnection(); //创建Channel final Channel channel = connection.createChannel(); //声明Queue channel.queueDeclare(QUEUE_NAME,true,false,false,null); channel.basicQos(1); //绑定 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,ROUTING_KEY); DefaultConsumer consumer = new MyDefaultConsumer(channel,\"topic2\"); channel.basicConsume(QUEUE_NAME,false,consumer); }} 11.RabbitMQ的消息确认机制(事务+confirm)在rabbitMQ中 我们可以通过持久化数据，解决rabbitmq服务器异常的数据丢失问题。 问题：生产者将消息发送出来之后，消息到底有没有到RabbitMQ服务器，默认的情况是不知道的。 两种方式： ​ AMQP实现了事务机制 ​ Confirm模式 事务机制： txSelect txCommit txRollback txSelect:用户将当前channel设置成transaction模式、 txCommit:用于提交事务 txRollback：回滚事务 1事务机制生产者1234567891011121314151617181920212223242526272829public class TxSend { private static final String QUEUE_NAME = \"test_queue_tx\"; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); //声明queue channel.queueDeclare(QUEUE_NAME,false,false,false,null); String msgString = \"hello tx message!\"; System.out.println(\"send message:\"+msgString); try{ //开始事务 channel.txSelect(); channel.basicPublish(\"\",QUEUE_NAME,null,msgString.getBytes()); int i = 1/0; channel.txCommit(); //事务提交 }catch (Exception e){ //事务回滚 channel.txRollback(); System.out.println(\"send mesage txRollback\"); } channel.close(); connection.close(); }} 消费者123456789101112131415161718192021public class TxReceive { private static final String QUEUE_NAME = \"test_queue_tx\"; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); //声明queue channel.queueDeclare(QUEUE_NAME, false, false, false, null); DefaultConsumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"receive:\"+new String(body,\"utf-8\")); } }; channel.basicConsume(QUEUE_NAME,true,consumer); }} 2.Confirm模式生产者端confirm模式的实现原理123生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会指派成一个唯一的id（从1开始），一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。 Confirm模式最大的好处就在于它是异步的、 Nack； 开启confirm模式。 Channel.confirmSelect(); 编程模式： 1.普通 发一条 waitForConfirms() 2.批量 发一批 waitForConfirms() 3.异步 Confirm模式：提供一个回调的方法， 生产者： 123456789101112131415161718192021222324252627282930313233/** * 批量模式 */public class Send2 { private static final String QUEUE_NAME = \"test_queue_confirm1\"; public static void main(String[] args) throws IOException, InterruptedException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME,false,false,false,null); //生产者调用confirmSelect模式 将channel设置为Confirm模式 channel.confirmSelect(); String msgString = \"Hello confirm message batch\"; //批量发送消息 for (int i = 0; i &lt; 10; i++) { channel.basicPublish(\"\",QUEUE_NAME,null,msgString.getBytes()); } //确认 if(!channel.waitForConfirms()){ System.out.println(\"message send failed\"); }else{ System.out.println(\"message send ok\"); } channel.close(); connection.close(); }} 异步模式： 1Channel对象提供的confirmListener（）回调方法值包deliveryTag（当前Channel发出的消息序号），我们需要自己为每一个Channel维护一个unconfirm的消息序列集合，每publish一条数据，集合中元素加1.每回到一次handleAck方法，unconfirm集合删除相应的一条（multiple=false）或多条（multiple=true），从程序的运行效率来看，这个unconfirm集合最好采用有序集合sortedset存储结构。 publish-subscribe和work queues的区别123456789101112131、publish/subscribe与work queues有什么区别。区别：1）work queues不用定义交换机，而publish/subscribe需要定义交换机。2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默 认交换机)。3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实质上work queues会将队列绑定到默认的交换机 。相同点：所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。 2、实质工作用什么 publish/subscribe还是work queues。建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大，并且发布订阅模式可以指定自己专用的交换机。 4.4.4思考1、本案例的需求使用Routing工作模式能否实现？使用Routing模式也可以实现本案例，共设置三个 routingkey，分别是email、sms、all，email队列绑定email和all，sms队列绑定sms和all，这样就可以实现上边案例的功能，实现过程比topics复杂。Topic模式更多加强大，它可以实现Routing、publish/subscirbe模式的功能。 Routing 与 Topic的区别 1234使用Routing模式时，生产者生产信息是带有特殊的rountingKey,一条消息只会发送到一个Queue中，消费者通过唯一的routingKey来监听指定的Queue使用Topic模式时，生产者生产消息时带有通用的routingKey，一条信息可以发送到符合条件的Queue中，消费者通过配置带有#通配符的routingKey来监听满足条件的Queue。 6.headers12345678Headers类型的Exchanges是不处理路由键的，而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers属性是一个键值对，可以是Hashtable，键值对的值可以是任何类型，而fanout，direct，topic的路由必须都需要字符串形式的。匹配规则x-match有下列两种类型：x-match=all:表示所有的键值对都可匹配才可以接收到消息。x-match=any:表示只有有键值对匹配就可以接收到到消息。 header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。案例：根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种通知类型都接收的则两种通知都有效。代码：1）生产者队列与交换机绑定的代码与之前不同，如下： 123456Map&lt;String, Object&gt; headers_email = new Hashtable&lt;String, Object&gt;();headers_email.put(\"inform_type\", \"email\");Map&lt;String, Object&gt; headers_sms = new Hashtable&lt;String, Object&gt;();headers_sms.put(\"inform_type\", \"sms\");channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,\"\",headers_email);channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_HEADERS_INFORM,\"\",headers_sms); 通知： 12345678String message = \"email inform to user\"+i;Map&lt;String,Object&gt; headers = new Hashtable&lt;String, Object&gt;();headers.put(\"inform_type\", \"email\");//匹配email通知消费者绑定的header//headers.put(\"inform_type\", \"sms\");//匹配sms通知消费者绑定的headerAMQP.BasicProperties.Builder properties = new AMQP.BasicProperties.Builder();properties.headers(headers);//Email通知channel.basicPublish(EXCHANGE_HEADERS_INFORM, \"\", properties.build(), message.getBytes()); 消费者： 1234567channel.exchangeDeclare(EXCHANGE_HEADERS_INFORM, BuiltinExchangeType.HEADERS);Map&lt;String, Object&gt; headers_email = new Hashtable&lt;String, Object&gt;();headers_email.put(\"inform_email\", \"email\");//交换机和队列绑定channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,\"\",headers_email);//指定消费队列channel.basicConsume(QUEUE_INFORM_EMAIL, true, consumer); 7.RPC RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下： 1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。 2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果 3、服务端将RPC方法 的结果发送到RPC响应队列 4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。","link":"/2020/01/18/RabbitMQ/"},{"title":"一、初见Mybatis","text":"在技术进步的过程中，往往是因为新的技术比老的使用操作更方便，或是性能更优。而现在要接触的Mybatis无疑比传统的JDBC和hibernate等框架有更优的地方，才会有其存在的理由。下面我们通过JDBC与Mybatis的简单操作进行对比，来认识Mybatis的好。 简介来自官网： ​ MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 说一下：Mybatis官网对于英语不好的工程师来说很友好，因为它是为数不多的有中文文档的技术官网。 JDBC VS Mybatis使用JDBC操作数据库DBUtils: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 描述: * 类【DBUtils】 * * @author ouYangHao * @create 2019-09-17 14:55 */public class DBUtils { /*用户名*/ private static final String username = \"root\"; /*密码*/ private static final String password = \"root\"; /*驱动名*/ private static final String driverClassName = \"com.mysql.jdbc.Driver\"; /*数据库连接地址*/ private static final String dbUrl = \"jdbc:mysql://120.79.167.xxx:3306/mybatis ?useUnicode=true &amp;characterEncoding=UTF-8 &amp;allowMultiQueries=true &amp;autoReconnect=true &amp;useSSL=false\"; public static List&lt;User&gt; findUsersByUsername(String name){ List&lt;User&gt; users = new ArrayList&lt;&gt;(); /*连接*/ Connection connection = null; /*预编译statement*/ PreparedStatement statement = null; /*结果集*/ ResultSet resultSet = null; try { /*加载数据库驱动*/ Class.forName(driverClassName); /*获取数据库连接*/ connection = DriverManager.getConnection(dbUrl, username, password); /*定义SQL*/ String sql = \" select * from tb_user where username = ? \"; /*创建预编译处理的statement*/ statement = connection.prepareStatement(sql); /*设置参数*/ statement.setString(1,name); /*执行SQL*/ resultSet = statement.executeQuery(); /*遍历结果集，封装对象*/ while (resultSet.next()){ User user = new User(); user.setId(resultSet.getInt(\"id\")); user.setUserId(resultSet.getString(\"user_id\")); user.setUsername(resultSet.getString(\"username\")); user.setPassword(resultSet.getString(\"password\")); user.setEmail(resultSet.getString(\"email\")); user.setPhone(resultSet.getString(\"phone\")); user.setGender(resultSet.getInt(\"gender\")); user.setBirthday(resultSet.getTime(\"birthday\")); user.setStatus(resultSet.getInt(\"status\")); user.setCreateTime(resultSet.getTimestamp(\"create_time\")); user.setCreateUser(resultSet.getString(\"create_user\")); user.setModifyTime(resultSet.getTimestamp(\"modify_time\")); user.setModifyUser(resultSet.getString(\"modify_user\")); users.add(user); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); } finally { try { if (connection != null){ connection.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (statement != null){ statement.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (resultSet != null){ resultSet.close(); } } catch (SQLException e) { e.printStackTrace(); } } return users; } public static void main(String[] args) { List&lt;User&gt; users = DBUtils.findUsersByUsername(\"admin\"); System.out.println(users); }} 使用Mybatis操作数据库Mapper接口的方法： 1List&lt;User&gt; findUsersByUsername(String username); Mapper.xml文件的SQL： 1234567891011121314&lt;sql id=\"Base_Column_List\"&gt; id, user_id, username, password, email, phone, gender, birthday, status, create_time, create_user, modify_time, modify_user&lt;/sql&gt;&lt;!--查询--&gt;&lt;select id=\"findUsersByUsername\" resultType=\"user\"&gt; select &lt;include refid=\"Base_Column_List\"/&gt; from tb_user &lt;where&gt; username = #{username} &lt;/where&gt;&lt;/select&gt; 以上代码除去Mybatis的配置文件外，上面仅仅几行就可以实现JDBC几十行代码可以实现的效果。 Mybatis的配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 通过源码我们可以分析读取优先级： 1、在 properties 内部自定义的属性值第一个被读取 2、然后读取 resource 路径表示文件中的属性，如果有它会覆盖已经读取的属性； 如果 resource 路径不存在，那么读取 url 表示路径文件中的属性，如果有它会覆盖第一步读取的属性值 3、最后读取 parameterType 传递的属性值，它会覆盖已读取的同名的属性 --&gt; &lt;!--引入properties的属性文件--&gt; &lt;properties resource=\"mybatis.properties\"&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;/properties&gt; &lt;!--设置使用驼峰命名--&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"logPrefix\" value=\"##Mybatis##\"/&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--设置别名--&gt; &lt;!-- mybatis自动扫描包中的po类，自动定义别名，别名是类名(首字母大写或小写都可以,一般用小写) --&gt; &lt;typeAliases&gt; &lt;package name=\"com.ooyhao.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;!--配置环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--可以用来配置不同环境的参数，例如：开发，测试，生产--&gt; &lt;environment id=\"development\"&gt; &lt;!--事务管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--数据源--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--mapper xml文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mybatis.properties: 12345jdbc.driver= com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://120.79.167.88:3306/mybatis ?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;useSSL=falsejdbc.username = rootjdbc.password = root 测试： 1234567891011121314151617181920public TestDemo{ SqlSession sqlSession = null; @Before public void init(){ String resource = \"mybatis-configuration.xml\"; InputStream inputStream = RoleTest.class.getClassLoader().getResourceAsStream(resource); SqlSessionFactory build = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = build.openSession(true); } @Test public void testFindUsersByUsername() { //使用Mapper文件形式 String username = \"admin\"; UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.findUsersByUsername(username); System.out.println(userList); sqlSession.close(); }} 我们可以看一下测试类：我们通过SqlSessionFactoryBuilder的build方法，结合Mybatis的全局配置文件创建出SqlSessionFactory,再利用SqlSessionFactory通过openSession方法创建一个SqlSession。然后通过SqlSession来操作SQL。 看一下项目结构： SqlSession执行SQL操作步骤 需要在对应的mapper文件中添加相关的sql配置。 获得配置文件的路径并通过Resources的getResourceAsStream/AsReader方法获取流 InputStream getResourceAsStream(String resource) 返回值为字节流 Reader getResourceAsReader(String resource) 返回值为字符流 通过SqlSessionFactoryBuilder创建对象 使用SqlSessionFactoryBuilder对象的build(Stream/Reader)方法创建SqlSessionFactory对象。 通过SQLSessionFactory对象的openSession方法创建一个SqlSession对象 通过SQLSession对象的相关方法进行对数据库的crud操作。 增删改时需要提交事务。 上面已经进行了数据库操作，我们再回头看一下是不是这样的步骤： 12345678910111213141516171819202122@Testpublic void testFindUsersByUsername() { //1.mybatis的全局配置文件。 String resource = \"mybatis-configuration.xml\"; //2.获取文件并将其读取成流。 InputStream inputStream = RoleTest.class.getClassLoader().getResourceAsStream(resource); //3.通过SqlSessionFactoryBuilder创建对象。 //4.通过build创建SQLSessionFactory。 SqlSessionFactory build = new SqlSessionFactoryBuilder().build(inputStream); //5.创建一个SqlSession对象 sqlSession = build.openSession(true); //使用Mapper接口形式 String username = \"admin\"; UserMapper mapper = sqlSession.getMapper(UserMapper.class); //6.进行数据库操作 List&lt;User&gt; userList = mapper.findUsersByUsername(username); System.out.println(userList); //7.前面设置了自动提交，所以不同提交事务，这里关闭资源。 sqlSession.close();} 我们通过SqlSession指定Sql的有下列几种方式： 方式1使用SqlSession直接通过namespace.id的形式操作xml： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ooyhao.mybatis1.mybatis.mapper.UserMapper\"&gt; &lt;!--查询--&gt; &lt;select id=\"findUsersByUsername\" resultType=\"user\"&gt; select &lt;include refid=\"Base_Column_List\"/&gt; from tb_user &lt;where&gt; username = #{username} &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 测试方法： 123456789@Testpublic void testMybatisFindUsersByUsernameXML() { /*使用XML形式文件*/ String username = \"admin\"; List&lt;User&gt; list = sqlSession.selectList (\"com.ooyhao.mybatis1.mybatis.mapper.UserMapper.findUsersByUsername\", username); System.out.println(list); sqlSession.close();} 提示：com.ooyhao.mybatis1.mybatis.mapper.UserMapper是xml配置文件的namespace。findUsersByUsername是sql的id。 方式2使用Mapper接口结合注解的方式来执行SQL： 12@Select(\" select * from tb_user where username = #{value} \")List&lt;User&gt; findUsersByUsername(String username); 测试方法： 123456789@Testpublic void testFindUsersByUsername() { //使用Mapper文件形式 String username = \"admin\"; UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.findUsersByUsername(username); System.out.println(userList); sqlSession.close();} 提示：这种方式通过在接口方法上使用注解，来替代在xml文件中的SQL，简单sql可以使用注解。 方式3使用Mapper接口和XML文件关联来查询SQL并执行： Mapper接口： 1List&lt;User&gt; findUsersByUsername(String username); Xml文件： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ooyhao.mybatis1.mybatis.mapper.UserMapper\"&gt; &lt;!--查询--&gt; &lt;select id=\"findUsersByUsername\" resultType=\"user\"&gt; select &lt;include refid=\"Base_Column_List\"/&gt; from tb_user &lt;where&gt; username = #{username} &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 单元测试方法： 123456789@Testpublic void testFindUsersByUsername() { //使用Mapper文件形式 String username = \"admin\"; UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.findUsersByUsername(username); System.out.println(userList); sqlSession.close();} 这种情况后面使用最多，但是有一些需要遵循的规则： 1234567891011//遵循四个原则1、Mapper.xml文件中的namespace与mapper接口的类路径相同。2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同mapper动态代理 Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。 完整的Mybatis案例完整的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 通过源码我们可以分析读取优先级： 1、在 properties 内部自定义的属性值第一个被读取 2、然后读取 resource 路径表示文件中的属性，如果有它会覆盖已经读取的属性； 如果 resource 路径不存在，那么读取 url 表示路径文件中的属性， 如果有它会覆盖第一步读取的属性值 3、最后读取 parameterType 传递的属性值，它会覆盖已读取的同名的属性 --&gt; &lt;!--引入properties的属性文件,数据库配置--&gt; &lt;properties resource=\"mybatis.properties\"&gt; &lt;/properties&gt; &lt;!--设置使用驼峰命名--&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"logPrefix\" value=\"##Mybatis##\"/&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--设置别名--&gt; &lt;!-- mybatis自动扫描包中的po类，自动定义别名，别名是类名(首字母大写或小写都可以,一般用小写) --&gt; &lt;typeAliases&gt; &lt;package name=\"com.ooyhao.mybatis3.bean\"/&gt; &lt;/typeAliases&gt; &lt;!--配置环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--可以用来配置不同环境的参数，例如：开发，测试，生产--&gt; &lt;environment id=\"development\"&gt; &lt;!--事务管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--数据源--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--mapper xml文件--&gt; &lt;mappers&gt; &lt;!--&lt;package name=\"mapper\"/&gt;--&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;mapper resource=\"mapper/RoleMapper.xml\"/&gt; &lt;mapper resource=\"mapper/VehicleMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 配置文件解析【通过properties 的resource属性引入properties文件】 12&lt;!--引入properties的属性文件,数据库配置--&gt;&lt;properties resource=\"mybatis.properties\"&gt;&lt;/properties&gt; 【延迟加载技术】 12345678910&lt;settings&gt; &lt;!--开启驼峰命名--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--日志输出--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--关闭强制延迟加载技术--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 【包别名】 1234567&lt;!--设置别名--&gt;&lt;!-- mybatis自动扫描包中的po类，自动定义别名，别名是类名(首字母大写或小写都可以,一般用小写) --&gt;&lt;typeAliases&gt; &lt;package name=\"com.ooyhao.mybatis3.bean\"/&gt;&lt;/typeAliases&gt; 【配置数据库信息】（要根据自己的环境来设置） 123456789101112131415&lt;!--配置环境--&gt;&lt;environments default=\"development\"&gt; &lt;!--可以用来配置不同环境的参数，例如：开发，测试，生产--&gt; &lt;environment id=\"development\"&gt; &lt;!--事务管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--数据源--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 【通过在mapper标签中引入mapper文件】 （一定要注意每新创建一个mapper文件需要在配置文件中配置） 1234567&lt;!--mapper xml文件--&gt;&lt;mappers&gt; &lt;!--&lt;package name=\"mapper\"/&gt;--&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;mapper resource=\"mapper/RoleMapper.xml\"/&gt; &lt;mapper resource=\"mapper/VehicleMapper.xml\"/&gt;&lt;/mappers&gt; properties属性文件123456jdbc.driver= com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://120.79.167.xxx:3306/mybatis ?useUnicode=true&amp;characterEncoding=UTF-8 &amp;allowMultiQueries=true&amp;autoReconnect=true&amp;useSSL=falsejdbc.username = rootjdbc.password = root UserMapper接口文件123public interface UserMapper { User findUserWithRolesByUserId(Integer id);} UserMapper.xml接口文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ooyhao.mybatis3.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultWithRole\" type=\"com.ooyhao.mybatis3.bean.User\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\"/&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/&gt; &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/&gt; &lt;result column=\"phone\" jdbcType=\"VARCHAR\" property=\"phone\"/&gt; &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/&gt; &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;collection property=\"roles\" ofType=\"role\" column=\"id\" select=\"selectRole\" /&gt; &lt;/resultMap&gt; &lt;resultMap id=\"selectRole\" type=\"role\"&gt; &lt;id column=\"cid\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/&gt; &lt;result column=\"description\" jdbcType=\"VARCHAR\" property=\"description\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findUserWithRolesByUserId\" resultMap=\"BaseResultWithRole\"&gt; select a.id,a.user_id,a.username,a.password,a.email,a.phone,a.gender, a.birthday,a.status,a.create_time,a.create_user,a.modify_time,a.create_user from tb_user a where a.id = #{id} &lt;/select&gt; &lt;select id=\"selectRole\" resultType=\"role\" &gt; select b.* from tb_user_role a left join tb_role b on a.role_id = b.id where a.user_id = #{id} &lt;/select&gt;&lt;/mapper&gt; 单元测试123456789101112131415161718192021public class UserTest { SqlSession sqlSession = null; @Before public void init(){ String resource = \"mybatis-configuration.xml\"; InputStream inputStream = UserTest.class.getClassLoader().getResourceAsStream(resource); sqlSession = new SqlSessionFactoryBuilder().build(inputStream).openSession(true); } @Test public void findUserWithRolesByUserId(){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.findUserWithRolesByUserId(1); System.out.println(JSONObject.toJSONString(user)); sqlSession.close(); }} 测试结果 总结​ 这一节仅仅通过JDBC和Mybatis的操作比较，来引出Mybatis，初一看，可能会觉得Mybatis配置文件很繁琐，但是当我们书写多个SQL之后，就会觉得Mybatis仅仅是在第一次配置有些繁琐，后面书写SQL会很方便，而使用JDBC方式，每次写sql都会连带着5，60%的与业务无关的代码 ，而且每次都写的是一样的，比如获取Connection，获取Statement，关闭资源。 源码地址： https://gitee.com/ooyhao/JavaRepo_Public/tree/master/Mybatis","link":"/2020/01/18/SSM/mybatis/1Mybatis%E7%9A%84%E5%88%9D%E6%AC%A1%E9%81%87%E8%A7%81/"},{"title":"九、整合PageHelper实现分页","text":"由于为了后续使用SpringBoot，本人还是推荐使用Java配置类来操作，但是这里还是提一下XML配置。（本文项目基于第六节Mybatis集成Spring操作） XML配置方式使用XML文件来配置Mybatis的PageHelper分页插件： mybatis-configuration:(mybatis的全局配置文件) 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置开启自动匹配驼峰--&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; &lt;!--配置PageHelper分页插件拦截器--&gt; &lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;property name=\"offsetAsPageNum\" value=\"true\"/&gt; &lt;property name=\"helperDialect\" value=\"mysql\"/&gt; &lt;property name=\"rowBoundsWithCount\" value=\"true\"/&gt; &lt;property name=\"reasonable\" value=\"true\"/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; Java配置类方式完整的配置类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@Configuration //标注为一个配置类@PropertySource(value = \"classpath:application.properties\") //加载属性文件@ComponentScan(basePackages = \"com.ooyhao.mybatis\") //组件扫描@MapperScan(basePackages = {\"com.ooyhao.mybatis.mapper\"}) //mapper文件的扫描@EnableTransactionManagement //开启事务管理public class AppConfig { @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.driver}\") private String driverClassName; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password; @Value(\"${mybatis.configuration}\") private String mybatisConfiguration; @Value(\"${mybatis.mapperLocations}\") private String mybatisMapperLocations; @Value(\"${mybatis.typeAliasesPackage}\") private String mybatisTypeAliasesPackage; /*配置数据源*/ @Bean public DataSource dataSource(){ DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(url); druidDataSource.setDriverClassName(driverClassName); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; } @Bean public PageInterceptor pageInterceptor(){ PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); /*4.0.0版本之后可以不用配置*/ properties.setProperty(\"helperDialect\",\"mysql\"); /*默认为false，会将RowBounds第一个参数offset当成pageNum页面使用 * 和startPage中的pageNum效果一样*/ properties.setProperty(\"offsetAsPageNum\",\"true\"); /*RowBounds方式是否做count查询 默认false*/ properties.setProperty(\"rowBoundsWithCount\",\"true\"); /*分页合理化，true开启，如果分页参数不合理会自动修正。默认false不启用*/ properties.setProperty(\"reasonable\",\"true\"); /*是否允许接口方法参数来传递分页参数 默认false*/ properties.setProperty(\"supportMethodsArguments\",\"true\"); pageInterceptor.setProperties(properties); /*当设置为true的时候，如果pageSize设置为0（或RowBounds的limit=0），就不执行分页*/ properties.setProperty(\"pageSizeZero\",\"true\"); return pageInterceptor; } /*Mybatis的全局配置*/ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) throws Exception { SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); /*配置Mybatis的全局配置文件*/ ClassPathResource resource = new ClassPathResource(mybatisConfiguration); sqlSessionFactoryBean.setConfigLocation(resource); /*配置Mapper.xml文件的路径*/ PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource[] resources = resolver.getResources(mybatisMapperLocations); sqlSessionFactoryBean.setMapperLocations(resources); /*配置别名包*/ sqlSessionFactoryBean.setTypeAliasesPackage(mybatisTypeAliasesPackage); /*设置数据源，位置有要求，需要在下面几项之前*/ sqlSessionFactoryBean.setDataSource(dataSource); /*将PageHelper分页插件以拦截器的形式配置*/ sqlSessionFactoryBean.setPlugins(new Interceptor[]{pageInterceptor()}); /*配置驼峰命名*/ sqlSessionFactoryBean.getObject().getConfiguration().setMapUnderscoreToCamelCase(true); /*配置日志类*/ sqlSessionFactoryBean.getObject().getConfiguration().setLogImpl(StdOutImpl.class); /*设置开启缓存*/ sqlSessionFactoryBean.getObject().getConfiguration().setCacheEnabled(true); return sqlSessionFactoryBean; } /*配置数据源事务管理器，需要将数据源注入*/ @Bean public DataSourceTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; }} 提示： 添加了PageInterceptor 组件 通过 sqlSessionFactoryBean.setPlugins(new Interceptor[]{pageInterceptor()});设置到SqlSessionFactoryBean中 开启了这个properties.setProperty(&quot;supportMethodsArguments&quot;,&quot;true&quot;);则表示可以通过Mapper来进行参数传递，实现分页，如下： 1List&lt;Role&gt; findByPage(@Param(\"pageNum\") int pageNum,@Param(\"pageSize\") int pageSize); xml文件不需要修改，只需要在参数上添加形参即可。 PageHelper的PageInterceptor的参数说明：一下是PageParams类中的setProperties方法的源码： 12345678910111213141516171819202122232425public void setProperties(Properties properties) { //offset作为PageNum使用 String offsetAsPageNum = properties.getProperty(\"offsetAsPageNum\"); this.offsetAsPageNum = Boolean.parseBoolean(offsetAsPageNum); //RowBounds方式是否做count查询 String rowBoundsWithCount = properties.getProperty(\"rowBoundsWithCount\"); this.rowBoundsWithCount = Boolean.parseBoolean(rowBoundsWithCount); //当设置为true的时候，如果pagesize设置为0（或RowBounds的limit=0），就不执行分页 String pageSizeZero = properties.getProperty(\"pageSizeZero\"); this.pageSizeZero = Boolean.parseBoolean(pageSizeZero); //分页合理化，true开启，如果分页参数不合理会自动修正。默认false不启用 String reasonable = properties.getProperty(\"reasonable\"); this.reasonable = Boolean.parseBoolean(reasonable); //是否支持接口参数来传递分页参数，默认false String supportMethodsArguments = properties.getProperty(\"supportMethodsArguments\"); this.supportMethodsArguments = Boolean.parseBoolean(supportMethodsArguments); //默认count列 String countColumn = properties.getProperty(\"countColumn\"); if(StringUtil.isNotEmpty(countColumn)){ this.countColumn = countColumn; } //当offsetAsPageNum=false的时候，不能 //参数映射 PageObjectUtil.setParams(properties.getProperty(\"params\"));} 测试： 下面是测试结果，以及获取PageInfo中的各个参数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class AppTest { AnnotationConfigApplicationContext context = null; @Before public void init(){ context = new AnnotationConfigApplicationContext(AppConfig.class); } @Test public void testFindByPage(){ RoleService bean = context.getBean(RoleService.class); /*是否需要计算总条数*/ List&lt;Role&gt; page = bean.findByPage(2, 2, true); PageInfo&lt;Role&gt; pageInfo = new PageInfo&lt;&gt;(page); //返回的是Page对象，Page是ArrayList的子类。由于Page重写了toString方法 List&lt;Role&gt; list = pageInfo.getList(); System.out.println(JSONObject.toJSONString(list)); System.out.println(JSONObject.toJSON(list)); //SQL查询的数据总条数 System.out.println(\"total:\"+pageInfo.getTotal());//22 //总分页数 System.out.println(\"pages:\"+pageInfo.getPages());//8 //自动生成一个分页导航，大小为8（如果满足）[1, 2, 3, 4, 5, 6, 7, 8] System.out.println(\"navigatepageNums:\"+Arrays.toString(pageInfo.getNavigatepageNums())); //分页导航的第一页 System.out.println(\"navigateFirstPage:\"+pageInfo.getNavigateFirstPage());//1 //分页导航的最后一页 System.out.println(\"navigateLastPage:\"+pageInfo.getNavigateLastPage());//8 //分页导航的总页数 System.out.println(\"navigatePages:\"+pageInfo.getNavigatePages());//8 //当前页 System.out.println(\"pageNum:\"+pageInfo.getPageNum());//2 //当前页的上一页 System.out.println(\"prePage:\"+pageInfo.getPrePage());//1 //当前页的下一页 System.out.println(\"nextPage:\"+pageInfo.getNextPage());//3 //每页的数据条数 System.out.println(\"pageSize:\"+pageInfo.getPageSize());//3 //当前页的开始行号 System.out.println(\"startRow:\"+pageInfo.getStartRow());//4 //当前页的结束行号 System.out.println(\"endRow:\"+pageInfo.getEndRow());//6 }} 提示: List list = pageInfo.getList();我们通过打印这个list对象是无法正常打印出Role对象的数据，是因为Page对象继承自ArrayList，并且重写了toString方法。我们可以通过迭代循环打印出来。如下图: ​ 这里由于循环打印才能看到Role对象的真实面部，个人觉得麻烦，所以使用了fastJson格式化为Json，但是发现一个之前没有留意的问题： ​ 通过上面打印出的结果可以发现，list既然是Page对象，但是我们可以看到Page类中有诸多属性，为何通过JSON格式化工具之后，就没有了呢？通过查询fastJson的toJson源码就可以发现奥秘了，如下： 123456789101112131415public static Object toJSON(Object javaObject, SerializeConfig config) { ...... if (javaObject instanceof Collection) { Collection&lt;Object&gt; collection = (Collection&lt;Object&gt;) javaObject; JSONArray array = new JSONArray(collection.size()); for (Object item : collection) { Object jsonValue = toJSON(item, config); array.add(jsonValue); } return array; } ...... String text = JSON.toJSONString(javaObject); return JSON.parse(text);} ​ 里面有这样一个判断，如果对象是Collection或其子类，则强转为Collection，所以我们会发现，在使用JSONObject.toJson或是toJsonString的时候，不管是ArrayList还是Page中的属性都没有了，这是因为取的是Collection。对于数据存储，需要进一步研究Collection系列集合，暂不涉及。 Page对象源码下面我们看一下Page对象源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354public class Page&lt;E&gt; extends ArrayList&lt;E&gt; implements Closeable { private static final long serialVersionUID = 1L; /** * 页码，从1开始 */ private int pageNum; /** * 页面大小 */ private int pageSize; /** * 起始行 */ private int startRow; /** * 末行 */ private int endRow; /** * 总数 */ private long total; /** * 总页数 */ private int pages; /** * 包含count查询 */ private boolean count = true; /** * 分页合理化 */ private Boolean reasonable; /** * 当设置为true的时候，如果pagesize设置为0（或RowBounds的limit=0），就不执行分页，返回全部结果 */ private Boolean pageSizeZero; /** * 进行count查询的列名 */ private String countColumn; /** * 排序 */ private String orderBy; /** * 只增加排序 */ private boolean orderByOnly; public Page() { super(); } public Page(int pageNum, int pageSize) { this(pageNum, pageSize, true, null); } public Page(int pageNum, int pageSize, boolean count) { this(pageNum, pageSize, count, null); } private Page(int pageNum, int pageSize, boolean count, Boolean reasonable) { super(0); if (pageNum == 1 &amp;&amp; pageSize == Integer.MAX_VALUE) { pageSizeZero = true; pageSize = 0; } this.pageNum = pageNum; this.pageSize = pageSize; this.count = count; calculateStartAndEndRow(); setReasonable(reasonable); } /** * int[] rowBounds * 0 : offset * 1 : limit */ public Page(int[] rowBounds, boolean count) { super(0); if (rowBounds[0] == 0 &amp;&amp; rowBounds[1] == Integer.MAX_VALUE) { pageSizeZero = true; this.pageSize = 0; } else { this.pageSize = rowBounds[1]; this.pageNum = rowBounds[1] != 0 ? (int) (Math.ceil(((double) rowBounds[0] + rowBounds[1]) / rowBounds[1])) : 0; } this.startRow = rowBounds[0]; this.count = count; this.endRow = this.startRow + rowBounds[1]; } public List&lt;E&gt; getResult() { return this; } public int getPages() { return pages; } public Page&lt;E&gt; setPages(int pages) { this.pages = pages; return this; } public int getEndRow() { return endRow; } public Page&lt;E&gt; setEndRow(int endRow) { this.endRow = endRow; return this; } public int getPageNum() { return pageNum; } public Page&lt;E&gt; setPageNum(int pageNum) { //分页合理化，针对不合理的页码自动处理 this.pageNum = ((reasonable != null &amp;&amp; reasonable) &amp;&amp; pageNum &lt;= 0) ? 1 : pageNum; return this; } public int getPageSize() { return pageSize; } public Page&lt;E&gt; setPageSize(int pageSize) { this.pageSize = pageSize; return this; } public int getStartRow() { return startRow; } public Page&lt;E&gt; setStartRow(int startRow) { this.startRow = startRow; return this; } public long getTotal() { return total; } public void setTotal(long total) { this.total = total; if (total == -1) { pages = 1; return; } if (pageSize &gt; 0) { pages = (int) (total / pageSize + ((total % pageSize == 0) ? 0 : 1)); } else { pages = 0; } //分页合理化，针对不合理的页码自动处理 if ((reasonable != null &amp;&amp; reasonable) &amp;&amp; pageNum &gt; pages) { pageNum = pages; calculateStartAndEndRow(); } } public Boolean getReasonable() { return reasonable; } public Page&lt;E&gt; setReasonable(Boolean reasonable) { if (reasonable == null) { return this; } this.reasonable = reasonable; //分页合理化，针对不合理的页码自动处理 if (this.reasonable &amp;&amp; this.pageNum &lt;= 0) { this.pageNum = 1; calculateStartAndEndRow(); } return this; } public Boolean getPageSizeZero() { return pageSizeZero; } public Page&lt;E&gt; setPageSizeZero(Boolean pageSizeZero) { if (pageSizeZero != null) { this.pageSizeZero = pageSizeZero; } return this; } public String getOrderBy() { return orderBy; } public &lt;E&gt; Page&lt;E&gt; setOrderBy(String orderBy) { this.orderBy = orderBy; return (Page&lt;E&gt;) this; } public boolean isOrderByOnly() { return orderByOnly; } public void setOrderByOnly(boolean orderByOnly) { this.orderByOnly = orderByOnly; } /** * 计算起止行号 */ private void calculateStartAndEndRow() { this.startRow = this.pageNum &gt; 0 ? (this.pageNum - 1) * this.pageSize : 0; this.endRow = this.startRow + this.pageSize * (this.pageNum &gt; 0 ? 1 : 0); } public boolean isCount() { return this.count; } public Page&lt;E&gt; setCount(boolean count) { this.count = count; return this; } /** * 设置页码 * * @param pageNum * @return */ public Page&lt;E&gt; pageNum(int pageNum) { //分页合理化，针对不合理的页码自动处理 this.pageNum = ((reasonable != null &amp;&amp; reasonable) &amp;&amp; pageNum &lt;= 0) ? 1 : pageNum; return this; } /** * 设置页面大小 * * @param pageSize * @return */ public Page&lt;E&gt; pageSize(int pageSize) { this.pageSize = pageSize; calculateStartAndEndRow(); return this; } /** * 是否执行count查询 * * @param count * @return */ public Page&lt;E&gt; count(Boolean count) { this.count = count; return this; } /** * 设置合理化 * * @param reasonable * @return */ public Page&lt;E&gt; reasonable(Boolean reasonable) { setReasonable(reasonable); return this; } /** * 当设置为true的时候，如果pagesize设置为0（或RowBounds的limit=0），就不执行分页，返回全部结果 * * @param pageSizeZero * @return */ public Page&lt;E&gt; pageSizeZero(Boolean pageSizeZero) { setPageSizeZero(pageSizeZero); return this; } /** * 指定 count 查询列 * * @param columnName * @return */ public Page&lt;E&gt; countColumn(String columnName) { this.countColumn = columnName; return this; } /** * 转换为PageInfo * * @return */ public PageInfo&lt;E&gt; toPageInfo() { PageInfo&lt;E&gt; pageInfo = new PageInfo&lt;E&gt;(this); return pageInfo; } public &lt;E&gt; Page&lt;E&gt; doSelectPage(ISelect select) { select.doSelect(); return (Page&lt;E&gt;) this; } public &lt;E&gt; PageInfo&lt;E&gt; doSelectPageInfo(ISelect select) { select.doSelect(); return (PageInfo&lt;E&gt;) this.toPageInfo(); } public long doCount(ISelect select) { this.pageSizeZero = true; this.pageSize = 0; select.doSelect(); return this.total; } public String getCountColumn() { return countColumn; } public void setCountColumn(String countColumn) { this.countColumn = countColumn; } @Override public String toString() { return \"Page{\" + \"count=\" + count + \", pageNum=\" + pageNum + \", pageSize=\" + pageSize + \", startRow=\" + startRow + \", endRow=\" + endRow + \", total=\" + total + \", pages=\" + pages + \", reasonable=\" + reasonable + \", pageSizeZero=\" + pageSizeZero + '}'; } @Override public void close() { PageHelper.clearPage(); }}","link":"/2020/01/18/SSM/mybatis/9Mybatis%E6%95%B4%E5%90%88PageHelper/"},{"title":"一、初识Spring","text":"本篇主要是简单的尝试一下Spring的两大功能，来感受一下Spring的强大，后面将进行更加详细的介绍。 spring的两大功能​ 我们都知道，Spring两大核心功能就是控制反转/依赖注入、面向切面编程。下面介绍一下两大功能。 IoC/DI Don’t call me , I will call you! 控制反转(Inversion of Control)/依赖注入(Dependency Injection)，简称IoC/DI. 控制反转不是一种技术，而是一种设计思想：将原来程序需要什么对象自己创建 转变为 需要什么对象向IoC容器获取，创建对象的工作由原来程序自身控制，反转到了由IoC容器进行创建。把相关的控制权进行了反转，反转给了Spring IoC容器。 DI：Dependency Injection。即依赖注入。对象(组件)之间的依赖关系由IoC容器来进行决定。 比如： ​ 在UserController中需要调用UserService(暂不考虑接口设计)。则在UserController中需要其自身通过new来创建UserService对象。 如下： UserService: 1234567891011public class UserService{ private PrintStream printStream; public UserService(PrintStream printStream){ this.printStream = printStream; } public void sayHello(){ printStream.println(\"sayHello!\") }} UserController: 1234567891011public class UserController{ private UserService userService; public UserController(){ this.userService = new UserService(System.out); } public void sayHi(){ userService.sayHello(); } } ​ 在Spring中，程序的对象控制权由其自身反转到了Spring容器，也就是不需要应用程序来new对象。既然不需要应用程序自身来创建Bean了，那么程序在运行的过程中，Bean从何而来呢？此时就是DI的show time了。 ​ Spring中的DI正是来实现IoC的一种方式：Spring容器负责维护对象(Bean)之间的依赖关系，并通过DI来向对象中注入其所依赖的对象。 Xml方式下面使用Spring的方式来设计: 123456789101112131415161718192021222324public class UserService{ private PrintStream printStream; public UserService(PrintStream printStream){ this.printStream = printStream; } public void sayHello(){ printStream.println(\"sayHello!\") }}public class UserController{ private UserService userService; public UserController(UserService userService){ this.userService = userService; } public void sayHi(){ userService.sayHello(); }} spring.xml文件： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userService\" class=\"com.ooyhao.spring.bean.UserService\"&gt; &lt;constructor-arg value=\"#{T(System).out}\"/&gt; &lt;/bean&gt; &lt;bean id=\"UserController\" class=\"com.ooyhao.spring.bean.UserController\"&gt; &lt;constructor-arg ref=\"userService\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类： 123456public void testXml(){ ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"spring.xml\"); UserController userController = ctx.getBean(UserController.class); userController.sayHi();} ​ 如果需要面向接口设计的话，接口由于无法实例化，所以在编码的时候必须指定具体的实现类，如此一来，导致无法自由动态的切换实现类,耦合度太高。而Spring xml方式的话，实现类松耦合，简化了开发，后期如果需要修改的话，直接修改xml文件，不用修改代码。 Java配置类方式SpringConfig配置类： 123456789101112131415public class SpringConfig{ @Bean public UserService userService(){ UserService userService = new UserService(System.out); return userService; } @Bean public UserController userController(){ UserController userController = new UserController(userService()); return userController; } } 测试类： 123456public void testJavaConfig(){ AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); UserController userController = ctx.getBean(UserController.class); userController.sayHi();} ​确实Spring xml文件实现了松耦合，但是实际项目中可以发现，往往xml很少修改。所以，SpringBoot又主张Java配置类的方式，但是Java配置类的绝大部分都是由Spring xml转化过来的。所以，不管是Java配置类方式还是Spring xml文件方式都有必要了解，当然我觉得，由于为了后期更好的学习和使用SpringBoot，可以以Java配置类方式为主。 AOP 参考自：阿古拉斯啦啦 https://blog.csdn.net/q982151756/article/details/80513340 ​ Aop：是Aspect oriented Programming的缩写，即面向切面编程。通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP(面向切面编程)是OOP(面向对象编程)的一种补充，而不是一种替代品。利用AOP可以对业务逻辑的各个部分进行隔离，从而降低各个模块之间的耦合度，简化维护。常见使用AOP的场景：事务控制，日志管理，权限控制等等。 Aop简单介绍下面先用几张图熟悉一下AOP是怎么回事。（图片来源于网络） 从图中可以看出：不管是 【获取活动相关数据】还是 【根据条件活动奖励发放】都需要先【检测活动有效性】和【检测活动是否需要登录】这两步操作。 可以将【检测活动有效性】和【检测活动是否需要登录】两部操作封装到一个方法，然后在两个不同的业务中进行调用，但是这样虽然重用了代码，但是还是将两步不是必须耦合在一起的代码耦合在了一起。 而第三幅图则使用了AOP的思想，将【检测活动有效性】和【检测活动是否需要登录】两个操作封装到一个单独的类（切面）。只需要在需要执行的地方，进行切入即可达到前面一样的效果。这样最大程度的降低了模块之间的耦合度。 Aop中的术语 Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。 Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。 Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。 Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。 Target（目标对象）：织入 Advice 的目标对象.。 Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程 举一个容易理解的例子​ 看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的. 下面我以一个简单的例子来比喻一下 AOP 中 Aspect, Joint point, Pointcut 与 Advice之间的关系.​ 让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来. ​ 来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.首先我们知道, 在 Spring AOP 中 Joint point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 Joint point, 通过 point cut, 我们就可以确定哪些 Joint point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问. 为什么可以这样类比呢? Join point ： 爪哇的小县城里的百姓: 因为根据定义, Join point 是所有可能被织入 Advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 Joinpoint. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人. Pointcut ：男性, 身高约七尺五寸: 我们知道, 所有的方法(joinpoint) 都可以织入 Advice, 但是我们并不希望在所有方法上都织入 Advice, 而 Pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问. Advice ：抓过来审问, Advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓. Aspect:：Aspect 是 pointcut 与 Advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” 这一整个动作可以被认为是一个 Aspect. 其他的一些内容AOP中的Joinpoint可以有多种类型：构造方法调用，字段的设置和获取，方法的调用，方法的执行，异常的处理执行，类的初始化。也就是说在AOP的概念中我们可以在上面的这些Joinpoint上织入我们自定义的Advice，但是在Spring中却没有实现上面所有的joinpoint，确切的说，Spring只支持方法执行类型的Joinpoint。 Advice 的类型 before advice, 在 join point前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码) after return advice, 在一个 join point 正常返回后执行的 advice after throwing advice, 当一个 join point 抛出异常后执行的 advice after(final) advice, 无论一个 join point是正常退出还是发生了异常, 都会被执行的 advice. around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice. introduction，introduction可以为原有的对象增加新的属性和方法。 在Spring中，通过动态代理和动态字节码技术实现了AOP，这些内容，我们将在以后进行讲解。 下面分别使用XML和Java配置类实现AOP XmlAOP方式目标类： 123456789101112public class Person { public String sayHello(){ System.out.println(\"Person say Hello!\"); return \"sayHelloMethod\"; } public String sayBye(){ System.out.println(\"Person say ByeBye!\"); return \"sayByeMethod\"; }} 切面类： 123456789101112131415161718192021222324252627282930public class XmlLoggerAspect { public void before(){ System.out.println(\"---&gt;before\"); } public void after(){ System.out.println(\"---&gt;after\"); } public void afterReturning(Object returnVal){ System.out.println(\"---&gt;afterReturning : \" + returnVal); } public void afterThrowing(Exception exception){ System.out.println(\"---&gt;afterTrowing:\"+exception.getMessage()); } public Object around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"---&gt;around before\"); Object proceed = joinPoint.proceed(); System.out.println(\"around result : \"+proceed); System.out.println(\"---&gt;around after\"); return proceed; }} xml配置文件： 12345678910111213141516171819202122232425262728293031323334&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--业务类Target--&gt; &lt;bean id=\"person\" class=\"com.ooyhao.spring.aop.Person\"/&gt; &lt;!--切面类--&gt; &lt;bean id=\"loggerAspect\" class=\"com.ooyhao.spring.aspect.XmlLoggerAspect\"/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"loggerAspect\"&gt; &lt;!--public String com.ooyhao.spring.aop.Person.sayHello() * String com.ooyhao.spring.aop.Person.sayHello() * com.ooyhao.spring.aop.Person.sayHello() * *.sayHello() * *.say*() * *.say*(..) --&gt; &lt;aop:pointcut id=\"pointCut\" expression=\"execution(* *.say*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointCut\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"pointCut\"/&gt; &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"pointCut\" returning=\"returnVal\"/&gt; &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"pointCut\" throwing=\"exception\"/&gt; &lt;aop:around method=\"around\" pointcut-ref=\"pointCut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void testXmlAop(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-aop.xml\"); Person bean = context.getBean(Person.class); bean.sayHello(); System.out.println(\"=================\"); bean.sayBye(); /** * * ---&gt;before * ---&gt;around before * Person say Hello! * around result : sayHelloMethod * ---&gt;around after * ---&gt;afterReturning : sayHelloMethod * ---&gt;after * ================= * ---&gt;before * ---&gt;around before * Person say ByeBye! * around result : sayByeMethod * ---&gt;around after * ---&gt;afterReturning : sayByeMethod * ---&gt;after */ //sayHello出现 int i = 1/0;时 /** * * ---&gt;before * ---&gt;around before * Person say Hello! * ---&gt;afterTrowing:/ by zero * ---&gt;after * * java.lang.ArithmeticException: / by zero * at com.ooyhao.spring.aop.Person.sayHello(Person.java:7) * * */} 由上测试结果可以看出： 正常执行的执行过程 before – &gt; around before –&gt; target method –&gt; around after –&gt; afterReturning –&gt; after 出现异常的执行过程 before –&gt; around before –&gt; target method –&gt; afterTrowing –&gt; after Java配置类方式java配置方式的切面： 12345678910111213141516171819202122232425262728293031323334353637@Aspect@Component@EnableAspectJAutoProxypublic class ConfigLoggerAspect { @Pointcut(\"execution(**.say*()))\") public void pointCut(){} @Before(\"pointCut()\") public void before(){ System.out.println(\"---&gt;before\"); } @After(\"pointCut()\") public void after(){ System.out.println(\"---&gt;after\"); } @AfterReturning(value = \"pointCut()\", returning = \"returnVal\") public void afterReturning(Object returnVal){ System.out.println(\"---&gt;afterReturning : \" + returnVal); } @AfterThrowing(value = \"pointCut()\", throwing = \"exception\") public void afterThrowing(Exception exception){ System.out.println(\"---&gt;afterTrowing:\"+exception.getMessage()); } @Around(value = \"pointCut()\") public Object around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"---&gt;around before\"); Object proceed = joinPoint.proceed(); System.out.println(\"around result : \"+proceed); System.out.println(\"---&gt;around after\"); return proceed; }} @Aspect: 定义为一个切面 @Component：定义为一个Spring组件 @EnableAspectJAutoProxy：开启Aop自动代理模式 Java配置类： 12345678@ComponentScan(basePackages = \"com.ooyhao.spring\")public class AopConfig { @Bean public Person person(){ return new Person(); }} @ComponentScan(basePackages = &quot;com.ooyhao.spring&quot;): 将前面的切面进行扫描成组件。 测试类： 12345678910@Testpublic void testJavaConfigAop(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AopConfig.class); Person bean = context.getBean(Person.class); bean.sayHello(); bean.sayBye();} 提示: ​ 前面均使用的是AspectJ表达式，这样可以定位到有一定规律的目标方法，降低程序耦合，但是操作不是特别灵活，个人比较使用注解方式，可以指定到某一个目标方法。 @pointcut(&quot;@annotation(com.sample.security.AdminOnly)&quot;) // 匹配注解有AdminOnly注解的方法","link":"/2020/01/29/SSM/spring4x/1%E5%88%9D%E8%AF%86pring/"},{"title":"四、面向切面的Spring","text":"面向切面的Spring Aop 的概念Aop ：Aspect oriented Programming 面向切面编程，面向切面编程是面向对象编程的补充，而不是替代品。在运行时，动态地将代码切入到类的指定方法，指定位置上的编程思想就是面向切面编程。 Aop中的术语通知（Advice）​ 通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前或是之后都调用？还是只在方法抛出异常时调用？ Spring切面可以应用的切面有五种： 前置通知（Before）：在目标方法被调用之前调用通知方法。 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么。 返回通知（After-Returning）：在目标方法成功执行之后调用通知。 异常通知（After-Throwing）：在目标方法抛出异常之后调用通知。 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 切面（Aspect）​ Aspect声明类似与Java中类的声明，在Aspect中包含着一些Pointcut以及相应的 Advice。 连接点（Joint Point）​ 表示在程序中明确定义的点，典型的包括方法的调用，属性的修改，对类成员的访问以及异常处理程序块的执行等。它自身还可以嵌套其他的Joint Point。 切点（PointCut）​ 表示一组符合要求的Joint Point， 这些Joint Point 或是通过逻辑关系组合起来，或是通过通配，正则表达式等方法集中起来，它定义了相应的Advice将要发生的地方。 目标对象（Target）​ 织入Advice的目标对象。 织入（Weaving）​ 将Apsect和其他对象连接起来，并创建Adviced Object的过程。 案例解释术语​ 看到上面的术语其实非常的头痛，不知所云，那么下面用一个比较容易理解的例子来说明上述概念：（摘自网上 https://blog.csdn.net/q982151756/article/details/80513340） 下面我以一个简单的例子来比喻一下 AOP 中 Aspect, Joint point, Pointcut 与 Advice之间的关系.​ 让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来. 来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.​ 首先我们知道, 在 Spring AOP 中 Joint point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 Joint point, 通过 point cut, 我们就可以确定哪些 Joint point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, Joint point 就相当于 爪哇的小县城里的百姓,pointcut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 Advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问.为什么可以这样类比呢? Join point ： 爪哇的小县城里的百姓: 因为根据定义, Joint point 是所有可能被织入 Advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 Joint point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人. Pointcut ：男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 Advice, 但是我们并不希望在所有方法上都织入 Advice, 而 Pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问. Advice ：抓过来审问, Advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 Joint point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓. Aspect：Aspect 是 point cut 与 Advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” 这一整个动作可以被认为是一个 Aspect. AspectJ指示器 可参考官方文档： https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#aop-aspectj-support 切入点表达式解释： AspectJ注解 注解 通知 @After 通知方法会在目标方法返回或抛出异常后调用 @AfterReturning 通知方法会在目标方法返回后调用 @AfterThrowing 通知方法会在目标方法抛出异常后调用 @Around 通知方法会将目标方法包裹起来 @Before 通知方法会再目标方法调用之前执行 Aop配置元素spring的Aop配置元素能够以非侵入性的方式声明切面 Aop配置元素 用途 aop:advisor 定义Aop通知器 aop:after 定义Aop后置通知（不管被通知的方法是否成功执行） aop:after-returning 定义Aop返回通知 aop:after-throwing 定义Aop异常通知 aop:around 定义Aop环绕通知 aop:aspect 定义一个切面 aop:aspectj-autopoxy 启用@Aspect注解驱动的切面 aop:before 定义Aop前置通知 aop:config 顶层的Aop配置元素，大多数的aop:*元素必须包含在aop:config元素类 aop:pointcut 定义一个切点 Java注解方式实现Aop表演接口： 123public interface Performance { String perform();} 音乐表演： 123456789/**音乐表演*/@Componentpublic class MusicPerformance implements Performance { public String perform() { System.out.println(\"&gt;&gt;&gt;&gt;&gt;演员正在表演进行音乐演唱&lt;&lt;&lt;&lt;&lt;\"); //int i = 1/0; return \"MusicPerformance\"; }} 切面定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ooyhao.spring.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 描述: * 类【PerformanceAspect】 * * @author 阳浩 * @create 2019-08-29 17:55 *//*使用注解版*/@Aspect@Componentpublic class PerformanceAspect { @Pointcut(\"execution(* *.perform(..))\") public void pointCut(){} @Before(\"pointCut()\") public void offPhone(){ System.out.println(\"将手机关机或调为静音\"); } @After(\"pointCut()\") public void clean(){ System.out.println(\"清理座位旁边的垃圾\"); } @Around(value = \"pointCut()\") public Object writeInfo(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"记录表演人员信息和歌曲名称\"); Object result = joinPoint.proceed(); System.out.println(\"记录表演时间！\"); return result; } @AfterThrowing(value = \"pointCut()\", throwing = \"exception\") public void refund(JoinPoint joinPoint, Exception exception){ System.out.println(exception.getMessage()); System.out.println(\"观看不满意，要求退款\"); } @AfterReturning(value = \"pointCut()\" , returning = \"result\") public void applause(JoinPoint joinPoint,Object result){ System.out.println(\"result:\"+result); System.out.println(\"起身并鼓掌\"); }} 测试类以测试结果： 123456789101112131415161718@Testpublic void testJavaConfigAop(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AopConfig.class); Performance bean = context.getBean(Performance.class); System.out.println(bean); bean.perform();}/*记录表演人员信息和歌曲名称将手机关机或调为静音&gt;&gt;&gt;&gt;&gt;演员正在表演进行音乐演唱&lt;&lt;&lt;&lt;&lt;记录表演时间！清理座位旁边的垃圾result:MusicPerformance起身并鼓掌*/ 由上述的测试结果可以看出，通知的执行流程是： 当出现异常时： 目标方法执行时出现异常： 12345678@Componentpublic class MusicPerformance implements Performance { public void perform() { System.out.println(\"&gt;&gt;&gt;&gt;&gt;演员正在表演进行音乐演唱&lt;&lt;&lt;&lt;&lt;\"); int i = 1/0; }} 异常时执行结果： 1234567记录表演人员信息和歌曲名称将手机关机或调为静音&gt;&gt;&gt;&gt;&gt;演员正在表演进行音乐演唱&lt;&lt;&lt;&lt;&lt;清理座位旁边的垃圾观看不满意，要求退款java.lang.ArithmeticException: / by zero 由上述两个流程图可以看出： 正常情况时： 环绕通知目标方法前–&gt;前置通知–&gt;目标方法–&gt;环绕通知目标方法后–&gt;后置通知–&gt;返回通知。异常情况时： 环绕通知目标方法前–&gt;前置通知–&gt;目标方法–&gt;后置通知–&gt;异常通知。 总结： ​ 正常情况下，不会执行异常通知（AfterTrowing），异常情况下，不会执行环绕通知目标方法后的代码（Around after），也不会执行返回通知（AfterReturning）。 Xml配置方式实现Aop切面：使用Xml方式，切面就是一个普通的Java类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ooyhao.spring.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 描述: * 类【PerformanceAspect】 * * @author 阳浩 * @create 2019-08-29 17:55 *//*使用XML版*/public class PerformanceAspect { //before public void offPhone(JoinPoint joinPoint){ System.out.println(\"将手机关机或调为静音\"); } //after public void clean(JoinPoint joinPoint){ System.out.println(\"清理座位旁边的垃圾\"); } //around public Object writeInfo(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"记录表演人员信息和歌曲名称\"); Object result = joinPoint.proceed(); System.out.println(\"记录表演时间！\"); return result; } //afterTrowing public void refund(JoinPoint joinPoint, Exception exception){ System.out.println(exception.getMessage()); System.out.println(\"观看不满意，要求退款\"); } //afterReturning public void applause(JoinPoint joinPoint, Object result) { System.out.println(\"AfterReturning :result \"+result); System.out.println(\"起身并鼓掌\"); }} Xml配置文件： 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--目标对象--&gt; &lt;bean class=\"com.ooyhao.spring.bean.MusicPerformance\"/&gt; &lt;!--开启aop的自动代理--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--将切面定义为一个Bean--&gt; &lt;bean id=\"performanceAspect\" class=\"com.ooyhao.spring.aop.PerformanceAspect\"/&gt; &lt;!--通知定义--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"performanceAspect\"&gt; &lt;aop:pointcut id=\"pointCut\" expression=\"execution(* *.perform(..))\"/&gt; &lt;aop:before method=\"offPhone\" pointcut-ref=\"pointCut\"/&gt; &lt;aop:after method=\"clean\" pointcut-ref=\"pointCut\"/&gt; &lt;aop:around method=\"writeInfo\" pointcut-ref=\"pointCut\"/&gt; &lt;aop:after-returning method=\"applause\" pointcut-ref=\"pointCut\" returning=\"result\" /&gt; &lt;aop:after-throwing method=\"refund\" pointcut-ref=\"pointCut\" throwing=\"exception\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试及结果： 123456789101112131415@Testpublic void testXmlAop(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"springAop.xml\"); Performance performance = context.getBean(Performance.class); performance.perform();}/**将手机关机或调为静音记录表演人员信息和歌曲名称&gt;&gt;&gt;&gt;&gt;演员正在表演进行音乐演唱&lt;&lt;&lt;&lt;&lt;起身并鼓掌记录表演时间！清理座位旁边的垃圾*/ 注意：可以看出，使用Java配置的方式和Xml配置的方式，通知执行顺序有差异。 JoinPoint 对象JoinPointJoinPoint对象封装了SpringAop中切面方法的信息，在切面方法中添加JoinPoint参数，就可以获取到封装了该方法的JoinPoint对象。 常用API： 方法名 功能 Signature getSignature() 获取封装了署名信息的对象，在该对象中可以获取目标方法的方法名，所属类的Class等信息。 Object[] getArgs() 获取传入目标方法的参数对象 Object[] getTarget() 获取被代理的对象 Object[] getThis() 获取代理对象 ProceedingJoinPointProceedingJoinPoint 对象是JoinPoint的子接口，该对象只用在@Around的切面方法中，添加了两个方法： Object proceed() trows Trowable //执行目标方法 Object proceed(Object[] var1) throws Throwable //传入的新的参数去执行目标方法 案例说明User类： 1234public class User { private String name; private Integer age;} UserService类： 123456@Componentpublic class UserService { public void Login(User user,String authCode){ System.out.println(\"user: \"+user+\" authCode: \"+authCode); }} 切面类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Component@Aspectpublic class UserAspect { @Pointcut(\"execution(* *Login(..))\") public void pointCut(){} /** * 目标方法： * public class UserService { * * public void Login(User user,String authCode){ * System.out.println(\"user: \"+user+\" authCode: \"+authCode); * } * } * */ @Around(\"pointCut()\") public Object checkPermission(ProceedingJoinPoint joinPoint) throws Throwable {//=================joinPoint.getArgs()============================== //目标方法的入参 [User{name='张三', age=23}, 123456] Object[] args = joinPoint.getArgs(); System.out.println(Arrays.toString(args));// ================joinPoint.getSignature()========================= Signature signature = joinPoint.getSignature(); //方法名 Login String name = signature.getName(); System.out.println(name); //目标方法所在类的Class对象 class com.ooyhao.spring.service.UserService Class aClass = signature.getDeclaringType(); System.out.println(aClass); //目标方法所在类的类的权限类名 com.ooyhao.spring.service.UserService String typeName = signature.getDeclaringTypeName(); System.out.println(typeName); //目标方法的修饰符 int modifiers = signature.getModifiers(); System.out.println(modifiers);//=====================joinPoint.getTarget()=================== //被代理的目标对象 com.ooyhao.spring.service.UserService@1ba9117e Object target = joinPoint.getTarget(); System.out.println(target);//=====================joinPoint.getThis()=================== //代理对象 Object aThis = joinPoint.getThis(); System.out.println(aThis); //可以将原有调用时传入的参数进行修改 // 调用无参的方法，即表示使用调用者传入的参数。 Object obj = joinPoint.proceed(new Object[]{new User(\"李四\",24),\"123abc\"}); return obj; }} 配置类： 123@ComponentScan(basePackages = \"com.ooyhao.spring\")@EnableAspectJAutoProxypublic class UserAopConfig {} 对现有类增加方法​ 至此，SpringAop的JavaConfig配置类和Xml配置文件形式都已经学完，但是Aop中 @Before、@After、@Around、@AfterReturning、@AfterTrowing这几种通知都是只对目标类的目标方法进行增强，但是无法向目标方法注入新的方法。这么强大的Spring，肯定有相应的解决办法啦！那就是使用@DeclareParents 注解实现。 Java配置类方式学生接口： 123public interface Student { void readBook();} 学生实现类： 123456@Componentpublic class CollegeStudent implements Student { public void readBook() { System.out.println(\"我在阅读大学必修书籍！\"); }} 教师接口： 1234/*教师接口*/public interface Teacher { void speak();} 教师实现类： 12345public class EnglishTeacher implements Teacher { public void speak() { System.out.println(\"我会说英语！\"); }} 切面： 123456@Aspect@Componentpublic class StudentAspect { @DeclareParents(value = \"com.ooyhao.spring.bean.Student+\",defaultImpl = EnglishTeacher.class) private Teacher teacher;} 配置类： 123@ComponentScan(basePackages = \"com.ooyhao.spring\")@EnableAspectJAutoProxypublic class AopConfig {} 单元测试： 123456789@Testpublic void testAop(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AopConfig.class); Student bean = context.getBean(Student.class); bean.readBook(); Teacher t = (Teacher)bean; t.speak();} 结果： 解释：首先教师和学生都是一个普通的java类，切面类中依旧使用@Aspect注解来定义其为一个切面类，使用@Component标注为一个Spring组件。而在配置类中使用@ComponentScan注解用来对组件进行扫描。使用@EnableAspectJAutoProxy 开启AspectJ自动代理。 需要研究的是切面中的内容： 123@DeclareParents(value = \"com.ooyhao.spring.bean.Student+\", defaultImpl = EnglishTeacher.class)private Teacher teacher; 属性teacher表示将哪种类型声明为增加类。而使用@DeclareParents注解来声明需要增加和实际定义了增加方法的实际类。其中value表示向所有Student类及其子类增加方法，增加的方法的实际来源是在defaultImpl中定义的，即：增加的方法在EnglishTeacher中定义。并且在实际类型转化的时候，不能将测试代码中的bean强转为EnglishTeacher，只能强转为Teacher类型。 解释：@DeclareParents 注解由三部分组成： value 属性指定了哪种类型的bean要引入该接口。（标记符后面的加号，表示的是所有的子类，而不是其自身。） defaultImpl 属性指定了为引入功能提供实现的类。 @DeclareParents 注解所标注的静态属性指明了要引入的接口。 Xml配置文件方式12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--开启包的扫描--&gt; &lt;context:component-scan base-package=\"com.ooyhao.spring\"/&gt; &lt;!--声明为一个Bean，即定义了增加方法的一个类--&gt; &lt;bean id=\"englishTeacher\" class=\"com.ooyhao.spring.bean.EnglishTeacher\"/&gt; &lt;!--切面--&gt; &lt;aop:config&gt; &lt;aop:aspect&gt; &lt;aop:declare-parents types-matching=\"com.ooyhao.spring.bean.Student+\" implement-interface=\"com.ooyhao.spring.bean.Teacher\" delegate-ref=\"englishTeacher\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!--开启AspectJ的自动代理--&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 单元测试：在获取Bean的时候，下列代码中只能获取Student类型，不能获取Student实现类CollegeStudent类型的Bean。 123456789@Test public void testXmlAop(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"AopConfig.xml\"); Student bean = context.getBean(Student.class); bean.readBook(); Teacher teacher = (Teacher)bean; teacher.speak(); } 本节主要是学习SpringAop的基于Java配置和Xml配置两种方式的使用方法，以及SpringAop中五种通知做不到的，就是在目标类中添加方法，SpringAop中的五种通知只能增强方法，而不能添加方法到目标类中，SpringAop提供了另外一种解决方案：@DeclareParents.","link":"/2020/01/29/SSM/spring4x/4%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84Spring/"},{"title":"八、Spring和JDBC操作数据库","text":"Spring和JDBC操作数据库 使用JNDI配置数据源 在Tomcat服务器的conf下的context.xml 配置数据源 1234567891011&lt;Resource name=\"jdbc/mysql\" auth=\"Container\" type=\"javax.sql.DataSource\" maxActive=\"20\" maxIdle=\"5\" maxWait=\"10000\" username=\"root\" password=\"root\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://120.79.167.88:3306/oms_sys_info?useUnicode=true&amp;amp;characterEncoding=utf-8\"/&gt; 使用xml或是Java类配置 配置jndi这种情况使用xml可能更加简单。 1&lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/mysql\" resource-ref=\"true\"/&gt; 使用Java配置类 123456789101112131415161718@Configurationpublic class DataSourceConfig { @Bean public JndiObjectFactoryBean dataSource(){ JndiObjectFactoryBean bean = new JndiObjectFactoryBean(); bean.setJndiName(\"jdbc/mysql\"); bean.setResourceRef(true); bean.setProxyInterface(DataSource.class); return bean; } @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ System.out.println(dataSource); return new JdbcTemplate(dataSource); }} 使用JDNI方式访问数据库1. POM依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-10-01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-10-01 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--导入Servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入SpringMVC依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--hibernate参数校验依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.0.Alpha3&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合Thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;mchange-commons-java&lt;/artifactId&gt; &lt;version&gt;0.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-10-01&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 2. Tomcat context.xml1234567891011&lt;Resource name=\"jdbc/mysql\" auth=\"Container\" type=\"javax.sql.DataSource\" maxActive=\"20\" maxIdle=\"5\" maxWait=\"10000\" username=\"root\" password=\"root\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://120.79.167.88:3306/oms_sys_info?useUnicode=true&amp;amp;characterEncoding=utf-8\"/&gt; 我们使用JDNI来配置数据源时，我们需要在tomcat下的conf目录下的context.xml添加对应的数据源，不同的数据源所配置的信息是不一样，这里是Tomcat默认的dbcp数据源，后面有修改为c3p0的案例。 3. jdni.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/mysql\" resource-ref=\"true\"/&gt;&lt;/beans&gt; ​ jee标签，就是将tomcat的数据源引入到项目中，并且通过后面的DataSourceConfig中的@ImportResource注解将其注入到Ioc容器中。id就相当于是bean的id，而jndi-name就是对应前面到tomcat的context.xml中配置数据源的名字一致。 4. DataSourceConfig123456789@Configuration@ImportResource(value = \"classpath:jdni.xml\")public class DataSourceConfig { @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ return new JdbcTemplate(dataSource); }} ​ 这里主要是将xml配置文件引入到配置类中，因为配置jndi数据源，使用xml文件的形式更加简单一点（当然，java配置类的形式也是可以简单的实现），并且将数据源注入到JdbcTemplate，因为这一节我们简单使用Spring的JdbcTemplate来操作数据库。 5. InitWeb1234567891011121314151617181920212223public class InitWeb extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[]{ RootConfig.class }; } @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class[]{ ServletConfig.class }; } @Override protected String[] getServletMappings() { return new String[]{ \"/\" }; }} InitWeb我们应该非常熟悉了，其实就是替代了原来的Web.xml文件的角色。 6. ServletConfig1234567891011@Configuration@EnableWebMvc@ComponentScan(basePackages = \"com.ooyhao.spring.**.controller\")public class ServletConfig implements WebMvcConfigurer { @Override public void configureDefaultServletHandling( DefaultServletHandlerConfigurer configurer) { configurer.enable(); }} ServletConfig文件就是相当于之前的SpringMVC.xml。这里开启了对静态资源的访问。 7. RootConfig12345@ComponentScan(basePackages = \"com.ooyhao.spring\",useDefaultFilters = true,excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,value = Controller.class), @ComponentScan.Filter(type = FilterType.ANNOTATION,value = RestController.class)})public class RootConfig {} RootConfig则相当于是配置文件形式下的applicationContext.xml文件。 8. TbUser123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.ooyhao.spring.bean;import com.fasterxml.jackson.annotation.JsonFormat;import java.io.Serializable;import java.util.Date;/** * 描述: * 类【TbUser】 * * @author ouYangHao * @create 2019-09-10 15:49 */public class TbUser implements Serializable { private Integer id; private String userId; private String username; private String password; private String email; private String phone; private Integer gender; @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") private Date birthday; private Integer status; @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") private Date createTime; private String createUser; @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") private Date modifyTime; private String modifyUser; public TbUser() { } public TbUser(Integer id, String userId, String username, String password, String email, String phone, Integer gender, Date birthday, Integer status, Date createTime, String createUser, Date modifyTime, String modifyUser) { this.id = id; this.userId = userId; this.username = username; this.password = password; this.email = email; this.phone = phone; this.gender = gender; this.birthday = birthday; this.status = status; this.createTime = createTime; this.createUser = createUser; this.modifyTime = modifyTime; this.modifyUser = modifyUser; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } public String getCreateUser() { return createUser; } public void setCreateUser(String createUser) { this.createUser = createUser; } public Date getModifyTime() { return modifyTime; } public void setModifyTime(Date modifyTime) { this.modifyTime = modifyTime; } public String getModifyUser() { return modifyUser; } public void setModifyUser(String modifyUser) { this.modifyUser = modifyUser; } @Override public String toString() { return \"TbUser{\" + \"id=\" + id + \", userId='\" + userId + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", email='\" + email + '\\'' + \", phone='\" + phone + '\\'' + \", gender=\" + gender + \", birthday=\" + birthday + \", status=\" + status + \", createTime=\" + createTime + \", createUser='\" + createUser + '\\'' + \", modifyTime=\" + modifyTime + \", modifyUser='\" + modifyUser + '\\'' + '}'; }} 9. UserService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.ooyhao.spring.service;import com.ooyhao.spring.bean.TbUser;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Service;import java.sql.Date;import java.sql.ResultSet;import java.sql.SQLException;/** * 描述: * 类【UserService】 * * @author ouYangHao * @create 2019-09-10 15:55 */@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate; public TbUser findById(Integer id) { TbUser tbUser = jdbcTemplate.queryForObject(\"select * from tb_user where id = ? \", new Object[]{id}, new RowMapper&lt;TbUser&gt;() { @Override public TbUser mapRow(ResultSet resultSet, int i) throws SQLException { int id = resultSet.getInt(\"id\"); String userId = resultSet.getString(\"user_id\"); String username = resultSet.getString(\"username\"); String password = resultSet.getString(\"password\"); String email = resultSet.getString(\"email\"); String phone = resultSet.getString(\"phone\"); int gender = resultSet.getInt(\"gender\"); Date birthday = resultSet.getDate(\"birthday\"); int status = resultSet.getInt(\"status\"); Date createTime = resultSet.getDate(\"create_time\"); String createUser = resultSet.getString(\"create_user\"); Date modifyTime = resultSet.getDate(\"modify_time\"); String modifyUser = resultSet.getString(\"modify_user\"); TbUser user = new TbUser(); user.setId(id); user.setUserId(userId); user.setUsername(username); user.setPassword(password); user.setEmail(email); user.setPhone(phone); user.setGender(gender); user.setBirthday(birthday); user.setStatus(status); user.setCreateTime(createTime); user.setCreateUser(createUser); user.setModifyUser(modifyUser); user.setModifyTime(modifyTime); return user; } }); return tbUser; }} 这里使用了Spring的JdbcTemplate来操作数据库，这里只是简单的使用了一下，如果使用，可以进一步研究。 10. UserController1234567891011121314151617181920212223242526272829package com.ooyhao.spring.controller;import com.ooyhao.spring.bean.TbUser;import com.ooyhao.spring.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.naming.NamingException;/** * 描述: * 类【UserController】 * * @author ouYangHao * @create 2019-09-10 16:01 */@RestControllerpublic class UserController { @Autowired private UserService userService; @RequestMapping(\"/user/{id}\") public TbUser findById(@PathVariable(\"id\") Integer id) throws NamingException { return userService.findById(id); }} 11. 数据库数据 12. 测试结果 切换JDNI Tomcat默认的数据源tomcat context.xml1234567891011&lt;Resource name=\"jdbc/mysql\" auth=\"Container\" factory=\"org.apache.naming.factory.BeanFactory\" type=\"com.mchange.v2.c3p0.ComboPooledDataSource\" maxPoolSize=\"20\" minPoolSize=\"5\" user=\"root\" password=\"root\" driverClass=\"com.mysql.jdbc.Driver\" jdbcUrl=\"jdbc:mysql://120.79.167.88:3306/oms_sys_info?useUnicode=true&amp;amp;characterEncoding=utf-8\"/&gt; Java配置类配置数据源12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.ooyhao.spring.config;import com.alibaba.druid.pool.DruidDataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbcp2.BasicDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.beans.PropertyVetoException;/** * 描述: * 类【DataSourceConfig】 * * @author ouYangHao * @create 2019-09-10 15:26 */@Configurationpublic class DataSourceConfig { /*配置C3P0数据源*/ @Bean @Primary public DataSource dataSource1() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setMaxPoolSize(20); dataSource.setMinPoolSize(5); dataSource.setUser(\"root\"); dataSource.setPassword(\"root\"); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://120.79.167.88:3306/oms_sys_info?useUnicode=true&amp;amp;characterEncoding=utf-8\"); return dataSource; } /*配置Druid数据源*/ @Bean public DataSource dataSource2(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setMaxActive(20); dataSource.setMaxWait(5); dataSource.setMinIdle(5); dataSource.setInitialSize(10); dataSource.setUrl(\"jdbc:mysql://120.79.167.88:3306/oms_sys_info?useUnicode=true&amp;amp;characterEncoding=utf-8\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"root\"); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); return dataSource; } /*配置DBCP数据源*/ @Bean public DataSource dataSource3(){ BasicDataSource dataSource = new BasicDataSource(); dataSource.setMaxTotal(20); dataSource.setMaxIdle(10); dataSource.setInitialSize(5); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://120.79.167.88:3306/oms_sys_info?useUnicode=true&amp;amp;characterEncoding=utf-8\"); dataSource.setMinIdle(5); dataSource.setUsername(\"root\"); dataSource.setPassword(\"root\"); return dataSource; } @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ System.out.println(dataSource); return new JdbcTemplate(dataSource); }} 总结： ​ 这一节主要是介绍如何在Spring中操作数据库，而本节只是使用了Spring中的JdbcTemplate来操作数据库。同时本节包含了操作数据库一个重要的知识点–数据源。配置数据源包括了从服务器中获取，即通过JNDI配置数据源。或是使用Java配置类的形式类配置数据源。常用的数据源包括：DruidDataSource(Alibaba Druid)、BasicDataSource(DBCP)、ComboPooledDataSource(C3P0).","link":"/2020/01/29/SSM/spring4x/8Spring%E5%92%8CJDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"十八、Sentinel规则之流量控制规则","text":"Sentinel规则之流量控制规则 概述流量控制(flow control), 其原理是监控应用的QPS或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。 文档：https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6 继承结构同一资源可以创建多条限流规则。我们先看一下继承结构： 下面是Rule接口代码： 123public interface Rule { boolean passCheck(Context context, DefaultNode node, int count, Object... args);} AbstractRule: 12345678910public abstract class AbstractRule implements Rule { /** * 资源名，资源名是限流规则的作用对象。 */ private String resource; /** * 流控针对的调用来源，default代表不区分调用来源 */ private String limitApp;} FlowRule： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class FlowRule extends AbstractRule { /** * 限流阈值类型 0：线程数 1：QPS queries per second */ private int grade = RuleConstant.FLOW_GRADE_QPS; /** * 数量。限流阈值 */ private double count; /** * 流控模式 * public static final int STRATEGY_DIRECT = 0; //direct 直接模式 * public static final int STRATEGY_RELATE = 1; //relate 关联 * public static final int STRATEGY_CHAIN = 2; //chain 链路 */ private int strategy = RuleConstant.STRATEGY_DIRECT; /** * Reference resource in flow control with relevant resource or context. */ private String refResource; /** * Rate limiter control behavior. * 流控控制效果（直接拒绝，Warm up，匀速排队） * 0. default(reject directly), 1. warm up, 2. rate limiter, 3. warm up + rate limiter */ private int controlBehavior = RuleConstant.CONTROL_BEHAVIOR_DEFAULT; private int warmUpPeriodSec = 10; /** * Max queueing time in rate limiter behavior. */ private int maxQueueingTimeMs = 500; private boolean clusterMode; /** * 集群模式 */ private ClusterFlowConfig clusterConfig; /** * The traffic shaping (throttling) controller. */ private TrafficShapingController controller; @Override public boolean passCheck(Context context, DefaultNode node, int acquireCount, Object... args) { return true; }} 单条限流规则主要由以下几个因素组成，我们可以组合这些元素实现不同的限流效果： resource : 资源名，即限流规则的作用对象 count : 限流阈值 grade : 限流阈值类型(QPS或是并发线程数) limitApp : 流控针对的调用来源，若为default 则不区分来源 strategy : 调用关系限流策略 controlBehavior ：流量控制效果(直接拒绝,Warm Up,均速排队) 基本代码12345678910111213141516171819202122232425262728293031// EchoController@RestControllerpublic class EchoController { @Autowired private EchoService echoService; @GetMapping(\"/echo/{str}\") public String echo(@PathVariable String str, HttpServletRequest request){ return echoService.echo(str); }}// EchoServicepublic interface EchoService { String echo(String str);}// EchoServiceImpl@Servicepublic class EchoServiceImpl implements EchoService { @Override @SentinelResource(value = \"echo\",blockHandler = \"handleBlockException\") public String echo(String str) { return \"echo str:\"+str; } public String handleBlockException(String str, BlockException ex){ return \"str:\"+str+\" | e:\"+ex; }} 基于QPS流量控制当QPS超过某个阈值的时候，则采用措施进行流量控制（基于并发线程数的没有这个控制）。流量控制的手段包括以下几种：直接拒绝，Warm Up，均速排队。对应FlowRule 中的controlBeHavior字段。 https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6#22-qps%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6 流量控制 直接拒绝:(RuleConstant.CONTROL_BEHAVIOR_DEFAULT)方式是默认的流量控制方式，当QPS超过任何规则的阈值后，新的请求就会立即拒绝，拒绝方式为抛出FlowException . 这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。 Warm Up:(RuleConstant.CONTROL_BEHAVIOR_WARM_UP)方式，即预热/冷启动方式。当系统长期处理低水平的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值的上限，给系统一个预热的时间，避免冷系统被压垮。 通常冷启动的过程系统允许通过的 QPS 曲线如下图所示： ​ ​ 均速排队:(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER)方式后严格控制请求通过的时间间隔，也即是让请求以均匀的速度通过，对应的是漏桶算法。 该方式的作用如下图所示： 这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。 代码测试初始化规则： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*初始化规则*/public static void initRule(){ List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;(); //定义规则 FlowRule rule = new FlowRule(); //定义资源 rule.setResource(\"echo\"); //定义模式 rule.setGrade(RuleConstant.FLOW_GRADE_QPS); //定义阈值 rule.setCount(2); rules.add(rule); FlowRuleManager.loadRules(rules);}public static void testFlowRule(){ initRule(); Entry entry = null; for (int i = 0; i &lt; 10; i++) { try { entry = SphU.entry(\"echo\"); System.out.println(\"访问成功\"); } catch (BlockException e) { System.out.println(\"当前访问人数过多，请刷新后重新!\"); }finally { if (entry != null){ entry.exit(); } } }}// ============== 执行结果 =================/**访问成功访问成功当前访问人数过多，请刷新后重试!当前访问人数过多，请刷新后重试!当前访问人数过多，请刷新后重试!当前访问人数过多，请刷新后重试!当前访问人数过多，请刷新后重试!当前访问人数过多，请刷新后重试!当前访问人数过多，请刷新后重试!当前访问人数过多，请刷新后重试!*/ 通过上面的代码可以测试出：当我们使用QPS为阈值类型时，并设置阈值为2，定义资源，其他默认，则表示一秒内，只需要通过两次请求，其他的均失败。 initRule()方法相当于在页面这样设置： 基于并发线程数控制代码测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static void initFlowRuleForThreadNum() { List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;(); FlowRule rule = new FlowRule(); //定义以线程数控制 rule.setGrade(RuleConstant.FLOW_GRADE_THREAD); //定义资源名 rule.setResource(\"echo\"); //定义并发线程数阈值 rule.setCount(2); rules.add(rule); FlowRuleManager.loadRules(rules);}public static void testFlowRuleForThreadNum() { initFlowRuleForThreadNum(); for (int i = 0; i &lt; 5; i++) { new Thread() { @Override public void run() { for (int j = 0; j &lt; 5; j++) { Entry entry = null; try { entry = SphU.entry(\"echo\"); System.out.println(\"操作成功！\"); } catch (BlockException ex) { System.out.println(\"当前访问人数过多，请刷新后重试!\"); } finally { if (entry != null) { entry.exit(); } } } } }.start(); }}// ========================测试结果==================/**操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！操作成功！当前访问人数过多，请刷新后重试!操作成功！*/ 上面的初始化规则，相当于： 基于调用关系的流量控制 https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6#%E5%9F%BA%E4%BA%8E%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6 根据调用方限流ContextUtil.enter(resourceName, origin) 方法中的origin 参数标明了调用身份。这些信息会在ClusterBuilderSlot 中统计。 流量规则中的limitApp 字段用于根据调用来源进行流量控制。该字段的值有以下三种选择，分别对应不同的场景： default ：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则出发限流。 {some_origin_name} : 表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如NodeA 配置了一条针对调用者caller1 的规则，那么当且仅当来自caller1 对 NodeA 的请求才会触发流量控制。 other ：表示针对除{some_origin_name} 以外的其余调用方的流量进行流量控制。例如：资源NodeA 配置了一条针对调用者caller1 的限流规则，同时又配置了一条调用者为other 的规则，那么任意来自非caller1 对NodeA 的调用，都不能超过other这条规则定义的阈值。 同一资源名可以配置多条规则，规则生效的顺序为:{some_origin_name} &gt; other &gt; default. 代码测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*定义根据调用者的流控规则*/public static void initFlowRuleForCaller(){ List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;(); FlowRule rule = new FlowRule(); //定义资源名 rule.setResource(\"echo\"); //定义阈值类型 rule.setGrade(RuleConstant.FLOW_GRADE_QPS); //定义阈值 rule.setCount(2); //定义限制调用者 rule.setLimitApp(\"caller\"); rules.add(rule); FlowRule rule1 = new FlowRule(); rule1.setResource(\"echo\"); rule1.setGrade(RuleConstant.FLOW_GRADE_QPS); rule1.setLimitApp(\"other\"); rule1.setCount(3); rules.add(rule1); FlowRuleManager.loadRules(rules);}public static void testFlowRuleForCaller(){ initFlowRuleForCaller(); for (int i = 0; i &lt; 5; i++) { ContextUtil.enter(\"c1\",\"caller\"); Entry entry = null; try { entry = SphU.entry(\"echo\"); System.out.println(\"访问成功\"); } catch (BlockException e) { System.out.println(\"网络异常，请刷新！\"); }finally { if (entry != null){ entry.exit(); } } }}// =========测试结果：=========/*访问成功访问成功网络异常，请刷新！网络异常，请刷新！网络异常，请刷新！*/// ===========将caller换成caller1测试，结果如下============/*访问成功访问成功访问成功网络异常，请刷新！网络异常，请刷新！*/ 控制页面流控规则列表： 前面都是自己手动使用ContextUtil自己去埋点定义，那么在web场景下如何识别origin呢？ 这一部分放到最后，：如何自定义origin ? 根据调用链路限流NodeSelectorSlot 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 machine-root 的虚拟节点，调用链的入口都是这个虚节点的子节点。 一棵典型的调用树如下图所示： 1234567 machine-root / \\ / \\ Entrance1 Entrance2 / \\ / \\DefaultNode(nodeA) DefaultNode(nodeA) 上图中来自入口 Entrance1 和 Entrance2 的请求都调用到了资源 NodeA，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 FlowRule.strategy 为 RuleConstant.CHAIN，同时设置 FlowRule.ref_identity 为 Entrance1 来表示只有从入口 Entrance1 的调用才会记录到 NodeA 的限流统计当中，而不关心经 Entrance2 到来的调用。 调用链的入口（上下文）是通过 API 方法 ContextUtil.enter(contextName) 定义的，其中 contextName 即对应调用链路入口名称。 代码测试： 规则定义 12345678910111213141516public static void initFlowRuleForLink(){ List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;(); FlowRule rule = new FlowRule(); //定义流控模式 rule.setStrategy(RuleConstant.STRATEGY_CHAIN); //定义资源名 rule.setResource(\"echo\"); //定义入口资源 rule.setRefResource(\"Entrance1\"); //定义阈值类型 rule.setGrade(RuleConstant.FLOW_GRADE_QPS); //定义阈值 rule.setCount(2); rules.add(rule); FlowRuleManager.loadRules(rules);} 页面显示 测试 1234567891011121314151617181920212223242526272829303132public static void testFlowRuleForLink(){ initFlowRuleForLink(); for (int i = 0; i &lt; 5; i++) { ContextUtil.enter(\"Entrance1\"); Entry entry = null; try { entry = SphU.entry(\"echo\"); System.out.println(\"访问成功\"); } catch (BlockException e) { System.out.println(\"网络异常，请刷新！\"); }finally { if (entry != null){ entry.exit(); } } }}//========测试结果======/*访问成功访问成功网络异常，请刷新！网络异常，请刷新！网络异常，请刷新！*///========ContextUtil.enter(\"Entrance1\");修改为ContextUtil.enter(\"Entrance2\");====/*访问成功访问成功访问成功访问成功访问成功*/ 根据测试结果可以看出，这里只对入口为Entrance1 进行流量控制，对Entrance2 不进行流量控制。 具有关系的资源流量控制：关联流量控制当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，read_db 和 write_db 这两个资源分别代表数据库读写，我们可以给 read_db 设置限流规则来达到写优先的目的：设置 FlowRule.strategy 为 RuleConstant.RELATE 同时设置 FlowRule.ref_identity 为 write_db。这样当写库操作过于频繁时，读数据的请求会被限流。 自定义Originalibaba的github FAQ中有提到： https://github.com/alibaba/Sentinel/wiki/FAQ#q-%E6%80%8E%E4%B9%88%E9%92%88%E5%AF%B9%E7%89%B9%E5%AE%9A%E8%B0%83%E7%94%A8%E7%AB%AF%E9%99%90%E6%B5%81%E6%AF%94%E5%A6%82%E6%88%91%E6%83%B3%E9%92%88%E5%AF%B9%E6%9F%90%E4%B8%AA-ip-%E6%88%96%E8%80%85%E6%9D%A5%E6%BA%90%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E9%87%8C%E9%9D%A2-limitapp%E6%B5%81%E6%8E%A7%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8 在web情况下，会有一个名为CommonFilter 的Filter对请求进行过滤：我们来看一下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class CommonFilter implements Filter { private final static String HTTP_METHOD_SPECIFY = \"HTTP_METHOD_SPECIFY\"; private final static String COLON = \":\"; private boolean httpMethodSpecify = false; @Override public void init(FilterConfig filterConfig) { httpMethodSpecify = Boolean.parseBoolean(filterConfig.getInitParameter(HTTP_METHOD_SPECIFY)); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest sRequest = (HttpServletRequest)request; Entry urlEntry = null; try { String target = FilterUtil.filterTarget(sRequest); UrlCleaner urlCleaner = WebCallbackManager.getUrlCleaner(); if (urlCleaner != null) { target = urlCleaner.clean(target); } if (!StringUtil.isEmpty(target)) { //******* 主要看这个方法，这是用来转化origin的。 String origin = parseOrigin(sRequest); ContextUtil.enter(WebServletConfig.WEB_SERVLET_CONTEXT_NAME, origin); if (httpMethodSpecify) { String pathWithHttpMethod = sRequest.getMethod().toUpperCase() + COLON + target; urlEntry = SphU.entry(pathWithHttpMethod, ResourceTypeConstants.COMMON_WEB, EntryType.IN); } else { urlEntry = SphU.entry(target, ResourceTypeConstants.COMMON_WEB, EntryType.IN); } } chain.doFilter(request, response); } catch (BlockException e) { HttpServletResponse sResponse = (HttpServletResponse)response; WebCallbackManager.getUrlBlockHandler().blocked(sRequest, sResponse, e); } catch (IOException | ServletException | RuntimeException e2) { Tracer.traceEntry(e2, urlEntry); throw e2; } finally { if (urlEntry != null) { urlEntry.exit(); } ContextUtil.exit(); } } private String parseOrigin(HttpServletRequest request) { RequestOriginParser originParser = WebCallbackManager.getRequestOriginParser(); String origin = EMPTY_ORIGIN; if (originParser != null) { origin = originParser.parseOrigin(request); if (StringUtil.isEmpty(origin)) { return EMPTY_ORIGIN; } } return origin; } @Override public void destroy() {} private static final String EMPTY_ORIGIN = \"\";} parseOrigin方法： 123456789101112private String parseOrigin(HttpServletRequest request) { //这个方法需要从WebCallbackManager中拿出一个RequestOriginParser. RequestOriginParser originParser = WebCallbackManager.getRequestOriginParser(); String origin = EMPTY_ORIGIN; if (originParser != null) { origin = originParser.parseOrigin(request); if (StringUtil.isEmpty(origin)) { return EMPTY_ORIGIN; } } return origin;} RequestOriginParser接口： 123public interface RequestOriginParser { String parseOrigin(HttpServletRequest request);} 在项目中这个接口是没有实现的，所以正常情况下origin = &quot;&quot;. 我们需要自己实现，并将其加入到spring容器中即可。 12345678910111213/** * @author hao.ouYang * @create 2019-10-22 18:25 */@Componentpublic class IOriginParser implements RequestOriginParser { @Override public String parseOrigin(HttpServletRequest request) { String id = request.getParameter(\"id\"); System.out.println(id); return id; }}","link":"/2020/01/18/SSM/springcloudalibaba/15.sentinel%E8%A7%84%E5%88%99%E4%B9%8B%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%A7%84%E5%88%99/"},{"title":"ArrayList源码分析","text":"ArrayList源码分析 部分参考自: https://www.cnblogs.com/aflyun/p/6444913.html https://www.cnblogs.com/ysocean/p/8622264.html#_label0 概述ArrayList底层是由数组实现的，是一个自动扩容的数组。(由于数组的长度是固定的，扩容时其实是进行数组复制) 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{} ArrayList继承AbstractList类，实现了List接口, 所有有List的所有功能。 ArrayList实现了RandomAccess接口，支持随机访问，可以直接通过下标进行访问。 ArrayList实现了Cloneable接口，支持克隆。 ArrayList实现了Serializable接口，支持序列化功能。 数组复制由于ArrayList底层是数组，所以会涉及到数组复制等操作，我们先来了解一下： 数组复制Arrays.copyOf 12345int[] oldArr = {1,2,3,4,5};int[] ints = Arrays.copyOf(oldArr, 4);System.out.println(Arrays.toString(ints));//[1, 2, 3, 4]int[] ints1 = Arrays.copyOf(oldArr, 10);System.out.println(Arrays.toString(ints1));//[1, 2, 3, 4, 5, 0, 0, 0, 0, 0] 数组复制 System.arraycopy 12345678910111213141516/** * 参数1：源数组 * 参数2：原数组的起始下标 * 参数3：目标数组 * 参数4：目标数组的起始下标 * 参数5：复制的元素个数 */System.arraycopy( sourceArr, 0, descArr, 0, sourceArr.length &lt; descArr.length ? sourceArr.length : descArr.length);System.out.println(Arrays.toString(sourceArr));//[1, 2, 3, 4]System.out.println(Arrays.toString(descArr));//[1, 2, 3, 4, 55] 方法综述和源码分析属性1234567891011121314151617181920212223242526272829303132333435/** * Default initial capacity. * 默认初始化容量 */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for empty instances. * 底层是基于数组实现的 */private static final Object[] EMPTY_ELEMENTDATA = {};/** * 共享的空数组实例，用于默认大小的空实例。 * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/** * ArrayList的元素存储的数组。ArrayList集合的容量就是数组的长度， * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * 任何空集合的数组如果等于 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素添加时， * 将会被扩容至默认容量大小。 */transient Object[] elementData; // non-private to simplify nested class access/** * ArrayList的size，元素的个数 */private int size; 根据方法功能的不同，来进行分类。 构造方法123public ArrayList(int initialCapacity) {}public ArrayList() {}public ArrayList(Collection&lt;? extends E&gt; c) {} 1234567891011121314151617181920212223242526272829303132333435/** * 指定初始化集合数组大小来实例化集合。如果指定的大小是负数，则抛出IllegalArgumentException */public ArrayList(int initialCapacity) { //指定大小大于0 ，就直接实例化。 if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity];//指定初始化容量 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA;//空数组 } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); }}/** * Constructs an empty list with an initial capacity of ten. * 构造一个初始化容量为10的空列表（注意：根据注释是10，但是源码其实是一个长度为0的空数组） */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}/** * 构造一个包含指定集合的List,将指定集合的数据全部添加到当前集合中。 * 如果指定的集合为null,则会抛出NullPointerException（因为直接调用了c.toArray()） */public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray();//如果c为空，则会抛出空指针异常 if ((size = elementData.length) != 0) { if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { this.elementData = EMPTY_ELEMENTDATA; }} 注意：通过上面的elementData 属性注释，以及 ArrayList()构造方法和 add()方法可以知道: 在不指定容量的情况下，初始化的ArrayList的容量为0，在添加第一个元素的时候，容量才会扩充到默认大小10. 在指定容量的时候，是根据指定容量大小来实例化集合的，不会采用默认大小10. Add Element12345public E set(int index, E element) {}public boolean add(E e) {}public void add(int index, E element) {}public boolean addAll(Collection&lt;? extends E&gt; c) {} public boolean addAll(int index, Collection&lt;? extends E&gt; c) {} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * 设置值，返回旧值 */public E set(int index, E element) { //下标检查 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;}/** * 在列表最后添加元素,通过查看源码可以发现，ArrayList()初始化是，数组的大小是0，当我们 * 添加第一个元素的时候，将大小扩充到了10. */public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;}private static int calculateCapacity(Object[] elementData, int minCapacity) { //这一个条件成立的情况只有初始化时未指定大小，并且是第一个次添加元素 //即：ArrayList list = new ArrayList(); // list.add(1); 能通过这个条件 // list.add(2); 不能通过这个条件 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); 1 ==&gt; 10 } return minCapacity;}private void ensureCapacityInternal(int minCapacity) { int capacity = calculateCapacity(elementData, minCapacity);//10 ensureExplicitCapacity(capacity);}private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0)//第一次之后，elementData.length,就是10 grow(minCapacity);//10}private void grow(int minCapacity) {// // overflow-conscious code int oldCapacity = elementData.length;// int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 按照1.5倍的方法进行扩容 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);}//数组的最大容量不会超过MAX_ARRAY_SIZEprivate static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;}/** * 将指定元素插入指定位置，将原有元素及其右边的元素均向后移动一个（下标加1） */public void add(int index, E element) { //检查下标是否合法，否则抛出IndexOutOfBoundsException rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;}/** * 将指定元素插入指定位置，将原有元素及其右边的元素均向后移动一个（下标加1） */public void add(int index, E element) { //检查下标是否合法，否则抛出IndexOutOfBoundsException rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;}/** * 在末尾添加指定集合的所有元素 */public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew);//使用数组复制。 size += numNew; return numNew != 0;}/** * 从指定位置开始添加集合元素，如指定为止及其右边有元素，则全部向后移动 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;} 对于 ArrayList 集合添加元素，我们总结一下： ①、当通过 ArrayList() 构造一个空集合，初始长度是为0的，第 1 次添加元素，会创建一个长度为10的数组，并将该元素赋值到数组的第一个位置。 ②、第 2 次添加元素，集合不为空，而且由于集合的长度size+1是小于数组的长度10，所以直接添加元素到数组的第二个位置，不用扩容。 ③、第 11 次添加元素，此时 size+1 = 11，而数组长度是10，这时候创建一个长度为10+10*0.5 = 15 的数组（扩容1.5倍），然后将原数组元素引用拷贝到新数组。并将第 11 次添加的元素赋值到新数组下标为10的位置。 ④、第 Integer.MAX_VALUE - 8 = 2147483639，然后 2147483639%1.5=1431655759（这个数是要进行扩容） 次添加元素，为了防止溢出，此时会直接创建一个 1431655759+1 大小的数组，这样一直，每次添加一个元素，都只扩大一个范围。 ⑤、第 Integer.MAX_VALUE - 7 次添加元素时，创建一个大小为 Integer.MAX_VALUE 的数组，在进行元素添加。 ⑥、第 Integer.MAX_VALUE + 1 次添加元素时，抛出 OutOfMemoryError 异常 注意：能向集合中添加 null 的，因为数组可以有 null 值存在。 为了测试上述的扩容方法是否为真，我们这里利用反射机制来查看ArrayList底层的数组的长度。 1234567891011121314151617181920212223242526272829303132public class Test { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { /* * ArrayList 在没有指定容量的情况下初始化，只是初始化一个空的数组。 * 当指定第一个add方法时，才会先将其容量扩容到10，其默认第一次初始化大小为10. */ ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); Class&lt;ArrayList&gt; aClass = ArrayList.class; Field elementData = aClass.getDeclaredField(\"elementData\"); elementData.setAccessible(true); Object[] o = (Object[]) elementData.get(strList); System.out.println(o.length);//0 strList.add(\"A\"); o = (Object[]) elementData.get(strList); System.out.println(o.length);//10 for (int i = 0; i &lt; 10; i++) { strList.add(String.valueOf(i)); } o = (Object[]) elementData.get(strList); System.out.println(o.length);//15 for (int i = 0; i &lt; 5; i++) { strList.add(String.valueOf(i)); } o = (Object[]) elementData.get(strList); System.out.println(o.length);//22 for (int i = 0; i &lt; 7; i++) { strList.add(String.valueOf(i)); } o = (Object[]) elementData.get(strList); System.out.println(o.length);//33 }} 打印结果如上述所示，按照1.5倍增长 10 =&gt; 10 =&gt; (10 + 10/2 = 15) =&gt; (15 + 15/2 = 22) =&gt; (22 + 22/2 = 33) Remove Element12345public E remove(int index) {}public boolean remove(Object o) {}public boolean removeAll(Collection&lt;?&gt; c) {}public boolean retainAll(Collection&lt;?&gt; c) {}public void clear() {} 通过 remove(Object) 方法可以看到，删除是进行了null 和 非null 的判断，所以：ArrayList是可以存储null 值的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 移除指定位置上的元素，在其右侧元素均向左移动一位（下标减1） */public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;}/** * 移除下标最小的所指定的元素，如果不存在，则不变. */public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false;}/** * 移除当前集合中存在于指定集合中的元素。 */public boolean removeAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); return batchRemove(c, false);}/** * 保留当前集合中存在于指定集合中的元素。即：移除所有存在于指定集合中的元素。 * 集合改变了则返回true，集合未改变则返回false. * 如果当前集合存在于指定集合类型不符时，会抛出ClassCastException. * 如果当前集合存在null值，但是指定集合不允许使用null时，则抛出NullPointerException. */public boolean retainAll(Collection&lt;?&gt; c) { //确保c集合不为null，否则抛出NullPointerException Objects.requireNonNull(c); return batchRemove(c, true);//complement:补充}//批量移除/** * 当 complement为true, 返回的是this集合中包含在指定集合c中的所有元素。 * 当 complement为false, 返回的是this集合中不包含在指定集合c中的所有元素。 */private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try { for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement)//如果c包含当前集合中的， elementData[w++] = elementData[r];//保留elementData中所有在集合c中的元素。 } finally { if (r != size) { System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; } if (w != size) { for (int i = w; i &lt; size; i++) elementData[i] = null;//将后续的元素置为null modCount += size - w;// modCount = modCount + (size - w) size = w; modified = true; } } return modified;}/** * 清除所有元素 */public void clear() { modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;} Get Element1public E get(int index) {} 123456789101112131415/** * 查询指定下边的元素 */@SuppressWarnings(\"unchecked\")E elementData(int index) { return (E) elementData[index];}/** * 获取指定位置上的元素 */public E get(int index) { rangeCheck(index); return elementData(index);} Search Element123public int indexOf(Object o) {}public int lastIndexOf(Object o) {}public boolean contains(Object o) {} 同样在查询的时候都进行了null 和 非null的区分。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 判断是否包含某个元素 */public boolean contains(Object o) { return indexOf(o) &gt;= 0;}/** * 根据指定元素，返回第一次出现在这个列表中的下标，如果列表中不包含这个元素，则返回 -1 * 如果元素为空，则返回第一个为null的元素的下标，如果不为空，则比较元素相同，返回第一个 * 相同的下标，如果不存在，则返回-1 */public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1;}/** * 返回最后一个匹配的该元素的下表，元素可以为空，如果没有则返回-1 */public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1;} To Array12public Object[] toArray() {}public &lt;T&gt; T[] toArray(T[] a) {} 1234567891011121314151617181920212223242526272829303132333435363738/** * 这个方法将ArrayList中的数组复制一份，再返回。即：需要新分配一个数组。 */public Object[] toArray() { return Arrays.copyOf(elementData, size);}/** * 将集合中装换到指定数组中。如果给定的数组长度小于集合元素个数，则会新创建一个数组，并返回。 * 如果给定的数组长度大于或等于集合元素个数，则直接复制进指定数组，并将剩余空间置为null. * 如果指定数组的运行时类型不是每个元素的运行时类型或父类型时，抛出ArrayStoreException * 如果指定数组为null,则会抛出NullPointerException. * * @Test * public void testToArray(){ * ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); * list.add(1); * list.add(2); * list.add(3); * * Integer [] arr = new Integer[4]; * Integer[] array = list.toArray(arr); * System.out.println(arr == array);//true * * Integer[] arr1 = new Integer[1]; * Integer[] array1 = list.toArray(arr1); * System.out.println(arr1 == array1);//false * } */@SuppressWarnings(\"unchecked\")public &lt;T&gt; T[] toArray(T[] a) { if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null;//将剩余位置置为null. return a;} Other12345678public int size() {}public boolean isEmpty() {}public Object clone() {}public List&lt;E&gt; subList(int fromIndex, int toIndex) {}public void forEach(Consumer&lt;? super E&gt; action) {}public boolean removeIf(Predicate&lt;? super E&gt; filter) {}public void replaceAll(UnaryOperator&lt;E&gt; operator) {}public void sort(Comparator&lt;? super E&gt; c) {} 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 元素的个数 */public int size() { return size;}/** * 集合大小是0，返回true */public boolean isEmpty() { return size == 0;}/** * ArrayList实例的浅拷贝 */public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); }}/** * 使用subList(fromIndex,toIndex)，返回的是原来集合的一个视图，所以操作的其实是原集合。 * Returns a view of the portion of this list between the specified * 注意：包括fromIndex,不包括toIndex.如果fromIndex和toIndex相等，则返回empty List。 * 当我们需要在当前集合的某些范围内操作，就可以使用subList，例如： * list.subList(fromIndex,toIndex).clear().另外List中的方法同样适用于返回的subList, * 因为subList()返回的SubList集合继承自AbstractList. * 下标越界则抛IndexOutOfBoundsException,参数异常则抛IllegalArgumentException。 */public List&lt;E&gt; subList(int fromIndex, int toIndex) { //检查集合下标是否合法。 subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);} 至于剩下的三个方法，我们通过测试案例来说明: RemoveIf(Predicate) 如果满足则删除 1234567891011121314151617181920212223@Testpublic void testRemoveIf(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.removeIf(new Predicate&lt;Integer&gt;() { /** * test返回true，则去除，否则，保留 * @param integer * @return */ @Override public boolean test(Integer integer) { if (integer == 1){ return true; } return false; } }); System.out.println(list);//[2, 3]} replaceAll(UnaryOperator) 替换所有满足条件的 12345678910111213141516171819@Testpublic void testReplaceAll(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.replaceAll(new UnaryOperator&lt;Integer&gt;() { @Override public Integer apply(Integer integer) { if (integer == 1){ return 11; } return integer; } }); System.out.println(list);//[11, 2, 3]} sort(Comparator) 排序 123456789101112131415161718192021@Testpublic void testSort(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(5); list.add(4); list.sort(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { if (o1 &lt; o2){ return -1;//负数表示o1&lt;o2, 正数表示o1&gt;o2. }else if (o1 &gt; o2){ return 1; } return 0; } }); System.out.println(list);} 迭代器1234// 创建Iteratorpublic ListIterator&lt;E&gt; listIterator(int index) {}public ListIterator&lt;E&gt; listIterator() {}public Iterator&lt;E&gt; iterator() {} 12345678910111213141516// 创建一个从指定下标开始到结尾的ListIterator.public ListIterator&lt;E&gt; listIterator(int index) { if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index);}//创建一个从开始到结尾的ListIterator.public ListIterator&lt;E&gt; listIterator() { return new ListItr(0);}//创建一个Iteratorpublic Iterator&lt;E&gt; iterator() { return new Itr();} 集合遍历普通for循环遍历1234567891011121314@Testpublic void testLoop(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { list.add(i); } for (int i = 0; i &lt; list.size(); i++) { if (list.get(i) == 5){ list.remove(i); } } System.out.println(list);//[0, 1, 2, 3, 4, 6, 7, 8, 9]} foreach 循环遍历123456789101112131415161718192021@Testpublic void testForeach(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); for (Integer i : list) { if (i == 2){ list.remove(i); } } System.out.println(list);}//以上代码会抛出 并发修改异常/*java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) at com.ooyhao.list.ListTest.testForeach(ListTest.java:215)*/ 使用foreach去增加或删除元素时,会出现并发异常。我们先来看一下反编译的代码： 123456789101112131415161718@Testpublic void testForeach() { ArrayList&lt;Integer&gt; list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); Iterator var2 = list.iterator(); while(var2.hasNext()) { Integer i = (Integer)var2.next(); if (i == 2) { list.remove(i); } } System.out.println(list);} 经过编译器编译之后的代码如上。 我们先看一下Iterator 类源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings(\"unchecked\") public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size &amp;&amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); }} 并发修改异常通过源码可以看到，方法next 和 remove 都有调用检查是否并发修改方法checkForComodification .再回来看下列代码： 1234567Iterator var2 = list.iterator();while(var2.hasNext()) { Integer i = (Integer)var2.next(); if (i == 2) { list.remove(i); }} 猜想分析：当i==2 时，调用remove方法可以正常删除，但是此时 list的modCount属性和迭代器expectedModCount的值不同了，下一次循环，调用var2.next() 方法时，会调用checkForComodification 方法，此时会抛出 ConcurrentModificationException异常。 验证： 此时可以看到，list中的元素正常删除了，我们在往下走一步。就报错了。所以，报错不是发生在执行list.remove(i) 时，而是下一次执行var2.next(). 综合上述两个案例可以知道：增强For循环其实使用的就是Iterator迭代器。 如果使用普通For循环遍历 ,则只能使用list.remove()。 如果使用 增加for循环遍历,则只能使用 迭代器的remove 方法。 Iterator迭代器迭代器源码上面已经看了，可以发现，Iterator迭代器除了hasNext() 和 next() 方法，用于操作的只有一个remove() 方法，所以这个迭代器只能用于remove，不能进行modify 和 add。 使用Iterator迭代器来遍历和删除： 1234567891011121314151617@Testpublic void testIterator(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer next = iterator.next(); if (next == 2){ iterator.remove(); } } System.out.println(list);//[1, 3, 4]} ListIterator迭代器我们先看一下ListIterator的源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * An optimized version of AbstractList.ListItr */private class ListItr extends Itr implements ListIterator&lt;E&gt; { ListItr(int index) { super(); cursor = index; } public boolean hasPrevious() { return cursor != 0; } public int nextIndex() { return cursor; } public int previousIndex() { return cursor - 1; } @SuppressWarnings(\"unchecked\") public E previous() { checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; } public void set(E e) { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.set(lastRet, e); } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } public void add(E e) { checkForComodification(); try { int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } }} 我们通过源码可以看出： 具有hasPrevious() 和 previous() 两个方法，可以倒序遍历。 具有hasNext()和 next() 两个方法，可以顺序遍历。 具有nextIndex() 和 previousIndex() 两个方法，可以获取游标的上一个和下一个位置。 具有remove(),add(),set() 三个方法，可以实现增删改。 下面通过例子测试一下： 1234567891011121314151617181920212223242526272829@Testpublic void testListIterator(){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(3); list.add(2); list.add(3); list.add(4); //遍历和删除 ListIterator&lt;Integer&gt; listIterator = list.listIterator(1); while (listIterator.hasNext()){ Integer next = listIterator.next(); if (next == 3){ listIterator.remove(); } } System.out.println(list);//[3, 2, 4] //上述遍历，已经将游标移动到了最后，此时我们使用倒序遍历。 while (listIterator.hasPrevious()){ Integer previous = listIterator.previous(); if (previous == 2){ listIterator.add(22); } if (previous == 3){ listIterator.set(303); } } System.out.println(list);//[303, 22, 2, 4]} 总结 ArrayList 底层是数组实现的，非同步。即：线程不安全。 默认初始化容量为10，最大容量为 MAX_ARRAY_SIZE = INTEGER.MAX_VALUE - 8 . 当使用无参构造进行实例化时，此时的容量为0，添加第一个元素是，容量为10. 当指定容量时，使用实际指定的数值。 indexOf() 和 lastIndexOf 查找元素，区别null ,如查找元素不存在时，返回-1. 数组进行扩容时，会重新设置容量。newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) ,即：使用1.5倍进行扩容。 ArrayList的克隆函数，就是将数组复制一份。 从代码看，当ArrayList的容量不足的时候，每次增加元素，都是将原来的数据复制到一个新的数组中，非常消耗时间，所以，当我们在事先可以确定元素的个数的情况下使用ArrayList ,否则建议使用LinkedList. ArrayList的实现中大量使用了 Arrays.copyof 和 System.arraycofy ，所以前面介绍了两个方法的使用。 ArrayList底层实现是使用的数组，所以在查询的时候支持随机访问 ，即：查询快，增删慢。而LinkedList底层实现是双向链表，不支持随机访问，仅能顺序访问。即：查询慢，增删快。所以我们在选择集合的时候，需要根据业务逻辑的不同来使用不同的集合。 在查询和删除的时候，都区分了null和非null两种情况，所以ArrayList中可以使用null.与LinkedList一样","link":"/2020/04/08/%E5%9F%BA%E7%A1%80/ArrayList/"},{"title":"二、装配Bean","text":"装配Bean Spring装配Bean的三种方式 在XML中进行显示配置 在Java中进行显示配置 隐式的Bean发现和自动装配 组件扫描：Spring会自动发现应用上下文所创建的Bean 自动装配：Spring自动满足Bean之间的依赖 ​ 尽可能地的使用自动配置的机制。显示的配置越少越好，当你必须要显示配置Bean的时候(比如：有些源码不是由你来维护的，而当你需要为这些代码配置的时候)，推荐使用类型安全（因为在Java配置中可以利用编译器检查）并且比XML更加强大的JavaConfig。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。 下面利用一个案例 ​ 手机和手机电池是一个依赖关系，在正常情况下，如果手机离开了手机电池，那么其实也不会起到什么作用，故以此为一个案例展开Spring Bean的装配。 手机接口： 12345/** * 案例分析： * 手机是依赖于手机电池存在的。 */public interface MobilePhone {} 电池接口： 12/*电池接口*/public interface Battery {} 手机实现类： 1234567891011121314public class HuaweiMobilePhone implements MobilePhone { private Battery battery; public HuaweiMobilePhone(){} public HuaweiMobilePhone(Battery battery){ this.battery = battery; } @Override public String toString() { return \"HuaweiMobilePhone{\" + \"battery=\" + battery + '}'; }} 电池实现类： 123456789101112131415161718public class HuaweiBattery implements Battery{ private String brand; private String name; public HuaweiBattery(){} public HuaweiBattery(String brand, String name){ this.brand = brand; this.name = name; } @Override public String toString() { return \"HuaweiBattery{\" + \"brand='\" + brand + '\\'' + \", name='\" + name + '\\'' + '}'; }} XML显示配置下面展示了基本的Bean注入方式，我们在上一篇其实已经接触到了。 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"battery\" class=\"com.ooyhao.spring.bean.HuaweiBattery\"/&gt; &lt;bean id=\"huaweiMobilePhone\" class=\"com.ooyhao.spring.bean.HuaweiMobilePhone\"&gt; &lt;constructor-arg name=\"battery\" ref=\"battery\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 使用Xml方式，测试类： 1234567@Testpublic void testDIXml(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"phone.xml\"); HuaweiMobilePhone bean = context.getBean(HuaweiMobilePhone.class); System.out.println(bean);} Java显示配置PhoneConfig 配置类： 12345678910public class PhoneConfig { @Bean public HuaweiBattery huaweiBattery(){ return new HuaweiBattery(); } @Bean public HuaweiMobilePhone huaweiMobilePhone(){ return new HuaweiMobilePhone(huaweiBattery()); }} 使用注解，测试，如下： 1234567@Testpublic void testAutoWire(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PhoneConfig.class); HuaweiMobilePhone phone = context.getBean(HuaweiMobilePhone.class); System.out.println(phone);} 自动发现和装配​ 使用Bean自动发现和装配的方式，则需要在Bean类上用@Component注解进行标识。通过@CompentScan(basePackages=&quot;&quot;)进行组件扫描。使用@AutoWired注解进行自动装配。 手机实现类： 123456789101112131415161718@Componentpublic class HuaweiBattery implements Battery{ private String brand; private String name; public HuaweiBattery(){} public HuaweiBattery(String brand, String name){ this.brand = brand; this.name = name; } @Override public String toString() { return \"HuaweiBattery{\" + \"brand='\" + brand + '\\'' + \", name='\" + name + '\\'' + '}'; }} 手机电池实现类： 12345678910111213141516@Componentpublic class HuaweiMobilePhone implements MobilePhone { @Autowired private Battery battery; public HuaweiMobilePhone(){} public HuaweiMobilePhone(Battery battery){ this.battery = battery; } @Override public String toString() { return \"HuaweiMobilePhone{\" + \"battery=\" + battery + '}'; }} Java配置类： 12@ComponentScan(basePackages = \"com.ooyhao.spring\")public class AutoWirePhoneConfig {} 测试类： 1234567@Testpublic void testAutoWire(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AutoWirePhoneConfig.class); HuaweiMobilePhone phone = context.getBean(HuaweiMobilePhone.class); System.out.println(phone);} 总结： 创建应用对象之间的协作关系行为通常称为装配，这也是依赖注入（DI）的本质。 @ComponentScan默认会扫描与配置类相同的包。组件扫描默认是不启动的。@ComponentScan除了basePackages属性，还有basePackageClasses属性。 @Bean 注解会告诉Spring这个方法将会返回一个对象。默认情况下，bean的ID与带有@Bean注解的方法名一样。 @component 默认是使用类名首字母小写作为Bean的id。当然也可以用其属性自定义指定。 属性注入构造注入XML配置： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"battery\" class=\"com.ooyhao.spring.bean.HuaweiBattery\"&gt; &lt;constructor-arg name=\"brand\" value=\"Huawei\"/&gt; &lt;constructor-arg name=\"name\" value=\"华为手机\"/&gt; &lt;/bean&gt; &lt;bean id=\"huaweiMobilePhone\" class=\"com.ooyhao.spring.bean.HuaweiMobilePhone\"&gt; &lt;constructor-arg name=\"battery\" ref=\"battery\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试实例不变，测试结果： 1HuaweiMobilePhone{battery=HuaweiBattery{brand='Huawei', name='华为手机'}} 为了了解更多的类型注入，下面新增耳机接口和实现类，并将手机的实现类进行修改，如下： 耳机接口类： 12/*耳机接口类*/public interface EarPhone {} 耳机实现类： 1234567891011121314151617181920public class HuaweiEarPhone implements EarPhone { private String color; private Double price; public HuaweiEarPhone() {} public HuaweiEarPhone(String color, Double price) { this.color = color; this.price = price; } @Override public String toString() { return \"HuaweiEarPhone{\" + \"color='\" + color + '\\'' + \", price=\" + price + '}'; }} 手机类：增加手机颜色和耳机 1234567891011121314151617181920212223242526272829303132333435363738public class HuaweiMobilePhone implements MobilePhone { private Battery battery; //手机颜色 private List&lt;String&gt; colors; private Set&lt;EarPhone&gt; earPhones; public HuaweiMobilePhone(){} public HuaweiMobilePhone(Battery battery){ this.battery = battery; } public HuaweiMobilePhone(List&lt;String&gt; colors) { this.colors = colors; } public HuaweiMobilePhone(Battery battery, List&lt;String&gt; colors){ this.battery = battery; this.colors = colors; } public HuaweiMobilePhone(Battery battery,List&lt;String&gt; colors, Set&lt;EarPhone&gt; earPhones) { this.battery = battery; this.colors = colors; this.earPhones = earPhones; } @Override public String toString() { return \"HuaweiMobilePhone{\" + \"battery=\" + battery + \", colors=\" + colors + \", earPhones=\" + earPhones + '}'; }} 修改XML配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"battery\" class=\"com.ooyhao.spring.bean.HuaweiBattery\"&gt; &lt;constructor-arg name=\"brand\" value=\"Huawei\"/&gt; &lt;constructor-arg name=\"name\" value=\"华为手机\"/&gt; &lt;/bean&gt; &lt;!--显示用name和value进行指定参数--&gt; &lt;bean id=\"earPhone1\" class=\"com.ooyhao.spring.bean.HuaweiEarPhone\"&gt; &lt;constructor-arg name=\"color\" value=\"白色\"/&gt; &lt;constructor-arg name=\"price\" value=\"59.9\"/&gt; &lt;/bean&gt; &lt;!--通过默认的Index顺序，顺序不能错--&gt; &lt;bean id=\"earPhone2\" class=\"com.ooyhao.spring.bean.HuaweiEarPhone\"&gt; &lt;constructor-arg value=\"黑色\"/&gt; &lt;constructor-arg value=\"60.5\"/&gt; &lt;/bean&gt; &lt;!--通过显示指定Index，顺序可以随意调换--&gt; &lt;bean id=\"earPhone3\" class=\"com.ooyhao.spring.bean.HuaweiEarPhone\"&gt; &lt;constructor-arg index=\"1\" value=\"66.6\"/&gt; &lt;constructor-arg index=\"0\" value=\"粉色\"/&gt; &lt;/bean&gt; &lt;!--通过c-index命名空间--&gt; &lt;bean id=\"earPhone4\" class=\"com.ooyhao.spring.bean.HuaweiEarPhone\" c:_0=\"蓝色\" c:_1=\"88.8\"/&gt; &lt;!--通过c-name命名空间--&gt; &lt;bean id=\"earPhone5\" class=\"com.ooyhao.spring.bean.HuaweiEarPhone\" c:color=\"绿色\" c:price=\"90.8\"/&gt; &lt;bean id=\"huaweiMobilePhone\" class=\"com.ooyhao.spring.bean.HuaweiMobilePhone\"&gt; &lt;!--手机电池 引用构造注入--&gt; &lt;constructor-arg name=\"battery\" ref=\"battery\"/&gt; &lt;!--手机颜色 集合字面量注入--&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;蓝色&lt;/value&gt; &lt;value&gt;红色&lt;/value&gt; &lt;value&gt;黑色&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;!--手机耳机 集合Bean注入--&gt; &lt;constructor-arg name=\"earPhones\"&gt; &lt;set&gt; &lt;ref bean=\"earPhone1\"/&gt; &lt;ref bean=\"earPhone2\"/&gt; &lt;ref bean=\"earPhone3\"/&gt; &lt;ref bean=\"earPhone4\"/&gt; &lt;ref bean=\"earPhone5\"/&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 测试结果如下： 1HuaweiMobilePhone{battery=HuaweiBattery{brand='Huawei', name='华为手机'}, colors=[蓝色, 红色, 黑色], earPhones=[HuaweiEarPhone{color='白色', price=59.9}, HuaweiEarPhone{color='黑色', price=60.5}, HuaweiEarPhone{color='粉色', price=66.6}, HuaweiEarPhone{color='蓝色', price=88.8}, HuaweiEarPhone{color='绿色', price=90.8}]} Set注入​ 下面案例展示如何使用Set方法进行属性注入，所以需要将 手机实现类、电池实现类和手机耳机实现类均添加上set方法。（此处不展示了） Xml配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"battery\" class=\"com.ooyhao.spring.bean.HuaweiBattery\"&gt; &lt;property name=\"brand\" value=\"Huawei\"/&gt; &lt;property name=\"name\" value=\"华为手机\"/&gt; &lt;/bean&gt; &lt;!--显示用name和value进行指定参数--&gt; &lt;bean id=\"earPhone1\" class=\"com.ooyhao.spring.bean.HuaweiEarPhone\"&gt; &lt;property name=\"color\" value=\"白色\"/&gt; &lt;property name=\"price\" value=\"59.9\"/&gt; &lt;/bean&gt; &lt;!--通过p-name命名空间--&gt; &lt;bean id=\"earPhone2\" class=\"com.ooyhao.spring.bean.HuaweiEarPhone\" p:color=\"蓝色\" p:price=\"88.88\"/&gt; &lt;bean id=\"huaweiMobilePhone\" class=\"com.ooyhao.spring.bean.HuaweiMobilePhone\"&gt; &lt;!--手机电池 引用set注入--&gt; &lt;property name=\"battery\" ref=\"battery\"/&gt; &lt;!--手机颜色 集合字面量注入--&gt; &lt;property name=\"colors\"&gt; &lt;set&gt; &lt;value&gt;蓝色&lt;/value&gt; &lt;value&gt;红色&lt;/value&gt; &lt;value&gt;黑色&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--手机耳机 集合引用类型注入--&gt; &lt;property name=\"earPhones\"&gt; &lt;list&gt; &lt;ref bean=\"earPhone1\"/&gt; &lt;ref bean=\"earPhone2\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试结果： 1HuaweiMobilePhone{battery=HuaweiBattery{brand='Huawei', name='华为手机'}, colors=[蓝色, 红色, 黑色], earPhones=[HuaweiEarPhone{color='白色', price=59.9}, HuaweiEarPhone{color='蓝色', price=88.88}]} 注意： ​ 可以使用&lt;null/&gt; 或者 &lt;null&gt;&lt;/null&gt; 标签可以将null注入。 &lt;set&gt; 和 &lt;list&gt; 的区别​ &lt;set&gt; 和 &lt;list&gt; 元素的区别不大，其中最重要的不同在于当Spring创建要装配的集合时，所创建的时java.util.Set 还是 java.util.List。 如果时Set的话，所有重复值都会被忽略掉，存放顺序也不会得以保证。不过无论在哪种情况下，&lt;set&gt; 和 &lt;list 都可以用来装配List和Set甚至时数组。 &lt;p&gt; 和 &lt;c-arg&gt; 区别​ &lt;property&gt; 元素为属性的setter方法所提供的功能与 &lt;constructor-arg&gt;元素为构造器所提供的功能时一样的。Spring为&lt;Constructor-arg&gt; 元素提供了c-命名空间作为替代方案，与之类似，Spring提供了更加简洁的p-命名空间，作为 &lt;property&gt; 元素的替代方案。 导入和混合配置​ 在实际开发中，也许时Xml显示配置和JavaConfig显示配置都存在，并且需要XML与XML相互引用，甚至的XML和JavaConfig交叉引用。所以，下面我们来看一下如何进行相互使用： XML配置文件相互引用手机实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HuaweiMobilePhone implements MobilePhone { private Battery battery; //手机颜色 private List&lt;String&gt; colors; public HuaweiMobilePhone(){} public HuaweiMobilePhone(Battery battery){ this.battery = battery; } public HuaweiMobilePhone(List&lt;String&gt; colors) { this.colors = colors; } public HuaweiMobilePhone(Battery battery, List&lt;String&gt; colors){ this.battery = battery; this.colors = colors; } public Battery getBattery() { return battery; } public void setBattery(Battery battery) { this.battery = battery; } public List&lt;String&gt; getColors() { return colors; } public void setColors(List&lt;String&gt; colors) { this.colors = colors; } @Override public String toString() { return \"HuaweiMobilePhone{\" + \"battery=\" + battery + \", colors=\" + colors + '}'; }} 电池实现类： 12345678910111213141516171819202122232425262728293031323334353637public class HuaweiBattery implements Battery{ private String brand; private String name; public HuaweiBattery(){} public HuaweiBattery(String brand, String name){ this.brand = brand; this.name = name; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"HuaweiBattery{\" + \"brand='\" + brand + '\\'' + \", name='\" + name + '\\'' + '}'; }} 电池XMl： 1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"huaweiBattery\" class=\"com.ooyhao.spring.bean.HuaweiBattery\"&gt; &lt;property name=\"brand\" value=\"Huawei\"/&gt; &lt;property name=\"name\" value=\"华为荣耀手机\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 手机XML： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;import resource=\"Battery.xml\"/&gt; &lt;bean id=\"huaweiMobilePhone\" class=\"com.ooyhao.spring.bean.HuaweiMobilePhone\"&gt; &lt;!--手机电池 引用构造注入--&gt; &lt;constructor-arg name=\"battery\" ref=\"huaweiBattery\"/&gt; &lt;!--手机颜色 集合字面量注入--&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;蓝色&lt;/value&gt; &lt;value&gt;红色&lt;/value&gt; &lt;value&gt;黑色&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 测试： 12345678@Testpublic void testRef(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"phone.xml\"); HuaweiMobilePhone bean = context.getBean(HuaweiMobilePhone.class); System.out.println(bean);}//HuaweiMobilePhone{battery=HuaweiBattery{brand='Huawei', name='华为荣耀手机'}, colors=[蓝色, 红色, 黑色]} ​ 在实际开发中，不可能将所有的配置信息写到一个XML文件中，所以存在相互引用，上述代码可以测试出，在xml文件如何引用另外一个xml文件。一般，可以单独创建一个xml文件统一管理，如下： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"Battery.xml\"/&gt; &lt;import resource=\"phone.xml\"/&gt;&lt;/beans&gt; 此时，将手机xml文件中的&lt;import resource=&quot;Battery.xml&quot;/&gt; 删除，而测试引用的使用引用合并的xml文件。如下： 1234567@Testpublic void testRef(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"combineXml.xml\"); HuaweiMobilePhone bean = context.getBean(HuaweiMobilePhone.class); System.out.println(bean);} Java配置类相互引用BatteryConfig配置类： 123456public class BatteryConfig { @Bean public HuaweiBattery huaweiBattery(){ return new HuaweiBattery(\"Huawei\",\"华为手机电池\"); }} PhoneConfig配置类： 123456789101112@Import({BatteryConfig.class})public class PhoneConfig { @Bean public HuaweiMobilePhone huaweiMobilePhone(Battery huaweiBattery){ List&lt;String&gt; colors = new ArrayList&lt;String&gt;(); colors.add(\"白色\"); colors.add(\"黑色\"); colors.add(\"粉色\"); return new HuaweiMobilePhone(huaweiBattery,colors); }} 测试类： 12345678@Testpublic void testJavaConfigRef(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PhoneConfig.class); HuaweiMobilePhone bean = context.getBean(HuaweiMobilePhone.class); System.out.println(bean); //HuaweiMobilePhone{battery=HuaweiBattery{brand='Huawei', name='华为手机电池'}, colors=[白色, 黑色, 粉色]}} ​ 上述代码可以看出，在JavaConfig配置类之间互相引用其实和Xml文件非常相似，在XML文件中是使用&lt;import resource = 'aa.xml' 而在JavaConfig配置类中导入是使用@import({Config.class})注解。通过导入的配置类的class类即可。当然，随着项目的不断扩大，JavaConfig配置类也会越来越多，这种方式来维护就会变得比较麻烦，我们还是可以通过使用统一的JavaConfig配置类来管理JavaConfig。如下： 12345@Import({ BatteryConfig.class, PhoneConfig.class})public class CombineConfig {} Java配置类中引用Xml配置文件上面已经介绍完了Java配置如何引用Java配置，Xml配置如何引用Xml配置，并且如何将其分散的配置文件或配置类进行统一的处理。下面我们看一下如何在Java配置类中引用Xml配置文件： Xml配置文件： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"huaweiBattery\" class=\"com.ooyhao.spring.bean.HuaweiBattery\"&gt; &lt;property name=\"brand\" value=\"Huawei\"/&gt; &lt;property name=\"name\" value=\"华为荣耀手机\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在Java配置类中引入Xml配置文件信息： 123456789101112@ImportResource({\"Battery.xml\"})public class PhoneConfig { @Bean public HuaweiMobilePhone huaweiMobilePhone(Battery huaweiBattery){ List&lt;String&gt; colors = new ArrayList&lt;String&gt;(); colors.add(\"白色\"); colors.add(\"黑色\"); colors.add(\"粉色\"); return new HuaweiMobilePhone(huaweiBattery,colors); }} 由上述代码可以看出，使用@ImportResource标签来导入一个或多个Xml配置文件，(所以代码中的配置文件默认存放在ClassPath的根目录下，如果有异，需要自行修改)。 Xml配置文件中引用Java配置类电池配置类： 123456public class BatteryConfig { @Bean public HuaweiBattery huaweiBattery(){ return new HuaweiBattery(\"Huawei\",\"华为手机电池\"); }} 在Xml配置文件中引入JavaConfig配置类，如下： 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;bean class=\"com.ooyhao.spring.config.BatteryConfig\"/&gt; &lt;context:component-scan base-package=\"com.ooyhao.spring.config\"/&gt; &lt;bean id=\"huaweiMobilePhone\" class=\"com.ooyhao.spring.bean.HuaweiMobilePhone\"&gt; &lt;!--手机电池 引用构造注入--&gt; &lt;constructor-arg name=\"battery\" ref=\"huaweiBattery\"/&gt; &lt;!--手机颜色 集合字面量注入--&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;蓝色&lt;/value&gt; &lt;value&gt;红色&lt;/value&gt; &lt;value&gt;黑色&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 由上述Xml配置文件中可以看出，使用&lt;bean&gt;标签将配置文件导入，则可以在ref中引用到，但是此时测试还是会报错误，需要使用&lt;component-scan&gt; 配合使用，测试代码就不展示了。 总结： ​ 至此，本节内容就算结束了，其中包括使用 Xml配置文件形式装配Bean，使用 JavaConfig配置文件形式装配Bean， 以及 使用自动发现和装配的方式来装配Bean 三种方式。同时涉及了 XMl文件中属性注入的两种方式，构造注入和set注入，JavaConfig配置文件中注入并未做过多的显示，因为这种方式其实跟普通的代码类似，不做主要记录。当然如果需要单独的引用properties配置文件的内容来装配字面量，可以使用@Value(${})来操作。 ​ 基于实际开发环境的复杂度，往往上述三种方式都会在一个项目中共存的，那么如何在Xml中引用Xml，如何在JavaConfig配置文件中引用JavaConfig配置类，如何在Xml配置文件中引用JavaConfig配置类，如何在JavaConfig配置类中引用Xml配置文件。","link":"/2020/01/29/SSM/spring4x/2%E8%A3%85%E9%85%8DBean/"},{"title":"六、渲染Web视图","text":"渲染Web视图 理解视图解析在前面我们已经接触了一个Springmvc中的视图解析器，InternalResourceViewResolver。下图是其继承结构： InternalResourceViewResolver：这个视图解析器应该不陌生，在SSM项目中整合JSP的时候，一般都会使用到这个视图解析器。下面这段代码应该也似曾相识，在SpringMVC.xml文件中都会配置到，这里只是以代码的方式进行配置，最熟悉的莫过于prefix 和 suffix ，分别是指定视图的前缀和后缀，即当视图解析器根据逻辑视图名映射视图的时候，会在Controller的返回值分别在其前后拼接配置好的前后缀，就形成了物理视图，比如Controller中返回的是home.其物理地址就是/WEB-INF/views/home.jsp 。 12345678910111213@Beanpublic ViewResolver viewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/views/\"); resolver.setSuffix(\".jsp\"); resolver.setExposeContextBeansAsAttributes(true); /*将视图解析为JstlView * 查看源码可以看出，默认解析为InternalResourceView * */ resolver.setViewClass(JstlView.class); return resolver;} 我们看一下视图解析器返回的ViewResolver的代码： 1234public interface ViewResolver { @Nullable View resolveViewName(String viewName, Locale locale) throws Exception;} 当给resolveViewName方法传入一个视图名和Locale对象时，会返回一个View实例，View是另外一个接口： 1234567891011121314151617public interface View { String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + \".responseStatus\"; String PATH_VARIABLES = View.class.getName() + \".pathVariables\"; String SELECTED_CONTENT_TYPE = View.class.getName() + \".selectedContentType\"; @Nullable default String getContentType() { return null; } void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)throws Exception;} View接口的任务就是接受模型以及Servlet的request和response对象，并将输出结果渲染到response中。 https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/web.html#mvc-viewresolver spring官网介绍了几种视图解析器。InternalResourceViewResolver一般会用于JSP。TilesViewResolver用于Apache Tiles视图，而FreeMarkerViewResolver和VelocityViewResolver分别用于FreeMarker和Velocity模板视图。 解析JSTL视图使用InternalResourceViewResolver进行视图解析，默认会将视图解析为InternalResourceView实例，但是如果我们在JSP文件中使用JSTL标签去处理了例如国际化的这个格式化和信息的化，我们希望将视图解析为JSTLView。JSTL的格式化标签需要一个Locale对象，以便于恰当的格式化地域相关的值，如日期和货币。 1234567891011121314151617&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;....&lt;body&gt; &lt;!-- &lt;fmt:setLocale value=\"${param.setLocale}\"/&gt; 区域语言的值从传过来的参数中得到 --&gt; &lt;fmt:setLocale value=\"en_US\"/&gt; &lt;!--指定区域语言--&gt; &lt;fmt:bundle basename=\"globalMessages\"&gt; &lt;!-- 指定使用basename为globalMessages的资源文件，也即资源文件第一个单词为globalMessages--&gt; &lt;center&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;fmt:message key=\"email\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"email\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/center&gt; &lt;/fmt:bundle&gt; &lt;/body&gt; 如果我们想要将视图渲染为JSTL视图，只需要在下面添加配置：setViewClass即可。 12345678910111213@Beanpublic ViewResolver viewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/views/\"); resolver.setSuffix(\".jsp\"); resolver.setExposeContextBeansAsAttributes(true); /*将视图解析为JstlView * 查看源码可以看出，默认解析为InternalResourceView * */ resolver.setViewClass(JstlView.class); return resolver;} Spring的JSP库​ Spring提供了两个JSP标签库，用来帮助定义SpringMVC Web的视图。其中一个标签库会用来渲染HTML表单标签，这些标签可以绑定model中的某个属性。另外一个标签库包含了一些工具类标签，我们随时都可以非常便利地使用它们。 JSP标签借助Spring表单绑定标签库中所包含的标签，我们能够将模型对象绑定到渲染后的HTML表单中。 JSP标签 描述 &lt;sf:checkbox&gt; 渲染成一个HTML&lt;input&gt;标签，其中type属性设置为checkbox &lt;sf:checkboxs&gt; 渲染成多个HTML&lt;input&gt;标签，其中type属性设置为checkbox &lt;sf:errors&gt; 在一个HTML&lt;span&gt;中输入输入域的错误 &lt;sf:form&gt; 渲染成一个HTML&lt;form&gt;标签，并为其内部标签暴露绑定路径，用于数据绑定 &lt;sf:hidden&gt; 渲染成一个HTML&lt;input&gt;标签，其中type属性设置为hidden &lt;sf:input&gt; 渲染成一个HTML&lt;input&gt;标签，其中type属性设置为text &lt;sf:label&gt; 渲染成一个HTML&lt;label&gt;标签 &lt;sf:option&gt; 渲染成一个HTML&lt;option&gt;标签，其selected属性根据所绑定的执行设置 &lt;sf:options&gt; 按照绑定的集合、数组或Map，渲染成一个HTML&lt;option&gt;标签列表 &lt;sf:password&gt; 渲染成一个HTML&lt;input&gt;标签，其中type属性设置为password &lt;sf:radiobutton&gt; 渲染成一个HTML&lt;input&gt;标签，其中type属性设置为radio &lt;sf:radiobuttons&gt; 渲染成多个HTML&lt;input&gt;标签，其中type属性设置为radio &lt;sf:select&gt; 渲染为一个HTML&lt;select&gt;标签 &lt;sf:textarea&gt; 渲染为一个HTML&lt;textarea&gt;标签 将标签绑定到模型上如果在jsp中引入spring标签呢？ 1&lt;%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %&gt; sf:form会渲染成一个HTML 标签，但它也会通过 modelAttribute 属性构建针对某个模型对象的上下文信息。在其他的表单绑定标签，会引用这个模型对象的属性。 最初的注册表单： 123456&lt;form method=\"post\" &gt; 用户名：&lt;input name=\"username\" type=\"text\" &gt;&lt;br&gt; 密码：&lt;input name=\"password\" type=\"password\" &gt;&lt;br&gt; 年龄：&lt;input name=\"age\" type=\"number\" &gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt; 使用Spring的标签库： 123456789&lt;sf:form method=\"post\" modelAttribute=\"user\" &gt; 账号：&lt;sf:input path=\"username\"/&gt; &lt;sf:errors path=\"username\" cssClass=\"error\" /&gt;&lt;br&gt; 密码：&lt;sf:password path=\"password\"/&gt; &lt;sf:errors path=\"password\" cssClass=\"error\" /&gt;&lt;br&gt; 年龄：&lt;sf:input path=\"age\"/&gt; &lt;sf:errors path=\"age\" cssClass=\"error\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\" &gt;&lt;br&gt;&lt;/sf:form&gt; 这里需要自定义一个error的css样式 123span.error{ color:red;} 如果不填数据提交，则会出现响应的错误提示。 为什么会出现这种提示信息呢？当然不仅仅是因为将前面的标签换成了Spring的标签。还有就是在Controller中绑定了对象。 123456789101112131415@GetMapping(\"/register\")public String toRegister(Model model){ model.addAttribute(\"user\",new User()); return \"register\";}/*处理表单数据，并验证*/@PostMapping(\"/register\")public String register(@Valid User user, Errors errors){ if (errors.hasErrors()){ return \"register\";//注册失败，重新返回到注册页面 } userService.saveUser(user); return \"redirect:/registerSuccess\";} User： 12345678910111213141516171819public class User implements Serializable { @NotNull @Size(min = 4,max = 20, message = \"{username.size}\") private String username; @NotNull @Size(min = 6,max = 32,message = \"密码需要在{min} 到 {max} 位之间\") private String password; @NotNull(message = \"年龄不能为空\") @Min(value = 1,message = \"年龄要大于等于1\") @Max(value = 150,message = \"年龄需要小于150\") private Integer age; //all or noArgsConstructor //getter and setter //toString} 可以看出，username的@size使用{}大括号来读取配置文件信息，解决了硬编码问题。由于这是输入数据验证，所以默认读取的是classpath下的，ValidationMessages.properties文件。如下： 1username.size = 账号需要在{min} 到 {max} 位之间 而{min}和{max}可以读取到@size中的min和max属性。 如何将错误信息显示到一个地方呢？ 1234567&lt;sf:form method=\"post\" modelAttribute=\"user\" &gt; &lt;sf:errors element=\"div\" path=\"*\" cssClass=\"errors\"/&gt; 账号：&lt;sf:input path=\"username\"/&gt;&lt;br&gt; 密码：&lt;sf:password path=\"password\" /&gt;&lt;br&gt; 年龄：&lt;sf:input path=\"age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\" &gt;&lt;br&gt;&lt;/sf:form&gt; 可以看出，将之前每一个输入框后都有一个对应的sf:errors 用来显示错误信息。而这里进行修改了，将错误信息全部放到了一个div元素中，并且path使用通配符*来描述。 并且css样式定义为了errors: 1234div.errors{ background-color: #ffcccc; border: 2px solid red;} 此时，测试结果如下： 通过上面的测试结果图片可以看出，此时虽然错误信息全部显示在一起了，但是并没有明显的显示是哪一个输入框或是输入属性填写有问题。下面，再次修改： 12345678910&lt;sf:form method=\"post\" modelAttribute=\"user\" &gt; &lt;sf:errors element=\"div\" path=\"*\" cssClass=\"errors\"/&gt; &lt;sf:label path=\"username\" cssErrorClass=\"error\"&gt;账号：&lt;/sf:label&gt; &lt;sf:input cssErrorClass=\"error\" path=\"username\"/&gt;&lt;br&gt; &lt;sf:label path=\"password\" cssErrorClass=\"error\"&gt;密码：&lt;/sf:label&gt; &lt;sf:password cssErrorClass=\"error\" path=\"password\" /&gt;&lt;br&gt; &lt;sf:label path=\"age\" cssErrorClass=\"error\"&gt;年龄：&lt;/sf:label&gt; &lt;sf:input cssErrorClass=\"error\" path=\"age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\" &gt;&lt;br&gt;&lt;/sf:form&gt; 如上代码，我们已经使用div类型的sf:errors来统一显示错误信息，并且将提示信息使用了sf:label进行修饰，使用path进行绑定数据，同时使用cssErrorClass属性来引用出现错误时的css样式。 123456label.error{ color:red;}input.error{ background-color: #ffcccc;} 所以，上述的代码运行结果如： 至此，Spring的JSP标签就告一段落了。 Spring 通用的标签库如何引入在JSP文件中引入spring通用的标签库？ 1&lt;%@ taglib prefix=\"s\" uri=\"http://www.springframework.org/tags\" %&gt; 以上标签大部分使用得很少，因为部分标签已被Spring所淘汰了。 展现国际化信息​ 我们都知道，如果将文本内容硬编码到网页里面，就无法实现动态改变网页显示内容，比如我们在没学习JavaScript之前，构建网页只是使用了HTML+CSS，那么我们的页面一旦写好了，在运行过程中是无法动态修改的。而我们后台系统中，绝大部分数据是以图表的形式展示，而表格的数据是动态切换的，比如：表格分页。分页的时候，网页URL并没有变化，而数据却修改了。而我们如果需要实现国际化也是一样的。所有需要进行国际化编码显示的内容都不可以硬编码到网页中，那么如何实现呢？下面看看Spring提供的方式： 使用到的标签是上面表格中的&lt;s:message code = “”&gt; home.jsp 12345678910111213&lt;%@ taglib prefix=\"s\" uri=\"http://www.springframework.org/tags\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;s:message code=\"article.welcome\"/&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 配置文件中配置引用文件： 1234567891011121314151617/*查询类路径下的message.properties文件*//*@Bean public MessageSource messageSource(){ ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename(\"message\"); return messageSource; }*/@Beanpublic MessageSource messageSource(){ ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasenames(\"classpath:message\"); messageSource.setCacheSeconds(10); return messageSource;} 上述配置类中，这两个类都可以使用，但是有一定的区别：ResourceBundleMessageSource是从classpath中查询message文件，但是ReloadableResourceBundleMessageSource既可以从文件系统file:/，也可以使用classpath来指定类路径下引用，或是web应用的根目录下（没有前缀）查找。 12345-- zh-CN:article.welcome = 欢迎来到spring的大世界-- en-US:article.welcome = welcome to Spring's world 如上图所示：创建两个properties文件，名称如上，en-US表示英文，zh-CN表示中文，由于浏览器更改语言环境不方便，这里我们使用Postman来测试。如下： 注意：Accept-Language的value值，比如zh-CN,需要将-写成中划线，不能写成下划线，否则不会生效。 创建URL链接对于HTML页面来说，是一种最寻常不过的元素了，下面我们来了解一下spring URL标签的神奇： 1234567891011121314151617181920212223242526272829303132333435&lt;%@ taglib prefix=\"s\" uri=\"http://www.springframework.org/tags\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"&lt;s:url value=\"/articles\"/&gt;\" &gt; 所有文章 &lt;/a&gt; |&lt;a href=\"&lt;s:url value=\"/register\"/&gt;\"&gt; 注册 &lt;/a&gt;&lt;br&gt;&lt;h2&gt;使用spring的标签库&lt;/h2&gt;&lt;%--定义一个变量，url的作用域默认在页面，但是可以通过scope进行修改--%&gt;&lt;s:url value=\"/articles\" scope=\"session\" var=\"articlesUrl\"/&gt;&lt;%--在连接中使用，--%&gt;&lt;a href=\"&lt;s:url value=\"${articlesUrl}\"/&gt; \"&gt;所有文章&lt;/a&gt;&lt;br&gt;&lt;%--传参数--%&gt;&lt;s:url value=\"/article\" var=\"article\" &gt; &lt;s:param name=\"page\" value=\"1\"/&gt; &lt;s:param name=\"size\" value=\"2\"/&gt;&lt;/s:url&gt;&lt;a href=\"${article}\"&gt;分页查询文章，page=1 size=2&lt;/a&gt;&lt;br/&gt;&lt;%--路径参数,如果有参数不匹配，则会转为普通参数传递。http://localhost:8080/article/3?name=ouyang--%&gt;&lt;s:url value=\"/article/{id}\" var=\"articleId\"&gt; &lt;s:param name=\"id\" value=\"3\"/&gt; &lt;s:param name=\"name\" value=\"ouyang\"/&gt;&lt;/s:url&gt;&lt;a href=\"${articleId}\"&gt;使用路径变量来获取文章{id = 3}&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 普通使用 &lt;a href=”&lt;s:url value=”/articles”/&gt;” &gt;` ，使用spring url标签，jsp页面渲染时，会将项目名自动与/articles 拼接。当我们将鼠标放在所有文章上面，可以看到下面的提示： 即：单纯普通使用spring的url标签，与jstl标签类似，也会自动拼接上项目名。 定义成变量，设置scope 1234&lt;%--定义一个变量，url的作用域默认在页面，但是可以通过scope进行修改--%&gt;&lt;s:url value=\"/articles\" scope=\"session\" var=\"articlesUrl\"/&gt;&lt;%--在连接中使用，--%&gt;&lt;a href=\"&lt;s:url value=\"${articlesUrl}\"/&gt; \"&gt;所有文章&lt;/a&gt;&lt;br&gt; 上述两行代码则说明，可以先将连接独立成一个变量，然后在进行引用，如使用var来定义连接变量。则在需要使用的地方可以使用${}来引用。同时我们可以看到，可以进行scope的设置，即：设置链接的作用域，链接本身的默认的作用域是page，而我们可以设置为request,session,application等作用域。 查询参数传递 123456&lt;%--传参数--%&gt;&lt;s:url value=\"/article\" var=\"article\" &gt; &lt;s:param name=\"page\" value=\"1\"/&gt; &lt;s:param name=\"size\" value=\"2\"/&gt;&lt;/s:url&gt;&lt;a href=\"${article}\"&gt;分页查询文章，page=1 size=2&lt;/a&gt;&lt;br/&gt; 我们直接看效果： 传递路径参数 123456&lt;%--路径参数,如果有参数不匹配，则会转为普通参数传递。http://localhost:8080/article/3?name=ouyang--%&gt;&lt;s:url value=\"/article/{id}\" var=\"articleId\"&gt; &lt;s:param name=\"id\" value=\"3\"/&gt; &lt;s:param name=\"name\" value=\"ouyang\"/&gt;&lt;/s:url&gt;&lt;a href=\"${articleId}\"&gt;使用路径变量来获取文章{id = 3}&lt;/a&gt; 效果： 结合上述说明和效果图可以发现，我们可以使用{}来定义路径参数，如果存在参数匹配不到路径变量，则自动转为查询参数拼接到请求URL上。 转义内容12345&lt;%--内容转义--%&gt;&lt;s:escapeBody htmlEscape=\"true\"&gt; &lt;h1&gt;这是转义的一级标题标签&lt;/h1&gt;&lt;/s:escapeBody&gt;&lt;h1&gt;这是没有转义的一级标题标签&lt;/h1&gt; 我们可以使用&lt;s:escapeBody&gt;来进行内容转义。效果如下： 使用Thymeleaf如今我们可以发现，jsp慢慢不再使用了，而转向了Thymeleaf，jsp本质来说不是HTML，并且它是依赖于Servlet的，这也就说明，JSP不能独立于Servlet,必须建立于基于Servlet的web容器上。JSP模板不能作为通用的模板（如格式化EMail），也不能用于非Servlet的web应用。 官网：https://www.thymeleaf.org/ Spring整合Thymeleaf 添加POM依赖。 可以进到Thymeleaf官网：https://www.thymeleaf.org/download.html 12345678910&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; 此时，项目的完整POM文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-06-01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-06-01 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--导入SpringMVC依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--hibernate参数校验依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.0.Alpha3&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Jstl标签依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--整合Thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-06-01&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 配置整合Thymeleaf在ServletConfig配置文件中配置相应的信息来整合Thymeleaf模板。 配置Thymeleaf视图解析器： 为了要在Spring中使用Thymeleaf，我们需要配置三个启用Thymeleaf与Spring集成的bean： ThymeleafViewResolver：将逻辑视图名称解析为Thymeleaf模式视图； SpringTemplateEngine：处理模板并渲染结果； TemplateResolver：加载Thymeleaf模板； 123456789101112131415161718192021222324252627/*-------------配置Thymeleaf模板引擎------------*/@Beanpublic SpringResourceTemplateResolver templateResolver(){ SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setTemplateMode(TemplateMode.HTML); resolver.setPrefix(\"/WEB-INF/templates/\"); resolver.setSuffix(\".html\"); resolver.setCharacterEncoding(\"utf-8\"); resolver.setCacheable(true); return resolver;}@Beanpublic SpringTemplateEngine templateEngine(){ SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setTemplateResolver(templateResolver()); engine.setEnableSpringELCompiler(true); return engine;}@Beanpublic ThymeleafViewResolver viewResolver(){ ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setTemplateEngine(templateEngine()); resolver.setCharacterEncoding(\"utf-8\"); return resolver;} 注意：需要在templateResolver和viewResolver中设置字符编码，否则会出现中文乱码的情况。 此时，ServletConfig.java的完整文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/*相当于springmvc.xml*/@Configuration@EnableWebMvc@ComponentScan(basePackages = \"com.ooyhao.spring.**.controller\")public class ServletConfig implements WebMvcConfigurer { /*配置JSP视图解析器*/ /*@Bean public ViewResolver viewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/views/\"); resolver.setSuffix(\".jsp\"); resolver.setExposeContextBeansAsAttributes(true); *//*将视图解析为JstlView * 查看源码可以看出，默认解析为InternalResourceView * *//* resolver.setViewClass(JstlView.class); return resolver; }*/ /*查询类路径下的message.properties文件*/ /*@Bean public MessageSource messageSource(){ ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename(\"message\"); return messageSource; }*/ @Bean public MessageSource messageSource(){ ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasenames(\"classpath:message\"); messageSource.setCacheSeconds(10); return messageSource; } /*配置静态资源的处理*/ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } /*使用Apache Tiles来进行布局，此处不做研究*/ /* @Bean public TilesConfigurer tilesConfigurer(){ TilesConfigurer tilesConfigurer = new TilesConfigurer(); tilesConfigurer.setDefinitions(\"/WEB-INF/layout/tiles.xml\"); tilesConfigurer.setCheckRefresh(true); return tilesConfigurer; } @Bean public TilesViewResolver tilesViewResolver(){ return new TilesViewResolver(); }*/ /*-------------配置Thymeleaf模板引擎------------*/ @Bean public SpringResourceTemplateResolver templateResolver(){ SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setTemplateMode(TemplateMode.HTML); resolver.setPrefix(\"/WEB-INF/templates/\"); resolver.setSuffix(\".html\"); resolver.setCharacterEncoding(\"utf-8\"); resolver.setCacheable(true); return resolver; } @Bean public SpringTemplateEngine templateEngine(){ SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setTemplateResolver(templateResolver()); engine.setEnableSpringELCompiler(true); return engine; } @Bean public ThymeleafViewResolver viewResolver(){ ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setTemplateEngine(templateEngine()); resolver.setCharacterEncoding(\"utf-8\"); return resolver; }} 通过上述配置 Thymeleaf templateResolver 视图解析器，与之前配置JSP视图解析器类似，都是通过逻辑视图名来定位文件，但是这里需要依赖templateEngine。 接下来按照上述代码配置或图中所示的位置编写相应的html页面即可。 Thymeleaf实现表单绑定html文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Blog&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt; &lt;style&gt; span.error{ color:red; } div.errors{ background-color: #ffcccc; border: 2px solid red; } label.error{ color:red; } input.error{ background-color: #ffcccc; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎加入Spring的大家庭&lt;/h1&gt; &lt;form method=\"post\" th:object=\"${user}\" &gt; &lt;div class=\"errors\" th:if=\"${#fields.hasErrors('*')}\" &gt; &lt;ul&gt; &lt;li th:each=\"err : ${#fields.errors('*')}\" th:text=\"${err}\" &gt; Input is Incorrect &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;label th:class=\"${#fields.hasErrors('username')} ? 'error' \"&gt;账号：&lt;/label&gt; &lt;input type=\"text\" th:field=\"*{username}\" th:class=\"${#fields.hasErrors('username')} ? 'error'\"/&gt;&lt;br&gt; &lt;label th:class=\"${#fields.hasErrors('password')} ? 'error' \"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" th:field=\"*{password}\" th:class=\"${#fields.hasErrors('password')} ? 'error'\" /&gt;&lt;br&gt; &lt;label th:class=\"${#fields.hasErrors('age')} ? 'error' \"&gt;年龄：&lt;/label&gt; &lt;input th:field=\"*{age}\" th:class=\"${#fields.hasErrors('age')} ? 'error'\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\" &gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 可以看出：代码中是通过使用fields.hasErrors以及后台的数据校验来判断是否有错误的。后台代码与之前的jsp略有不同： Controller文件1234567891011121314151617181920212223//jsp//处理表单数据，并验证*//*@PostMapping(\"/register\")public String register(@Valid User user, Errors errors){ if (errors.hasErrors()){ return \"register\";//注册失败，重新返回到注册页面 } userService.saveUser(user); return \"redirect:/registerSuccess\";}//thymeleaf/*处理表单数据，并验证*/@PostMapping(\"/register\")public String register(@Valid User user, BindingResult bindingResult,Model model){ if (bindingResult.hasErrors()){ System.out.println(\"错误数目:\" + bindingResult.getErrorCount()); model.addAttribute(user); return \"register\";//注册失败，重新返回到注册页面 } userService.saveUser(user); return \"redirect:/registerSuccess\";} jsp使用spring的标签时是用Errors来判断，而html使用Thymeleaf时是使用BindingResult来进行判断。上述代码显示了不同之处。 效果图 总结： ​ 至此，本节已经学习了Spring如何整合JSP，使用Spring的标签，同时也接触了当前正在逐渐替代JSP的Thymeleaf，也实现了之前使用JSP同样地表单双向绑定的效果。 使用Thymeleaf实现表单双向绑定参考了 https://blog.csdn.net/z28126308/article/details/54429853","link":"/2020/01/29/SSM/spring4x/6%E6%B8%B2%E6%9F%93Web%E8%A7%86%E5%9B%BE/"},{"title":"14.Spring Boot之数据持久化","text":"Spring Boot之数据持久化 在我们实际项目中，数据的持久化是必不可少的一部分。那么，接下来我们来看一下使用SpringBoot的数据持久化操作的几种方式。分别是SpringBoot/Spring自带的JdbcTemplate，mybatis以及JPA。 下面我们就一一来使用一下： JdbcTemplateCRUD我们先使用JdbcTemplate来实现数据库操作的增删改查。 创建一个SpringBoot项目，并导入下列依赖： 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置数据源： 12345spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT 创建数据库表： 123456CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(64) DEFAULT NULL, `address` varchar(64) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 实体类： 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class User { private Integer id; private String username; private String address;} 下面真正进入JdbcTemplate操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate; //增删直接使用update,查询使用Query public Integer addUser(User user){ String insert = \"insert into user (username,address) values (?,?)\"; int update = jdbcTemplate.update(insert, user.getUsername(), user.getAddress()); return update; } //更新 public Integer updateUsernameById(User user){ String update = \" update user set username = ? where id = ? \"; int rows = jdbcTemplate.update(update, user.getUsername(), user.getId()); return rows; } //删除 public Integer deleteUserById(Integer id){ String delete = \"delete from user where id = ?\"; int rows = jdbcTemplate.update(delete, id); return rows; } /*public List&lt;User&gt; findAllUsers(){ String query = \" select * from user \"; //属性名称和数据库字段名称是一一对应的话，就可以使用这种方式，如果是相同的话，就需要考虑使用RowMapper List&lt;User&gt; users = jdbcTemplate.query(query,new BeanPropertyRowMapper&lt;&gt;(User.class)); return users; }*/ public List&lt;User&gt; findAllUsers(){ String query = \" select * from user \"; List&lt;User&gt; users = jdbcTemplate.query(query, new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { //游标自动会移动，只需要取值就可以 int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String address = rs.getString(\"address\"); User user = new User(id,username,address); return user; } }); return users; }} 可以直接将JdbcTemplate 从Spring容器中注入进来。说明： 使用JdbcTemplate，增删改都是使用update方法，查使用query方法。 查询时，如果实体属性名和数据库字段名是一一对应的，则可以使用BeanPropertyRowMapper对象。如果不是一一对应的，需要手动去实现RowMapper接口。 上面就已经简单的实现了，使用JdbcTemplate来操作数据库表的增删改查操作。 多数据源下面我们来利用JdbcTemplate创建多数据源： 首先我们先再创建一个数据库，命名为springboot2. 创建项目并导入相应的依赖，至于依赖，是与前面一样的，这里不再赘述。我们需要在配置文件中配置两个数据源信息。 123456789101112spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.one.username=rootspring.datasource.one.password=rootspring.datasource.one.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.one.url=jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMTspring.datasource.two.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.two.username=rootspring.datasource.two.password=rootspring.datasource.two.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.two.url=jdbc:mysql://127.0.0.1:3306/springboot2?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT 可以看出，我们是分别使用spring.datasource.one 和 spring.datasource.two 为前缀来配置两个数据源。 我们先声明两个数据源： 123456789101112131415@Configurationpublic class DataSourceConfig { @Bean @ConfigurationProperties(prefix = \"spring.datasource.one\") public DataSource dataSourceOne(){ DruidDataSource build = DruidDataSourceBuilder.create().build(); return build; } @Bean @ConfigurationProperties(prefix = \"spring.datasource.two\") public DataSource dataSourceTwo(){ DruidDataSource build = DruidDataSourceBuilder.create().build(); return build; }} 这里可以看出，我们使用了注解@ConfigurationProperties注解，来实现类型安全的注入。其次我们创建出两个不同JdbcTemplate实例并加入到Spring容器中： 123456789101112@Configurationpublic class JdbcTemplateConfig { //配置两个JdbcTemplate @Bean public JdbcTemplate jdbcTemplateOne(@Qualifier(\"dataSourceOne\") DataSource dataSource1){ return new JdbcTemplate(dataSource1); } @Bean public JdbcTemplate jdbcTemplateTwo(@Qualifier(\"dataSourceTwo\") DataSource dataSource2){ return new JdbcTemplate(dataSource2); }} 至于实体类也与前面一样。我们看一下UserService： 123456789101112131415161718192021@Servicepublic class UserService { @Autowired @Qualifier(\"jdbcTemplateOne\") private JdbcTemplate jdbcTemplateOne; @Autowired @Qualifier(\"jdbcTemplateTwo\") private JdbcTemplate jdbcTemplateTwo; public List&lt;User&gt; findAllUserByTemplateOne(){ return jdbcTemplateOne.query(\"select * from user \", new BeanPropertyRowMapper&lt;&gt;(User.class)); } public List&lt;User&gt; findAllUserByTemplateTwo(){ return jdbcTemplateTwo.query(\"select * from user\", new BeanPropertyRowMapper&lt;&gt;(User.class)); }} 我们通过测试，可以发现两个查询方法查到的数据是来自不同的数据库的。 MybatisCRUD依赖： 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 与之前不同的是，这里需要导入Mybatis依赖。 配置文件： 1234567spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMTmybatis.mapper-locations=classpath:mapper/**/*.xml 可以看出，我们这里指定了Mapper.xml文件的位置。 实体类与前面一致。下面我们看一下UserMapper接口.至于Mapper接口如何被扫描呢，可以在每一个Mapper接口上都用@Mapper 注解进行标识，也可以在主程序上用@MapperScan(basePackage=) 来统一扫描。 1234567//@Mapperpublic interface UserMapper { List&lt;User&gt; findAllUser(); Integer insertUser(User user); Integer updateUsernameById(User user); Integer deleteUserById(Integer id);} UserMapper.xml文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.hao.springbootmybatis.mapper.UserMapper\"&gt; &lt;insert id=\"insertUser\"&gt; insert into user (username, address) values (#{username}, #{address}) &lt;/insert&gt; &lt;update id=\"updateUsernameById\"&gt; update user set username = #{username} where id = #{id} &lt;/update&gt; &lt;delete id=\"deleteUserById\"&gt; delete from user where id = #{id} &lt;/delete&gt; &lt;select id=\"findAllUser\" resultType=\"com.hao.springbootmybatis.bean.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 主程序，使用@MapperScan注解标注： 1234567@SpringBootApplication@MapperScan(basePackages = \"com.hao.springbootmybatis.mapper\")public class SpringbootMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringbootMybatisApplication.class, args); }} 测试代码： 12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass SpringbootMybatisApplicationTests { @Autowired private UserMapper userMapper; @Test void testFindAllUser() { List&lt;User&gt; allUser = userMapper.findAllUser(); for (User user : allUser){ System.out.println(user); } } @Test public void testInsertUser(){ User user = new User(); user.setUsername(\"孙悟空\"); user.setAddress(\"花果山\"); System.out.println(userMapper.insertUser(user)); } @Test public void testUpdateUsernameById(){ User user = new User(); user.setUsername(\"齐天大圣\"); user.setId(7); System.out.println(userMapper.updateUsernameById(user)); } @Test public void testDeleteUserById(){ System.out.println(userMapper.deleteUserById(6)); }} 这里可以看出，我们通过配置文件指定了Mapper.xml文件是放在Resources中的，但是如果我们需要把xml文件放在与java文件同包下，则需要修改一下POM文件： 12345678910111213141516171819&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 表示在执行打包编译的时候，将src/main/java包中的xml文件 和 src/main/resources目录下的文件都打包进去。 多数据源Mybatis的动态数据源配置要比前面的JdbcTemplate的数据源配置麻烦一点。下面我们开始： 创建SpringBoot项目并引入依赖，与上面的普通项目一致，不再赘述。 总的项目结果如下： 我们先看一下配置文件。application.properties: 123456789101112spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.one.username=rootspring.datasource.one.password=rootspring.datasource.one.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.one.url=jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMTspring.datasource.two.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.two.username=rootspring.datasource.two.password=rootspring.datasource.two.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.two.url=jdbc:mysql://127.0.0.1:3306/springboot2?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT User实例这里也不再说，看一下数据源配置DataSourceConfig，与前面的JdbcTemplate也是大同小异的。 12345678910111213@Configurationpublic class DataSourceConfig { @Bean @ConfigurationProperties(prefix = \"spring.datasource.one\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasource.two\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} MybatisConfigOne: 123456789101112131415161718192021222324252627@Configuration@MapperScan(basePackages = \"com.hao.springbootmybatisdynamicdatasource.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactory1\")public class MybatisConfigOne { @Resource(name = \"dataSourceOne\") DataSource dsOne; @Bean public SqlSessionFactory sqlSessionFactory1(){ SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); try { bean.setDataSource(dsOne); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mapper1/**/*.xml\")); return bean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } @Bean public SqlSessionTemplate sqlSessionTemplate1(){ return new SqlSessionTemplate(sqlSessionFactory1()); }} MybatisConfigTwo: 1234567891011121314151617181920212223242526@Configuration@MapperScan(basePackages = \"com.hao.springbootmybatisdynamicdatasource.mapper2\",sqlSessionFactoryRef = \"sqlSessionFactory2\")public class MybatisConfigTwo { @Resource(name = \"dataSourceTwo\") DataSource dsTwo; @Bean public SqlSessionFactory sqlSessionFactory2(){ SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); try { bean.setDataSource(dsTwo); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:/mapper/mapper2/**/*.xml\")); return bean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } @Bean public SqlSessionTemplate sqlSessionTemplate2(){ return new SqlSessionTemplate(sqlSessionFactory2()); }} 可以看到这两个Mybatis的配置文件中，分别需要指明自己的SqlSessionFactory需要获取哪里的mapper.xml文件，就是需要设置mapper.location。 然后就是创建的相应的UserMapper1.java 和 UserMapper1.xml， 以及 UserMapper2.java和UserMapper2.xml。 123public interface UserMapper1 { List&lt;User&gt; findAllUser();} UserMapper1.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.hao.springbootmybatisdynamicdatasource.mapper1.UserMapper1\"&gt; &lt;select id=\"findAllUser\" resultType=\"com.hao.springbootmybatisdynamicdatasource.bean.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; UserMapper2.java 和 UserMapper2.xml文件只是文件名称不一样，其他类似，测试结果就可以发现，通过UserMapper1获取到的是数据库Springboot库中User表的数据。而通过UserMapper2获取到的是数据库SpringBoot2库中User表的数据。 注意：如果我们的UserMapper.xml文件和UserMapper.java文件放在同一个目录下，我们只需要在maven中配置下面的就可以了，而不需在SqlSessionFactory中设置Mapper.location。 12345678910111213141516171819&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; JPA至于JPA的概念就不多介绍，JPA是一套标准，一套规范，而hibernate是JPA的实现。相当于说使用JPA实际上底层使用的还是hibernate。 CRUD下面我们使用JPA来实现数据库表的增删改查。 引入依赖： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;!-- 引入Spring Data JPA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件，application.properties: 123456789101112spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMTspring.jpa.show-sql=truespring.jpa.database=mysqlspring.jpa.database-platform=mysql# 表数据与实体类是否一致spring.jpa.hibernate.ddl-auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect 这里不用自己先创建表，jpa会根据实体类自动去创建表。 12345678910//如果不指定名字，则与类名同名@Entity(name = \"t_book\")@Datapublic class Book { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; private String author;} 下面我们需要自定义一个接口，并实现JPA的JpaRepository: 1public interface BookDao extends JpaRepository&lt;Book,Integer&gt; {} 此时我们可以只需要实现接口，而不新增方法，就可以实现一些基本的增删改查了。因为Jpa中默认实现了一套基本的CRUD操作。 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@SpringBootTestclass SpringbootJpaApplicationTests { @Autowired private BookDao bookDao; @Test void insert() { Book book = new Book(); book.setName(\"三国演义\"); book.setAuthor(\"罗贯中\"); bookDao.save(book); } @Test void update(){ Book book = new Book(); book.setId(1); book.setName(\"三国演义\"); book.setAuthor(\"luoguanzhong\"); bookDao.saveAndFlush(book); } @Test void delete(){ bookDao.deleteById(1); } @Test void find1(){// List&lt;Book&gt; books = bookDao.findAll(); System.out.println(bookDao.findById(2)); //Optional[Book(id=2, name=水浒传, author=施耐庵)] } @Test void find2(){ List&lt;Book&gt; books = bookDao.findAll(Sort.by(Sort.Direction.DESC, \"id\")); //[Book(id=4, name=红楼梦, author=曹雪芹), Book(id=3, name=西游记, author=吴承恩), // Book(id=2, name=水浒传, author=施耐庵), Book(id=1, name=三国演义, author=罗贯中)] System.out.println(books); } @Test void find3(){ Pageable pageable = PageRequest.of(0,2); Page&lt;Book&gt; bookPage = bookDao.findAll(pageable); long totalElements = bookPage.getTotalElements(); System.out.println(\"总记录数：\"+totalElements); System.out.println(\"当前页记录数：\"+bookPage.getNumberOfElements()); System.out.println(\"每页记录数：\"+bookPage.getSize()); System.out.println(\"总页数：\"+bookPage.getTotalPages()); System.out.println(\"查询结果：\"+bookPage.getContent()); System.out.println(\"当前页(从0开始记录)：\"+bookPage.getNumber()); System.out.println(\"是否为首页：\"+bookPage.isFirst()); System.out.println(\"是否为尾页：\"+bookPage.isLast()); }} 如上，这些方法都是默认就有的，那么如果我们需要自定义方法呢。可以按照下面的命名规范来设计方法，同样也可以不用写SQL，JPA会自动完成： 根据上面的规范，我们自定义几个： 12345public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { Book findBookById(Integer id); List&lt;Book&gt; findBookByIdGreaterThan(Integer id); List&lt;Book&gt; findBookByIdLessThanOrNameContaining(Integer id, String name);} 解释： findBookById. 顾名思义就是，根据id查询Book findBookByIdGreaterThan. 查询Book信息，满足Id大于指定的值 findBookByIdLessThanOrNameContaining. 查询Book，满足Id小于指定值 或者 name包含指定字符串的。 自定义SQL 但是有一些需求可能简单实用方法命名查询就无法实现了，比如：查询Id最大的Book。此时，我们就需要自定义方法和SQL了。 12@Query(nativeQuery = true, value = \" select * from t_book where id = (select max(id) from t_book) \")Book getMaxIdBook(); 说明一下，习惯实用原生的SQL的同学，如果不在``@Query中加入nativeQuery=true，会自动将其以JPQL来处理。所以，这里需要使用nativeQuery=true` 标注一下。 上面的是查询，下面我们看一下修改： 123456789@Query(nativeQuery = true,value = \" insert into t_book (name,author) values (?1,?2) \")@Modifying //修改是需要加这个注解。 修改(add/insert/update)@Transactional //Executing an update/delete query (add, insert, delete)Integer addBook(String name,String author);@Query(nativeQuery = true,value = \" insert into t_book (name,author) values (:name,:author) \")@Modifying@TransactionalInteger addBook2(@Param(\"name\") String name,@Param(\"author\") String author); 注意上面的注解，修改的时候需要加@Modifying 和 @Transactional 注解的。这里的修改包括 增加，修改，删除。 多数据Spring Data JPA 整合多数据源。项目结构图如下： 依赖与前面一样，就不再赘述。配置文件如下： 123456789101112131415161718spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.one.username=rootspring.datasource.one.password=rootspring.datasource.one.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.one.url=jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMTspring.datasource.two.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.two.username=rootspring.datasource.two.password=rootspring.datasource.two.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.two.url=jdbc:mysql://127.0.0.1:3306/springboot2?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMTspring.jpa.properties.show-sql=truespring.jpa.properties.database=mysqlspring.jpa.properties.database-platform=mysqlspring.jpa.properties.hibernate.ddl-auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect 配置两个数据源：DataSourceConfig 12345678910111213141516@Configurationpublic class DataSourceConfig { @Bean @Primary //优先使用 @ConfigurationProperties(\"spring.datasource.one\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(\"spring.datasource.two\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} JpaConfigOne,配置与之前的Mybatis配置大致类似： 123456789101112131415161718192021222324252627@Configuration@EnableJpaRepositories(basePackages = \"com.hao.springbootjpamultidatasource.dao1\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBean1\", transactionManagerRef = \"platformTransactionManager1\")public class JpaConfigOne { @Autowired @Qualifier(\"dataSourceOne\") private DataSource dataSource; @Autowired private JpaProperties jpaProperties; @Bean @Primary public LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBean1(EntityManagerFactoryBuilder builder){ return builder.dataSource(dataSource) .properties(jpaProperties.getProperties()) .persistenceUnit(\"pu1\") .packages(\"com.hao.springbootjpamultidatasource.bean\") .build(); } @Bean public PlatformTransactionManager platformTransactionManager1(EntityManagerFactoryBuilder builder){ return new JpaTransactionManager(localContainerEntityManagerFactoryBean1(builder).getObject()); }} JpaConfigTwo,配置信息： 1234567891011121314151617181920212223242526@Configuration@EnableJpaRepositories(basePackages = \"com.hao.springbootjpamultidatasource.dao2\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBean2\", transactionManagerRef = \"platformTransactionManager2\")public class JpaConfigTwo { @Autowired @Qualifier(\"dataSourceTwo\") private DataSource dataSource; @Autowired private JpaProperties jpaProperties; @Bean public LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBean2(EntityManagerFactoryBuilder builder){ return builder.dataSource(dataSource) .properties(jpaProperties.getProperties()) .persistenceUnit(\"pu2\") .packages(\"com.hao.springbootjpamultidatasource.bean\") .build(); } @Bean public PlatformTransactionManager platformTransactionManager2(EntityManagerFactoryBuilder builder){ return new JpaTransactionManager(localContainerEntityManagerFactoryBean2(builder).getObject()); }} 上面的@EnableJpaRepositories注解指明了需要扫描哪个包。 实体类Book与前面的一样。下面声明两个Dao。 dao1/BookDao1: 1public interface BookDao1 extends JpaRepository&lt;Book, Integer&gt; {} dao1/BookDao2: 1public interface BookDao2 extends JpaRepository&lt;Book, Integer&gt; {} 测试： 12345678910111213141516171819@SpringBootTestclass SpringbootJpaMultidatasourceApplicationTests { @Autowired private BookDao1 bookDao1; @Autowired private BookDao2 bookDao2; @Test void contextLoads() { System.out.println(bookDao1.findAll()); } @Test void test(){ System.out.println(bookDao2.findAll()); }} 以上可以分别查询到两个数据库的表的信息。结果不再显示。","link":"/2020/03/04/SSM/springboot/14.SpringBoot%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"title":"03.视图层开发","text":"视图层开发 1.简介使用SpringBoot步骤： 1）创建SpringBoot应用，选择我们需要的模块开发 2）SpringBoot已经将这些场景配置好了。只需要在配置文件中配置少量配置就可以运行起来了 3）编写业务代码 自动配置需要理解： 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置，能不能扩展？？ 12xxxxAutoConfiguration:帮我们给容器中自动配置组件xxxxProperties:配置类来封装配置文件的内容 2.SpringBoot对静态资源的映射规则12@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties {} 1）所有/webjars/**，都去 classpath:/META-INF/resources/webjars/找资源 ​ webjars：以jar包的方式引入静态资源 https://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1-1/jquery.js 123456&lt;!--jQuery--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-1&lt;/version&gt;&lt;/dependency&gt; 2) “/**” 访问当前项目的任何资源（静态资源的文件夹）resources就是类路径下的根目录 123456\"classpath:/META-INF/resources/\", :resources/META-INF/resources/\"classpath:/resources/\", :resources/resources/\"classpath:/static/\", :resources/static/\"classpath:/public/\" :resources/public/\"/\" 当前项目的根路径 localhost:8080/jquery.js == 去静态文件夹下的jquery.js 3）欢迎页，静态资源文件夹下的所有index.html；被”/**”映射 localhost:8080 4）所有的**/favicon.ico 都是在静态资源文件夹下找 依然可以在application.properties文件夹下进行自动指定 12spring.resources.static-locations=classpath:/ooyhao/,# 但是自己指定了的话，原有的静态文件路径就不再生效了 3.模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf;语法更简单，功能更强大；**thymeleaf 官网 ** 1、引入thymeleaf12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 3.0.9&lt;/dependency&gt;切换thymeleaf版本 (可以切换，但是现在已经是最新的版本了)&lt;properties&gt; &lt;!-- 布局功能的支持程序 --&gt; &lt;!-- thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 2、Thymeleaf使用12345678910@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; //前后缀,只要把html页面放在classpath:/templates/，thymeleaf就能自动渲染了} 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； SpringBoot 的自动配置 12345# 关于 thymeleaf 的配置信息这里使用默认配置即可(下面均为默认配置)spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.mode=HTMLspring.thymeleaf.suffix=.htmlspring.thymeleaf.encoding=utf-8 导入thymeleaf的名称空间，并使用thymeleaf语法； 12345678910111213&lt;!DOCTYPE html&gt;&lt;!--导入thymeleaf的名称空间--&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"${hello}\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1.th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 123&lt;h1&gt;你好&lt;/h1&gt; 使用th:text 输出：&lt;h1&gt;你好&lt;/h1&gt;使用th:utext输出：你好（加粗） 1234567891011121314&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;图书编号&lt;/td&gt; &lt;td&gt;图书名称&lt;/td&gt; &lt;td&gt;图书作者&lt;/td&gt; &lt;td&gt;图书价格&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"book : ${books}\"&gt; &lt;td th:text=\"${book.id}\"&gt;&lt;/td&gt; &lt;td th:text=\"${book.name}\"&gt;&lt;/td&gt; &lt;td th:text=\"${book.author}\"&gt;&lt;/td&gt; &lt;td th:text=\"${book.price}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2.表达式？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344Simple expressions:(表达式语法)Variable Expressions: ${...}:获取变量值(OGNL);1.获取对象的属性、调用方法2.使用内置的基本对象：${session.foo}3.内置的一些工具对象：Selection Variable Expressions: *{...}:选择表达式;和${}在功能上是一样；补充：配合 th:object=\"${session.user}&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*{lastName}\"&gt;Pepper&lt;/span&gt;&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;Message Expressions: #{...}：获取国际化内容Link URL Expressions: @{...}：定义URL；@{/order/process(execId=${execId},execType='FAST')}Fragment Expressions: ~{...}：片段引用表达式&lt;div th:insert=\"~{commons :: main}\"&gt;...&lt;/div&gt;Literals（字面量）Text literals: 'one text' , 'Another one!' ,…Number literals: 0 , 34 , 3.0 , 12.3 ,…Boolean literals: true , falseNull literal: nullLiteral tokens: one , sometext , main ,…Text operations:（文本操作）String concatenation: +Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算）Binary operators: + , - , * , / , %Minus sign (unary operator): -Boolean operations:（布尔运算）Binary operators: and , orBoolean negation (unary operator): ! , notComparisons and equality:（比较运算）Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符）If-then: (if) ? (then)If-then-else: (if) ? (then) : (else)Default: (value) ?: (defaultvalue)Special tokens:No-Operation: _ 示例 html文件： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:text 将div里面的文本内容设置为传递过来的--&gt;&lt;div th:text=\"${hello}\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;div th:utext=\"${hello}\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;!--th:each每次遍历都会生成当前这个标签：3个h4--&gt;&lt;h4 th:text=\"${user}\" th:each=\"user:${users}\"&gt;&lt;/h4&gt;&lt;hr/&gt;&lt;h4&gt; &lt;span th:each=\"user:${users}\"&gt;[[${user}]]&lt;/span&gt;&lt;/h4&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; controller文件： 123456789@Controllerpublic class HelloController { @GetMapping(\"/hello\") public String hello(Map&lt;String,Object&gt; map){ map.put(\"hello\",\"&lt;h1&gt;你好&lt;/h1&gt;\"); map.put(\"users\", Arrays.asList(\"张三\",\"李四\",\"王五\")); return \"message\"; }} 效果图： 4、Springmvc自动配置https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc 1.Spring MVC Auto-configurationSpringBoot自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置： Spring Boot provides auto-configuration for Spring MVC that works well with mostapplications. The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染，是请求转发，还是重定向） ContentNegotiatingViewResolver：组合所有的视图解析器的 如何定制：我们可以自己给容器添加一个视图解析器；自动的将其组合进来、 Support for serving static resources, including support for WebJars (coveredlater in this document)). 静态资源文件jar与webjars Automatic registration of Converter, GenericConverter, and Formatter beans. 自动注册了Converter, GenericConverter, and Formatter Converter：转换器；public String hello(User user):类型转换组件 Formatter：格式化器：2017-12-17 ==&gt; Date 自己添加格式化器，我们只需要放到容器中即可 12345678910111213141516If you need to add or customize converters, you can use Spring Boot’s HttpMessageConverters class, as shown in the following listing:import org.springframework.boot.autoconfigure.web.HttpMessageConverters;import org.springframework.context.annotation.*;import org.springframework.http.converter.*;@Configurationpublic class MyConfiguration { @Bean public HttpMessageConverters customConverters() { HttpMessageConverter&lt;?&gt; additional = ... HttpMessageConverter&lt;?&gt; another = ... return new HttpMessageConverters(additional, another); }} Support for HttpMessageConverters (coveredlater in this document). HttpMessageConverters：SpringMVC用来装换http请求和相应的；User–Json HttpMessageConverters是从容器中确定的，获得所有的HttpMessageConverter； 自己给容器中添加，只需要将自己的组件注册到容器中（@Bean, @Component） Automatic registration of MessageCodesResolver (coveredlater in this document). 定义错误代码生成规则。 Static index.html support. 静态资源首页 Custom Favicon support (covered later in thisdocument). 图标 Automatic use of a ConfigurableWebBindingInitializer bean (coveredlater in this document). 我们自己可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器中） 初始化web数据绑定器WebDataBinder 请求数据 == &gt; JavaBean org.springframework.boot.autoconfigure.web ：web的所有自动配置场景。 If you want to keep Spring Boot MVC features and you want to add additionalMVC configuration (interceptors, formatters, viewcontrollers, and other features), you can add your own @Configuration class of typeWebMvcConfigurer but without @EnableWebMvc. If you wish to provide custominstances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, orExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapterinstance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configurationannotated with @EnableWebMvc. 2.扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个配置类（@Configuration）是WebMvcConfigurer类型，不能标注@EnableWebMvc 既保留了所有的自动配置，也能用我们扩展的配置。 123456789@Configurationpublic class MyMvcConfig implements WebMvcConfigurer{ @Override public void addViewControllers(ViewControllerRegistry registry){ //浏览器发送 /hello请求，来到message页面 registry.addViewController(\"/ooyhao\").setViewName(\"message\"); }} 原理： 1）WebMvcAutoConfiguration是springmvc的自动配置类 2）新版本使用的是WebMvcConfigurer，而不是WebMvcConfigurerAdapter， 123456789101112131415161718192021222324@Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { @Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); //一个参考实现,将所有的WebMvcConfigurer相关的配置都一起调用起来 //@Override //public void addViewControllers(ViewControllerRegistry registry) { //for (WebMvcConfigurer delegate : this.delegates) { //delegate.addViewControllers(registry); //} //} } }} 3）容器中所有的WebMvcConfigurer都会一起起作用 4）我们的配置类也会被调用。 效果：springmvc的自动配置和我们的扩展配置都会起作用 3.全面接管SpringMvcSpringBoot对SpringMVC的自动配置不需要了。所有的配置都是我们自己配置。所有的SpringMVC自动配置都失效了。 我们需要在配置类上添加@EnableWebMvc即可 12345678910111213/** * @author ooyhao */@EnableWebMvc@Configurationpublic class MyMvcConfig implements WebMvcConfigurer{ @Override public void addViewControllers(ViewControllerRegistry registry){ //浏览器发送 /hello请求，来到message页面 registry.addViewController(\"/ooyhao\").setViewName(\"message\"); }} 原理： 1） 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc {} 2） 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { 3） 123456789@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class })public class WebMvcAutoConfiguration { 4）@EnableWebMvc将WebMvcConfigurationSupport组件导入进来， 5）导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能 5.如何修改SpringBoot的默认配置模式： 1）SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean,@Component)如果有就用用户配置的，如果没有，才自动配置，如果有些组件可以有多个（例如：ViewResolver）将用户配置的和默认的组合起来 2）在SpringBoot中会有非常多的*Configuration帮助我们扩展配置。 3）在springboot中也会用很多的xxxCustomizer帮助我们进行定制配置 6.RestfulCRUD1.默认访问首页1234567891011121314151617181920//所有的webMvcConfigurer组件都会一起起作用@Beanpublic WebMvcConfigurer webMvcConfigurer(){ return new WebMvcConfigurer(){ @Override public void addViewControllers(ViewControllerRegistry registry) { //注意：urlPath=RequestMapping(value) // viewName=return \"\";(原handler中返回的视图名) registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); } };}// 或者是@RequestMapping(value = {\"/\",\"/index.html\"})public String index(){ return \"index\";} 2.国际化1）编写国际化配置文件 2）使用ResourceBundleMessageSource管理国际化资源文件 3）在页面使用fmt:message取出国际化内容 以前使用需要1,2,3.现在使用SpringBoot， 步骤： 1.编写国际化配置文件，抽取页面需要显示的国际化消息 2.SpringBoot自动配置好了管理国际化资源文件的组件自动配置源码： 1234public class MessageSourceAutoConfiguration { private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫message.properties;} 3.去页面获取国际化的值解决中文乱码，file–&gt;other setting–&gt;default setting 实现了国际化效果 1spring.messages.basename=i18n.login html 1234567891011121314151617181920&lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@{/asserts/img/bootstrap-solid.svg}\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#{login.username}\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#{login.password}\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" th:placeholder=\"#{login.password}\" placeholder=\"Password\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"&gt;[[#{login.remember}]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt; 效果：根据浏览器语言设置的信息切换国际化； 原理：国际化locale（区域信息对象）；LocaleResolver（获取区域信息对象） 1234567891011121314@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\")public LocaleResolver localeResolver() { if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;}//默认的就是根据请求头带来的区域信息获取Locale进行国际化 4.点击链接切换国际化12345678910111213141516171819202122/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver{ @Override public Locale resolveLocale(HttpServletRequest request) { //解析区域信息 String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] strings = l.split(\"_\"); locale = new Locale(strings[0],strings[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {}} 加入到SpringBoot容器中 12345 //添加组件@Beanpublic LocaleResolver localeResolver(){ return new MyLocaleResolver();} 3.登录在开发期间，模板引擎页面修改以后， 要实时生效： 1）禁用模板引擎的缓存 12#禁用缓存spring.thymeleaf.cache=false 2）页面修改完成以后ctrl+f9，重新编译 登录错误消息显示 12&lt;!--判断--&gt;&lt;p style=\"color:red;\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"&gt;&lt;/p&gt; 4.拦截器进行登录检查1234567891011121314151617181920/** * 登录检查 */public class LoginHandlerInterceptor implements HandlerInterceptor { /** * 目标方法执行之前 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { String loginUser = (String) request.getSession().getAttribute(\"loginUser\"); if(loginUser != null){ return true; } request.setAttribute(\"msg\",\"没有权限，请登录\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }} 如何添加拦截器： ​ 1.编写一个自定义拦截器类并实现HandlerInterceptor接口；编写相应的逻辑 ​ 2.在webmvc配置类中配置配置注册拦截器 12345678910111213141516171819202122232425262728293031323334353637383940414243//@EnableWebMvc //不要完全接管SpringMVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer{ @Override public void addViewControllers(ViewControllerRegistry registry){ //浏览器发送 /hello请求，来到message页面 registry.addViewController(\"/ooyhao\").setViewName(\"message\"); } //所有的webMvcConfigurer组件都会一起起作用 @Bean public WebMvcConfigurer webMvcConfigurer(){ return new WebMvcConfigurer(){ @Override public void addViewControllers(ViewControllerRegistry registry) { //注意：urlPath=RequestMapping(value) // viewName=return \"\";(原handler中返回的视图名) registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(\"/**\") //拦截任意请求 .excludePathPatterns(\"/index.html\",\"/\",\"index\",\"/user/login\",\"/webjars/**\",\"/asserts/**\") //排除拦截请求 //静态资源不用排除，SpringBoot已经做好了静态资源映射，拦截器处理是可以不用考虑静态资源 ; } }; } //添加组件国际化 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); }} 5.CRUD员工列表1.RestfulCRUDURI：/资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD RestfulCRUD 查询 getEmp emp–GET 添加 addEmp?xxx emp–POST 修改 update?id=xxx&amp;xxx=xxx emp/{id}–PUT 删除 deleteEmp?id=1 emp/{id}–DELETE 2.实验的请求架构 请求的URI 请求方式 查询所有员工 emps GET 查询某个员工 emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查询员工信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3.员工列表1.thymeleaf公共页面元素抽取1234567891011121314151.抽取公共片段，利用th:fragment&lt;div th:fragment=\"copy\"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2.引入公共片段 &lt;div th:insert=\"~{footer :: copy}\"&gt;&lt;/div&gt;~{templatename::selector}:模板名::选择器 &lt;div th:replace=\"~{dashboard::topbar}\"&gt;&lt;/div&gt;~{templatename::fragmentname}:模板名::片段名 &lt;div th:replace=\"~{dashboard::#sidebar}\"&gt;&lt;/div&gt;3.默认效果insert的动能片段在div标签中如果使用th:insert等属性进行引入，可以不用写~{}:行内写法可以加上：[[~{}]],[(~{})] 三种引入功能片段的th属性： 1.th:insert：将公共片段整个插入到整个声明引入的元素中 2.replace：将声明引入的元素替换成公共片段 3.include：被引入的片段的内容包含进这个标签中 12345678910111213141516171819202122232425&lt;footer th:fragment=\"copy\"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!--引入方式--&gt;&lt;body&gt; &lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;!--效果--&gt;&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 再引入片段的时候传入参数： 在抽取的部分进行定义判断 th:class=”${activeUri == ‘emps’?’nav-link active’:’nav-link’}” 1234567891011&lt;a class=\"nav-link active\" href=\"#\" th:class=\"${activeUri == 'emps'?'nav-link active':'nav-link'}\" th:href=\"@{/emps}\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-users\"&gt; &lt;path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"&gt;&lt;/path&gt; &lt;circle cx=\"9\" cy=\"7\" r=\"4\"&gt;&lt;/circle&gt; &lt;path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"&gt;&lt;/path&gt; &lt;path d=\"M16 3.13a4 4 0 0 1 0 7.75\"&gt;&lt;/path&gt; &lt;/svg&gt; 员工管理&lt;/a&gt; 在引入的地方进行变量赋值 1&lt;div th:replace=\"~{commons/bar::#sidebar(activeUri='emps')}\"&gt;&lt;/div&gt; 2.添加页面123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; 员工添加提交的数据格式不对：生日—日期 2017-12-12；2017/12/12；2017.12.12 日期的格式化：SpringMVC将页面提交的值需要转换为指定的类型 默认日期是按照斜线/方式；在配置文件中自定义时间格式: 12#自定义时间格式spring.mvc.date-format=yyyy-MM-dd 3.更新与修改的页面复用，以及如何提交PUT请求请求除get，post请求之外的请求，使用一个隐藏域，name=”_method”.value=”put” 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--需要区分是员工修改还是员工添加--&gt;&lt;!--1.springmvc中配置HiddenHttpMethodFilter2.页面创建一个post变单3.创建一个input项，name必须是_method--&gt;&lt;form th:action=\"@{/emp}\" th:method=\"post\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_mathod\" value=\"put\" th:if=\"${emp!=null}\" &gt; &lt;input type=\"hidden\" name=\"id\" th:value=\"${emp!= null}?${emp.id}\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${emp.lastName}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"${emp!=null}?${emp.email}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${emp!=null}?${emp.gender == 1}\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${emp!=null}?${emp.gender == 0} \"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\" name=\"department.id\" &gt; &lt;!--提交的是部门id--&gt; &lt;option th:each=\"dept:${depts}\" th:text=\"${dept.departmentName}\" th:value=\"${dept.id}\" th:selected=\"${emp!=null}?${emp.department.id} == ${dept.id}\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"birth\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"${emp!=null}?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt;","link":"/2020/02/29/SSM/springboot/3.%E8%A7%86%E5%9B%BE%E5%B1%82%E5%BC%80%E5%8F%91/"},{"title":"十七、Sentinel注解支持","text":"Sentinel注解支持 官方文档：https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81 这一节，我们首先做一个小的案例，然后把官方文档中的介绍过一遍，再把文档所述的特性在代码中找到。 案例依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 属性文件12345678910spring: cloud: sentinel: transport: dashboard: 127.0.0.1:8080 port: 8719 application: name: sentinel-annotaionserver: port: 9999 说明： spring.application.name 定义应用名,如图所示的名称 server.port :应用端口 spring.cloud.sentinel.transport.dashboard :sentinel的IP:端口 spring.cloud.sentinel.transport.port :sentinel 与服务的通讯端口 切面如果使用的是Spring Boot/Cloud ，即没有导入前面的依赖，需要自己将切面纳入到Spring容器中去： 1234@Beanpublic SentinelResourceAspect sentinelResourceAspect() { return new SentinelResourceAspect();} 由于我们导入了springcloud的依赖，所以会自动配置好这个切面,源码如下： EchoService1234public interface EchoService { String echoMessage(String message); String hello();} EchoServiceImpl1234567891011121314151617181920@Servicepublic class EchoServiceImpl implements EchoService { @Override @SentinelResource(value = \"echo.message\",blockHandler = \"handleException\", blockHandlerClass = ExceptionUtil.class) public String echoMessage(String message) { return \"echo message:\"+message; } @Override @SentinelResource(value = \"hello\",blockHandler = \"handleHello\") public String hello() { return \"echo hello\"; } public String handleHello(BlockException ex){ return \"handle hello ; exception:\"+ex; }} ExceptionUtil12345public class ExceptionUtil { public static String handleException(String message, BlockException ex){ return \"exception handle \"+message + \" exception:\"+ex; }} EchoController12345678910111213141516@RestControllerpublic class EchoController { @Autowired private EchoService echoService; @GetMapping(\"/echo/message/{message}\") public String echoMessage(@PathVariable String message){ return echoService.echoMessage(message); } @GetMapping(\"/hello\") public String hello(){ return echoService.hello(); }} 页面控制流控流控限制如下，简单使用基于QPS的流控规则（规则后续会详细说到），阈值为2，流控效果选的是快速失败。 通过测试，当我们在页面快速刷新（达到一秒访问3次或3次以上）可以看到下面的效果。 @SentinelResource 注解@sentinelResource 注解用于定义资源，并提供可选的异常处理和fallback配置项，@sentinelResource 注解包含以下属性： 注解源码12345678910111213141516171819202122232425262728@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface SentinelResource { //资源名 String value() default \"\"; //entry 类型 EntryType entryType() default EntryType.OUT; //指定异常处理函数名 String blockHandler() default \"\"; //如果异常处理函数不与目标方法在同一个类，则需要指定类，并且异常处理函数需要声明为static Class&lt;?&gt;[] blockHandlerClass() default {}; //fallback函数名，默认为空 String fallback() default \"\"; //指定默认fallback函数 String defaultFallback() default \"\"; //同样，fallback函数需要和目标方法在同一个类，如果不再，则需要指定，并且对应的函数需要声明为static Class&lt;?&gt;[] fallbackClass() default {}; // Class&lt;? extends Throwable&gt;[] exceptionsToTrace() default {Throwable.class}; //指定排除的异常类型，不进入异常统计，也不会进入fallback函数处理，而是原样抛出。 Class&lt;? extends Throwable&gt;[] exceptionsToIgnore() default {};} 文档原文@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性： value：资源名称，必需项（不能为空） entryType：entry 类型，可选项（默认为 EntryType.OUT） blockHandler / blockHandlerClass: blockHandler对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 fallback：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：返回值类型必须与原函数返回值类型一致；方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：返回值类型必须与原函数返回值类型一致；方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。 注：1.6.0 之前的版本 fallback 函数只针对降级异常（DegradeException）进行处理，不能针对业务异常进行处理。 特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。若未配置 blockHandler、fallback 和 defaultFallback，则被限流降级时会将 BlockException 直接抛出 @SentinelResource逻辑分析源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344@Around(\"sentinelResourceAnnotationPointcut()\")public Object invokeResourceWithSentinel(ProceedingJoinPoint pjp) throws Throwable { //标有注解(@SentinelResource)的目标原始方法 Method originMethod = resolveMethod(pjp); //获取注解对象(@SentinelResource) SentinelResource annotation = originMethod.getAnnotation(SentinelResource.class); if (annotation == null) { throw new IllegalStateException(\"Wrong state for SentinelResource annotation\"); } //资源名称 String resourceName = getResourceName(annotation.value(), originMethod); EntryType entryType = annotation.entryType(); Entry entry = null; try { //sentinel 逻辑代码 entry = SphU.entry(resourceName, entryType, 1, pjp.getArgs()); //执行目标方法 Object result = pjp.proceed(); return result; } catch (BlockException ex) { // 处理BlockException return handleBlockException(pjp, annotation, ex); } catch (Throwable ex) { // 处理非BlockException // 获取忽略处理的异常 Class&lt;? extends Throwable&gt;[] exceptionsToIgnore = annotation.exceptionsToIgnore(); //判断当前异常是否在 忽略异常列表中，如果存在，则直接抛出 if (exceptionsToIgnore.length &gt; 0 &amp;&amp; exceptionBelongsTo(ex, exceptionsToIgnore)) { throw ex; } //如果当前异常在exceptionsToTrace属性中定义了，就进行处理 if (exceptionBelongsTo(ex, annotation.exceptionsToTrace())) { traceException(ex); return handleFallback(pjp, annotation, ex); } //前面的条件都不符合，则直接抛出异常 throw ex; } finally { if (entry != null) { entry.exit(1, pjp.getArgs()); } }} 我们主要看 catch 中的handleBlockException() 方法。 第一步：执行 blockHandler所配置的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118protected Object handleBlockException(ProceedingJoinPoint pjp, SentinelResource annotation, BlockException ex) throws Throwable { //第一步：处理blockHandler方法。 // 如果配置了blockHandler 处理函数，则进行执行处理，获取blockHandler处理方法 Method blockHandlerMethod = extractBlockHandlerMethod(pjp, annotation.blockHandler(), annotation.blockHandlerClass()); //存在blockHandlerMethod的方法 if (blockHandlerMethod != null) { //获取目标方法的参数 Object[] originArgs = pjp.getArgs(); // 构建参数 Object[] args = Arrays.copyOf(originArgs, originArgs.length + 1); args[args.length - 1] = ex; try { //静态方法 if (isStatic(blockHandlerMethod)) { //反射调用方法，静态方法不需要传入obj return blockHandlerMethod.invoke(null, args); } //非静态方法。 return blockHandlerMethod.invoke(pjp.getTarget(), args); } catch (InvocationTargetException e) { // throw the actual exception throw e.getTargetException(); } } //如果没有配置blockHandler 异常处理函数。则执行fallback //第二步执行fallback 处理函数 return handleFallback(pjp, annotation, ex);}//========================进入extractBlockHandlerMethod方法======================== /** * name:异常处理函数名，locationClass：异常处理函数所在类，如果没有配置，则说明不是静态方法 */ //注意：这里可以看到，如果使用blockHandler函数，则先处理普通的，其次在去处理静态的。 private Method extractBlockHandlerMethod(ProceedingJoinPoint pjp, String name, Class&lt;?&gt;[] locationClass) { if (StringUtil.isBlank(name)) { return null; } // locationClass 如果配置了类，说明异常处理方法是静态方法。 boolean mustStatic = locationClass != null &amp;&amp; locationClass.length &gt;= 1; Class&lt;?&gt; clazz; //是不是配置了方法所在的类 if (mustStatic) { //如果传入了blockHandlerClass，则取第一个class clazz = locationClass[0]; } else { // 如果为空，就取当前类 clazz = pjp.getTarget().getClass(); } //从缓存中取MethodWrapper MethodWrapper m = ResourceMetadataRegistry.lookupBlockHandler(clazz, name); //缓存中没有 if (m == null) { // name是异常处理方法的名称，clazz是方法所在的类，mustStatic 是 是否为静态方法 // 获取 异常处理方法在当前类(及所有父类)的异常处理方法 Method method = resolveBlockHandlerInternal(pjp, name, clazz, mustStatic); //缓存当前方法的MethodWrapper实例 ResourceMetadataRegistry.updateBlockHandlerFor(clazz, name, method); return method; } if (!m.isPresent()) { return null; } //从缓存中取 return m.getMethod();} //===============进入resolveBlockHandlerInternal()方法================================//name: 异常处理方法；class：异常处理方法所在的类，mustStatic是否为静态方法//注意：通过这个方法可以看到：blockHandler异常处理函数的参数列表是在原方法的基础上，在末尾添加一个// BlockException类型的形参private Method resolveBlockHandlerInternal(ProceedingJoinPoint pjp, /*@NonNull*/ String name, Class&lt;?&gt; clazz,boolean mustStatic) { //获取目标方法的Method对象 Method originMethod = resolveMethod(pjp); //获取方法参数数组 Class&lt;?&gt;[] originList = originMethod.getParameterTypes(); //获取异常处理方法的参数列表 Class&lt;?&gt;[] parameterTypes = Arrays.copyOf(originList, originList.length + 1); //添加了一个新的参数，所以，我们定义降级的方法时，在末尾需要添加一个BlockException。 parameterTypes[parameterTypes.length - 1] = BlockException.class; //查找处理异常方法的Method对象（handleException） return findMethod(mustStatic, clazz, name, originMethod.getReturnType(), parameterTypes);}//=================进入findMethod()方法==========================//注意：这里可以发现，如果使用的是非静态的方法的处理方式，如果本类没有对应的异常处理函数，会递归追溯到父类，// 父类的父类....../*递归查询方法对象*/private Method findMethod(boolean mustStatic, Class&lt;?&gt; clazz, String name, Class&lt;?&gt; returnType, Class&lt;?&gt;... parameterTypes) { //获取当前类对象的所有方法对象 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { if (name.equals(method.getName()) &amp;&amp; checkStatic(mustStatic, method) &amp;&amp; returnType.isAssignableFrom(method.getReturnType()) &amp;&amp; Arrays.equals(parameterTypes, method.getParameterTypes())) { RecordLog.info(\"Resolved method [{0}] in class [{1}]\", name, clazz.getCanonicalName()); return method; } } // 本类没有，则向它的父类查找 Class&lt;?&gt; superClass = clazz.getSuperclass(); if (superClass != null &amp;&amp; !Object.class.equals(superClass)) { return findMethod(mustStatic, superClass, name, returnType, parameterTypes); } else { String methodType = mustStatic ? \" static\" : \"\"; RecordLog.warn(\"Cannot find{0} method [{1}] in class [{2}] with parameters {3}\", methodType, name, clazz.getCanonicalName(), Arrays.toString(parameterTypes)); return null; }} 第二步：执行fallback所配置的方法，进入handleFallback()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected Object handleFallback(ProceedingJoinPoint pjp, SentinelResource annotation, Throwable ex) throws Throwable { return handleFallback(pjp, annotation.fallback(), annotation.defaultFallback(), annotation.fallbackClass(), ex);}protected Object handleFallback(ProceedingJoinPoint pjp, String fallback, String defaultFallback, Class&lt;?&gt;[] fallbackClass, Throwable ex) throws Throwable { //目标方法的参数数组 Object[] originArgs = pjp.getArgs(); // 如果配置了fallback处理函数，则执行 Method fallbackMethod = extractFallbackMethod(pjp, fallback, fallbackClass); if (fallbackMethod != null) { // 构造参数列表 int paramCount = fallbackMethod.getParameterTypes().length; Object[] args; if (paramCount == originArgs.length) { args = originArgs; } else { args = Arrays.copyOf(originArgs, originArgs.length + 1); args[args.length - 1] = ex; } try { if (isStatic(fallbackMethod)) { //静态方法调用 return fallbackMethod.invoke(null, args); } //普通方法调用 return fallbackMethod.invoke(pjp.getTarget(), args); } catch (InvocationTargetException e) { // throw the actual exception throw e.getTargetException(); } } // If fallback is absent, we'll try the defaultFallback if provided. // 如果fallback 方法没有，则执行默认的fallback方法 //第三步处理默认的fallback配置的函数 return handleDefaultFallback(pjp, defaultFallback, fallbackClass, ex);}//==================进入extractFallbackMethod()方法==================private Method extractFallbackMethod(ProceedingJoinPoint pjp, String fallbackName, Class&lt;?&gt;[] locationClass) { if (StringUtil.isBlank(fallbackName)) { return null; } //判断配置为静态方法 boolean mustStatic = locationClass != null &amp;&amp; locationClass.length &gt;= 1; //同样，如果是配置为静态的，直接取，如果不是，则使用目标方法所在类 Class&lt;?&gt; clazz = mustStatic ? locationClass[0] : pjp.getTarget().getClass(); //从缓存中取 MethodWrapper m = ResourceMetadataRegistry.lookupFallback(clazz, fallbackName); if (m == null) { // 获取fallback方法的Method对象 Method method = resolveFallbackInternal(pjp, fallbackName, clazz, mustStatic); // 加入到缓存中 ResourceMetadataRegistry.updateFallbackFor(clazz, fallbackName, method); return method; } if (!m.isPresent()) { return null; } return m.getMethod();}//===========进入resolveFallbackInternal()方法中=================private Method resolveFallbackInternal(ProceedingJoinPoint pjp, /*@NonNull*/ String name, Class&lt;?&gt; clazz,boolean mustStatic) { //获取原方法（目标增强方法） Method originMethod = resolveMethod(pjp); // Fallback function allows two kinds of parameter list. // Fallback函数是支持两种类型的参数列表的，这里不像BlockHandler函数 // 第一种：与原参数列表一直；第二种：在原参数列表的最后添加一个Throwable类型 Class&lt;?&gt;[] defaultParamTypes = originMethod.getParameterTypes(); Class&lt;?&gt;[] paramTypesWithException = Arrays.copyOf(defaultParamTypes, defaultParamTypes.length + 1); paramTypesWithException[paramTypesWithException.length - 1] = Throwable.class; // We first find the fallback matching the signature of origin method. // 先查找第一个参数列表的方法 Method method = findMethod(mustStatic, clazz, name, originMethod.getReturnType(), defaultParamTypes); // If fallback matching the origin method is absent, we then try to find the other one. if (method == null) { // 如果第一种没有找到，则查询第二个加了异常类型的方法列表的方法 method = findMethod(mustStatic, clazz, name, originMethod.getReturnType(), paramTypesWithException); } return method;} 第三步：执行defaultFallback属性配置的函数,进入handleDefaultFallback()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465protected Object handleDefaultFallback(ProceedingJoinPoint pjp, String defaultFallback, Class&lt;?&gt;[] fallbackClass, Throwable ex) throws Throwable { // 如果配置了默认的fallback方法，如果配置了的话 Method fallbackMethod = extractDefaultFallbackMethod(pjp, defaultFallback, fallbackClass); if (fallbackMethod != null) { // 构造参数 Object[] args = fallbackMethod.getParameterTypes().length == 0 ? new Object[0] : new Object[] {ex}; try { if (isStatic(fallbackMethod)) { //静态方法调用 return fallbackMethod.invoke(null, args); } //普通方法调用 return fallbackMethod.invoke(pjp.getTarget(), args); } catch (InvocationTargetException e) { // 抛出实际异常 throw e.getTargetException(); } } // 如果没有配置任何的fallback函数（fallback函数和默认的fallback函数，则直接抛出异常 BlockException） throw ex;}//====================进入extractDefaultFallbackMethod()方法====================private Method extractDefaultFallbackMethod(ProceedingJoinPoint pjp, String defaultFallback, Class&lt;?&gt;[] locationClass) { if (StringUtil.isBlank(defaultFallback)) { return null; } //判断配置的是否是其他类的静态方法 boolean mustStatic = locationClass != null &amp;&amp; locationClass.length &gt;= 1; //获取方法所在的类名 Class&lt;?&gt; clazz = mustStatic ? locationClass[0] : pjp.getTarget().getClass(); //查询缓存 MethodWrapper m = ResourceMetadataRegistry.lookupDefaultFallback(clazz, defaultFallback); if (m == null) { Class&lt;?&gt; originReturnType = resolveMethod(pjp).getReturnType(); // Default fallback allows two kinds of parameter list. // 默认的fallback方法支持两种参数列表 // One is empty parameter list. // 第一种是空参数 Class&lt;?&gt;[] defaultParamTypes = new Class&lt;?&gt;[0]; // The other is a single parameter {@link Throwable} to get relevant exception info. // 第二种是只有一个Throwable类型的参数 Class&lt;?&gt;[] paramTypeWithException = new Class&lt;?&gt;[] {Throwable.class}; // We first find the default fallback with empty parameter list. // 先查找空参数 Method method = findMethod(mustStatic, clazz, defaultFallback, originReturnType, defaultParamTypes); // If default fallback with empty params is absent, we then try to find the other one. if (method == null) { // 再查询有参数的方法 method = findMethod(mustStatic, clazz, defaultFallback, originReturnType, paramTypeWithException); } // 缓存方法 ResourceMetadataRegistry.updateDefaultFallbackFor(clazz, defaultFallback, method); return method; } if (!m.isPresent()) { return null; } return m.getMethod();} 如果把上面的代码过一遍的话，前面文档中总结的要点基本都理解了。 执行方法顺序: blockHandler –&gt; fallback –&gt; defaultFallback 处理BlockException属性方法形参： blockHandler:在原方法的形参列表基础上，需要在最后添加一个BlockException 类型的参数。 123456//获取方法参数数组Class&lt;?&gt;[] originList = originMethod.getParameterTypes();//获取异常处理方法的参数列表Class&lt;?&gt;[] parameterTypes = Arrays.copyOf(originList, originList.length + 1);//添加了一个新的参数，所以，我们定义降级的方法时，在末尾需要添加一个BlockException。parameterTypes[parameterTypes.length - 1] = BlockException.class; fallback:有两种：1:方法参数列表与原方法参数列表一致，2：在原方法列表后添加一个Throwable 类型的参数 123456// Fallback函数是支持两种类型的参数列表的，这里不像BlockHandler函数// 第一种：与原参数列表一致；第二种：在原参数列表的最后添加一个Throwable类型Class&lt;?&gt;[] defaultParamTypes = originMethod.getParameterTypes();Class&lt;?&gt;[] paramTypesWithException = Arrays.copyOf(defaultParamTypes, defaultParamTypes.length + 1);paramTypesWithException[paramTypesWithException.length - 1] = Throwable.class; defaultFallback:有两种，1：方法参数列表为空，2：仅有一个Thowable的参数列表 12345678// Default fallback allows two kinds of parameter list.// 默认的fallback方法支持两种参数列表// One is empty parameter list.// 第一种是空参数Class&lt;?&gt;[] defaultParamTypes = new Class&lt;?&gt;[0];// The other is a single parameter {@link Throwable} to get relevant exception info.// 第二种是只有一个Throwable类型的参数Class&lt;?&gt;[] paramTypeWithException = new Class&lt;?&gt;[] {Throwable.class}; 处理非BlockException如果配置了在忽略异常列表中，则直接抛出原始异常，否则使用exceptionToTrace 配置进行处理，如果没有配置，则直接抛出原始异常。 1234567891011121314// 处理非BlockException// 获取忽略处理的异常Class&lt;? extends Throwable&gt;[] exceptionsToIgnore = annotation.exceptionsToIgnore();//判断当前异常是否在 忽略异常列表中，如果存在，则直接抛出if (exceptionsToIgnore.length &gt; 0 &amp;&amp; exceptionBelongsTo(ex, exceptionsToIgnore)) { throw ex;}//如果当前异常在exceptionsToTrace属性中定义了，就进行fallback和defaultFallback处理if (exceptionBelongsTo(ex, annotation.exceptionsToTrace())) { traceException(ex); return handleFallback(pjp, annotation, ex);}//前面的条件都不符合，则直接抛出异常throw ex; annotation.exceptionsToTrace() 默认是Throwable.class类型的,所以，理论上fallback是可以处理任何异常，排序在忽略异常列表中的异常。 这一节通过阅读源码的方式来学习sentinel的注解支持，后面我们看一下sentinel的几种控制规则。","link":"/2020/01/18/SSM/springcloudalibaba/14.sentinel%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%E8%AF%A6%E8%BF%B0/"},{"title":"二十四、GatewayFilter 工厂","text":"路由过滤器GatewayFilter允许修改进来的HTTP请求内容或者返回的HTTP响应内容。路由过滤器的作用域是一个具体的路由配置。 Spring Cloud Gateway提供了丰富的内建的GatewayFilter工厂，可以按需选用 。 图 from： https://blog.csdn.net/forezp/article/details/85057268 过滤器的声明周期： Gateway Filters 注意：接收端默认9999的服务中。 1. AddRequestHeaderAddRequestHeader GatewayFilter 工厂采用 name 和 value 参数。 12345678910spring: cloud: gateway: routes: - id: gateway-filter uri: http://localhost:9999 predicates: - Path=/addRequestHeader filters: - AddRequestHeader= X-Request-username,admin 9999端口接收端： 12345@GetMapping(value = \"/addRequestHeader\")public String addRequestHeader(@RequestHeader(\"X-Request-username\") String username){ System.out.println(\"X-Request-username:\"+username); return \"addRequestHeader SUCCESS\";} 说明：使用@RequestHeader注解读取HTTP Header中的数据。 当然，我们也可以使用路径变量的形式来动态传递参数。 12345678910spring: cloud: gateway: routes: - id: add_request_header_route uri: http://localhost:9999 predicates: - Path=/addRequestHeader/{username} filters: - AddRequestHeader= X-Request-username,u-{username} 接收端： 12345@GetMapping(value = \"/addRequestHeader/{str}\")public String addRequestHeader(@RequestHeader(\"X-Request-username\") String username){ System.out.println(\"X-Request-username:\"+username); return \"addRequestHeader SUCCESS\";} 2. AddRequestParameterAddRequestParameter GatewayFilter Factory同样是采用 name 和 value . 12345678910spring: cloud: gateway: routes: - id: add_request_parameter_route uri: http://localhost:9999 predicates: - Path=/addRequestParameter filters: - AddRequestParameter= name,zhangsan 接收端： 12345@GetMapping(value = \"/addRequestParameter\")public String addRequestParameter(@RequestParam(\"name\") String name){ System.out.println(\"name:\"+name); return \"addRequestParameter SUCCESS\";} 说明： 我们使用addRequestParamter filter来将参数信息添加到所有匹配请求的下游请求的请求参数中。同样也可以使用路径参数来动态传递,如下： 12345678910spring: cloud: gateway: routes: - id: add_request_parameter_route uri: http://localhost:9999 predicates: - Host= {str}.ouyanghao.com filters: - AddRequestParameter= name,{str} 这里记录一个异常信息： 12reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalArgumentException: Unable to find GatewayFilterFactory with name AddResponseHeader Caused by: java.lang.IllegalArgumentException: Unable to find GatewayFilterFactory with name AddResponseHeader 这个问题我之前以为是导包的问题，结果一顿操作之后，发现在配置过滤器的时候，不能中间加空格，即： 12345filters: - AddResponseHeader = name,lisi# 上面的写法是错误的，不能在等号之前加空格filters: - AddResponseHeader= name,lisi 3. AddResponseHeaderAddResponseHeader Filter Factory同样是采用两个参数 key (name)和 value 形式。 12345678910spring: cloud: gateway: routes: - id: add_response_header_route uri: http://localhost:9999 predicates: - Path=/addResponseHeader filters: - AddResponseHeader= name,lisi 说明： 这样会将name=list 头信息，添加到所有匹配请求的下游响应头中去。同样也可以使用路径参数来动态传递/user/{str}. 4. DedupeResponseHeaderDedupeResponseHeader Filter Factory 采用两个参数，一个是name,一个是策略，中间使用空格隔开，我们看一下源码上的注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*Use case: Both your legacy backend and your API gateway add CORS header values. So, your consumer ends up with Access-Control-Allow-Credentials: true, true Access-Control-Allow-Origin: https://musk.mars, https://musk.mars(The one from the gateway will be the first of the two.) To fix, add DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin用例：后端程序以及API网关都会往响应头中添加 CORS的头信息，所以，最终的消费者得到的就是具有重复值的，如上所述，所以此时我们需要将重复值去除。Configuration parameters:- name String representing response header names, space separated. Required.- strategy RETAIN_FIRST - Default. Retain the first value only. RETAIN_LAST - Retain the last value only. RETAIN_UNIQUE - Retain all unique values in the order of their first encounter.配置： 名字：响应头的名字，中间添加一个必须的空格。 策略：1.保留第一个，2.保留最后一个，3.保留所有唯一值，以它们第一次出现的顺序保留。Example 1 default-filters: - DedupeResponseHeader=Access-Control-Allow-CredentialsResponse header Access-Control-Allow-Credentials: true, falseModified response header Access-Control-Allow-Credentials: trueExample 2 default-filters: - DedupeResponseHeader=Access-Control-Allow-Credentials, RETAIN_LASTResponse header Access-Control-Allow-Credentials: true, falseModified response header Access-Control-Allow-Credentials: falseExample 3 default-filters: - DedupeResponseHeader=Access-Control-Allow-Credentials, RETAIN_UNIQUEResponse header Access-Control-Allow-Credentials: true, trueModified response header Access-Control-Allow-Credentials: true */public class DedupeResponseHeaderGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;DedupeResponseHeaderGatewayFilterFactory.Config&gt; {} 上面的注释已经解释了问题。 12345678910spring: cloud: gateway: routes: - id: dedupe_response_header_route uri: http://localhost:9999 predicates: - Path=/dedupeResponseHeader filters: - DedupeResponseHeader= Access-Control-Allow-Credentials Access-Control-Allow-Origin, RETAIN_FIRST 剔除重复的响应头信息。 5. HystrixHystrix 是 netflix下的熔断组件，由于已经停止维护，并且这里主要是使用SpringCloudAlibaba系列，使用的是Sentinel，所以这里不详述，就简单把官方示例放在这，后面用来再回来看。 Hystrix是Netflix的一个库，用于实现断路器模式。Hystrix GatewayFilter允许您将断路器引入网关路由，保护您的服务免受级联故障的影响，并允许您在下游故障的情况下提供后备响应。 12345678spring: cloud: gateway: routes: - id: hystrix_route uri: https://example.org filters: - Hystrix=myCommandName 6. FallbackHeaders 该FallbackHeaders工厂可以让你在转发到请求的头部添加Hystrix执行异常的详细信息fallbackUri在以下情况下在外部应用程序，如： 123456789101112131415161718192021spring: cloud: gateway: routes: - id: ingredients uri: lb://ingredients predicates: - Path=//ingredients/** filters: - name: Hystrix args: name: fetchIngredients fallbackUri: forward:/fallback - id: ingredients-fallback uri: http://localhost:9994 predicates: - Path=/fallback filters: - name: FallbackHeaders args: executionExceptionTypeHeaderName: Test-Header 7. MapRequestHeaderMapRequestHeader GatewayFilter 工厂采用两个参数：fromHeader 和 toHeader. 12345678910spring: cloud: gateway: routes: - id: map_request_header_route uri: http://localhost:9999 predicates: - Path=/mapRequestHeader filters: - MapRequestHeader= password, X-Request-username 说明： fromHeader 和 toHeader 在上例中分别为 password 和 X-Request-username . 接收端： 1234567@GetMapping(value = \"/mapRequestHeader\")public String mapRequestHeader( @RequestHeader(value = \"password\", required = false) String password, @RequestHeader(value = \"X-Request-username\", required = false) String username){ System.out.println(\"username:\"+username + \" | password:\"+password); return \"mapRequestHeader Success\";} 我们下面来测试一下： 后台结果如下： 1username:admin,123456 | password:123456 可以看出，password 将值注入到了 X-Request-username . 即将请求的头信息添加到后续的下游请求中。 8. PrefixPathPrefixPath GatewayFilter工厂采用单个prefix参数。 12345678910spring: cloud: gateway: routes: - id: prefix_path_route uri: http://localhost:9999 Predicates: Method= GET filters: - PrefixPath=/user 我们通过下面的命令可以将请求转发到 http://localhost:9999/user/name 1curl localhost:8080/name 接收端： 1234@GetMapping(value = \"/user/name\")public String useName(){ return \"prefixPath success\";} 9. PreserveHostHeader我们从字面意思可以知道:保护Host Header，其实就是保护请求头中的Host字段。PreserveHostHeader 不需要参数。此过滤器将检查该请求属性，以确定是否应发送原始主机头，而不是由HTTP客户端确定的主机头。 如下： 12345678910spring: cloud: gateway: routes: - id: prefix_path_route uri: http://localhost:9999 Predicates: Method= GET filters: - PreserveHostHeader 接收端： 123456@GetMapping(value = \"/preserveHostHeader\")public String preserveHostHeader(@RequestHeader(value = \"Host\", required = false) String host){ System.out.println(\"host:\"+host); return \"preserveHostHeader success\";} 在浏览器地址栏输入：http://localhost:8080/preserveHostHeader,接收端显示结果： 12host:localhost:8080,localhost:8080//会把Host存到请求头中 10. RequestRateLimiterRequestRateLimiter:请求速率限制器。RequestRateLimiter GatewayFilter 工厂是一个RateLimiter 的实现类，用它去决定当前请求是否允许继续执行。如果不允许继续执行，默认会返回一个 HTTP 429 - Too Many Requests （太多连接状态）。 这个filter采用 一个可选的keyResolver 参数 和 指定的速率限制器参数。 keyResolver 是一个实现了KeyResolver接口的实现类的bean。在配置中，使用SpEL按名称引用bean. #{@myKeyResolver} 是SpEL表达式，它引用名称为myKeyResolver的bean。 KeyResolver.java 源码： 123public interface KeyResolver { Mono&lt;String&gt; resolve(ServerWebExchange exchange);} KeyResolver接口允许一个可拔插策略去驱动如何限制请求。 有一个默认实现： 123456789public class PrincipalNameKeyResolver implements KeyResolver { public static final String BEAN_NAME = \"principalNameKeyResolver\"; @Override public Mono&lt;String&gt; resolve(ServerWebExchange exchange) { return exchange.getPrincipal().map(Principal::getName) .switchIfEmpty(Mono.empty()); }} 从上面的代码可以看出：默认的keyResolver 的实现是从 ServerWebExchange 取得Principal 并且回调Principal.getName() 方法。 默认情况下，如果 KeyResolver 没有找到一个key，那么请求将会被拒绝。当然，可以通过 spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key (true or false) 以及 spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code 属性来设置。 10.1 Redis RateLimiterredis 实现基于Stripe所做的工作。需要导入相关依赖,注意版本要求，参考spring官网。 https://spring.io/projects/spring-cloud 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--监控依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置类： 123456789101112131415161718192021222324@Configurationpublic class GatewayConfiguration { //根据请求路径限流 getPath @Bean public KeyResolver keyResolver(){ return new KeyResolver() { @Override public Mono&lt;String&gt; resolve(ServerWebExchange exchange) { return Mono.just(exchange.getRequest().getPath().toString()); } }; } // 基于请求参数的限流 @Bean public KeyResolver userKeyResolver(){ return exchange -&gt; Mono.just( exchange.getRequest().getQueryParams().getFirst(\"userId\") ); } } 上面的例子是获取到官网的，就是在请求中获取一个叫user的请求参数，用于统计。 SpringCloud Gateway的限流方式是基于令牌桶算法的，使用Redis来存储Key。 配置信息： 123456789101112131415161718spring: cloud: gateway: routes: - id: request_hrate_limiter uri: http://localhost:9999 Predicates: Method= GET filters: # 使用限流过滤器 - name: RequestRateLimiter args: key-resolver: \"#{@userKeyResolver}\" redis-rate-limiter.replenishRate: 2 redis-rate-limiter.burstCapacity: 2 redis: host: 127.0.0.1 port: 6379 说明： redis-rate-limiter.replenishRate : 向令牌桶中填充的速率(一秒放多少个令牌) redis-rate-limiter.burstCapacity : 允许用户在一秒内执行的最大请求数。将此值设置为0，将阻止所有请求。（令牌桶的容量） 为实现一个稳定的速率，通常将上述两个属性设置成相同的值，将burstCapacity 设置大于 replenishRate 可以允许临时暴发。在这种情况下，需要在突发之间允许速率限制器一段时间(根据replenishRate )，因为连续两次突发可能导致请求被丢弃(HTTP 429 - Too Many Requests) 上面的userKeyResolver 是一个简单的获取用户请求参数（注意：不建议用在生产） 速率限制器也可以定义为实现了 RateLimiter 接口的bean。在配置中，使用SpEL按名称引用bean。#{@myRateLimiter} 是SpEL表达式，它引用名称为myRateLimiter的bean。 1234567891011spring: cloud: gateway: routes: - id: requestratelimiter_route uri: https://example.org filters: - name: RequestRateLimiter args: rate-limiter: \"#{@myRateLimiter}\" key-resolver: \"#{@userKeyResolver}\" 11. RedirectToRedirectTo:重定向到。RedirectTo GatewayFilter工厂采用两个参数：status 和 url。这个状态码需要是一个300系列的重定向的HTTP状态码。例如：301. url应该是一个有效的地址，将设置为头部的Location的值。 application.yaml 12345678910spring: cloud: gateway: routes: - id: request_hrate_limiter uri: http://localhost:9999 Predicates: Method= GET filters: - RedirectTo= 302, http://www.163.com 上面配置，当我们访问http://localhost:8080/redirectTo 路径时，并不会映射到http://localhost:9999/redirectTo.而是被转发到了http://www.163.com. 12. RemoveHopByHopHeadersFIlterRemoveHopByHopHeadersFilter GatewayFilter工厂从转发的请求中删除header，被删除的header列表来自IETF。 默认删除的header是： Connection Keep-Alive Proxy-Authenticate Proxy-Authorization TE Trailer Transfer-Encoding Upgrade 如果希望去修改它，可以通过设置spring.cloud.gateway.filter.remove-non-proxy-headers.headers属性来移除header列表。 13. RemoveRequestHeaderRemoveRequestHeader GatewayFilter 工厂采用一个参数：name. 请求头中的指定名字的值将被移除。 application.yaml 12345678910spring: cloud: gateway: routes: - id: remove_request_header uri: http://localhost:9999 Predicates: Method= GET filters: - RemoveRequestHeader=username 接收端： 123456@GetMapping(value = \"/removeRequestHeader\")public String removeRequestHeader( @RequestHeader(value = \"username\", required = false) String username){ System.out.println(\"username:\"+username); return \"removeRequestHeader success\";} 测试： 请求是携带了username 参数，下面是接收端打印的结果： 1username:null 14. RemoveResponseHeader见名知意，在返回客户端之前，删除指定响应头的数据。RemoveResponseHeader GatewayFilter 工厂采用一个参数：name . 12345678910spring: cloud: gateway: routes: - id: remove_response_header uri: http://localhost:9999 Predicates: Method= GET filters: - RemoveResponseHeader=Content-Type 上面的配置可以从响应头中删除 Content-Type 头信息，然后将其返回到客户端。 要删除任何类型的敏感信息，你可以需要配置这个filter在你需要的任何路由上，当然，我们可以在配置文件中配置spring.cloud.gateway.default-filters, 那么可以引用在所有的路由上。 15. RemoveRequestParameterRemoveRequestParameter GatewayFilter 工厂采用一个参数：name . 指定请求参数将会被删除。 这个是新版本2.2.0.RC1中新加的. 12345678910spring: cloud: gateway: routes: - id: remove_response_parameter uri: http://localhost:9999 Predicates: Method= GET filters: - RemoveRequestParameter=username 以上代码可以从请求参数中删除指定参数，在进行路由。 16. RewritePathRewritePath Gateway采用路径 正常表达式和替换参数。使用正则表达式可以灵活地重写请求路径。 application.yaml 12345678910spring: cloud: gateway: routes: - id: remove_response_parameter uri: http://localhost:9999 Predicates: Method= GET filters: - RewritePath=/user/(?&lt;str&gt;.*), /$\\{str} 根据上面的配置，使用路径http://localhost:8080/user/rewritePath 会被映射到 http://localhost:9999/rewritePath. 注意: 由于YAML规范，$\\替换为$ 17. RewriteLocationResponseHeaderRewriteLocationResponseHeader GatewayFilter 工厂 用来重写 响应头的Location 的值，以摆脱后端特定的详细信息。这需要 stripVersionMode , locationHeaderName , hostValue 和 protocolsRegex 参数。 12345678spring: cloud: gateway: routes: - id: rewritelocationresponseheader_route uri: http://example.org filters: - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, , 示例：对于请求api.example.com/some/object/name. Location 响应头的值object-service.prod.example.net/v2/some/object/id 将会被重写为api.example.com/some/object/id。 解释：由于hostValue 和 protocolsRegex 参数都没有提供，所以使用原请求的host，并且stripVersionMode 选择的是AS_IN_REQUEST , 所以在原请求路径不包含版本时，将版本剥离删除。 步骤： api.example.com/some/object/name api.example.com/v2/some/object/id api.example.com/some/object/id 参数stripVersionMode 具有以下可选值：NEVER_STRIP , AS_IN_REQUEST (默认) , ALWAYS_STRIP. NEVER_STRIP 即使原始请求路径不包含任何版本，也不会剥离版本。 AS_IN_REQUEST 仅当原始请求不包含版本时，版本才会被剥离。 ALWAYS_STRIP 即使原始请求路径包含版本，也会删除版本。 参数 hostValue (如果提供) 将用于替换 host:port 响应 Location 头的一部分。如果未提供，Host 则将作为请求头的值使用。 参数 protocolsRegex 必须是有效的正则表达式字符串，协议名称将与该regex 匹配。如果不匹配，过滤器将不执行任何操作。默认值为 http|https|ftp|ftps. 18. RewriteResponseHeaderRewriteResponseHeader GatewayFilter 工厂采用三个参数，分别为：name, regexp 和 replacement . 它使用Java正则表达式以灵活的方式来重写响应头的值。 12345678spring: cloud: gateway: routes: - id: rewriteresponseheader_route uri: https://example.org filters: - RewriteResponseHeader=X-Response-Foo, , password=[^&amp;]+, password=*** 对于响应头值 /42?user=ford&amp;password=omg!what&amp;flag=true , 在下游请求执行之后将被设置为 /42?user=ford&amp;password=***&amp;flag=true ，在YAML文件中，需要使用$\\ 来表示$. 19. SaveSessionSaveSession GatewayFilter 工厂在向下游转发调用之前会强制执行 WebSession::save 操作。 这在将Spring Session之类的东西与惰性数据存储一起使用时特别有用，并且需要确保在进行转发呼叫之前已保存会话状态。 application.yaml 12345678910spring: cloud: gateway: routes: - id: save_session uri: https://example.org predicates: - Path=/foo/** filters: - SaveSession 如果您将Spring Security与Spring Session 集成在一起，并且想要确保安全性详细信息已转发到远程进程，那么这一点至关重要。 20. SecureHeadersSecureHeaders GatewayFilter 工厂添加了许多头到响应中。 文档： https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.0.RC1/reference/html/#secureheaders-gatewayfilter-factory 下面内容摘抄自官网 添加了以下标头（以及默认值）： X-Xss-Protection:1; mode=block Strict-Transport-Security:max-age=631138519 X-Frame-Options:DENY X-Content-Type-Options:nosniff Referrer-Policy:no-referrer Content-Security-Policy:default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline' X-Download-Options:noopen X-Permitted-Cross-Domain-Policies:none 要更改默认值，请在spring.cloud.gateway.filter.secure-headers名称空间中设置适当的属性： 要更改的属性： xss-protection-header strict-transport-security frame-options content-type-options referrer-policy content-security-policy download-options permitted-cross-domain-policies 要禁用默认值，请将该属性设置为spring.cloud.gateway.filter.secure-headers.disable逗号分隔的值。 例： 1spring.cloud.gateway.filter.secure-headers.disable=frame-options,download-options 21. SetPathSetPath GatewayFilter 采用路径template 参数。通过允许路径的模板片段，提供了一种操作请求路径的简单方法。这使用了Spring Framework 中的uri模板。允许多个匹配片段。 application.yaml 12345678910spring: cloud: gateway: routes: - id: remove_response_parameter uri: http://localhost:9999 Predicates: - Path= /set/{subUrl} filters: - SetPath= /{subUrl} 对于请求路径 /set/path ，路径会被设置为/path 然后在转发到下游请求。 22. SetRequestHeaderSetRequestHeader GatewayFilter 工厂采用 name 和 value 参数。 application.yaml 12345678910spring: cloud: gateway: routes: - id: set_request_header uri: http://localhost:9999 Predicates: - Method=GET filters: - SetRequestHeader= username,admin 以上设置，可以将请求头中的username 的原来值修改为admin. 接收端： 123456@GetMapping(value = \"/setRequestHeader\")public String setRequestHeader( @RequestHeader(value = \"username\", required = false) String username){ System.out.println(\"username:\"+username); return \"setRequestHeader success\";} postman测试： 测试结果： 1username:admin 上述测试可以看出，SetRequestHeader 和前面的AddRequestHeader 不同，这个是将原来的值替换为配置的值。 23. SetResponseHeaderSetResponseHeader GatewayFilter 工厂采用两个参数：name 和 value . application.yaml 12345678910spring: cloud: gateway: routes: - id: set_request_header uri: http://localhost:9999 Predicates: - Method=GET filters: - SetResponseHeader= X-Response-username,admin 这个过滤器主要是将 响应头中的 X-Response-username 替换为 admin .同样也可以使用路径参数动态传递。 24. SetStatusSetStatus GatewayFilter工厂采用一个参数：status , 这个参数必须是一个有效的Spring HttpStatus . 它可以是整数值 404 或是枚举的字符串表示形式NOT_FOUND. application.yaml 12345678910111213141516spring: cloud: gateway: routes: - id: set_status1 uri: http://localhost:9999 Predicates: - Method=GET filters: - SetStatus= NOT_FOUND - id: set_status2 uri: http://localhost:9999 Predicates: - Method=GET filters: - SetStatus= 404 无论上述情况的哪一种，响应的HTTP状态都讲设置为404. SetStatus GatewayFilter可以被 配置为响应头中从代理请求返回原始HTTP状态码，如果使用以下属性配置header，则会将其添加到响应头中： 12345spring: cloud: gateway: set-status: original-status-header-name: original-http-status 25. StripPrefixStripPrefix GatewayFilter工厂采用一个参数：part , 这个参数在请求转发到下游之前去除路径的前 part 部分。 12345678910spring: cloud: gateway: routes: - id: strip_prefix uri: http://localhost:9999 Predicates: - Method=GET filters: - StripPrefix= 2 根据以上配置，可以将/user/name/stripPrefix 地址 切除前面两段，所以最后转发到下游的地址是/stripPrefix. 26. RetryRetry GatewayFilter 工厂重试机制，参考官网： https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.0.RC1/reference/html/#retry-gatewayfilter-factory 27. RequestSize当请求大小高于允许的限制大小时，RequestSize GatewayFilter工厂将会阻止转发到下游服务。过滤器将RequestSize 参数作为请求的允许大小限制（以字节为单位） application.yaml 123456789101112spring: cloud: gateway: routes: - id: request_size_route uri: http://localhost:8080/upload predicates: - Path=/upload filters: - name: RequestSize args: maxSize: 5000000 当请求由于大小而被拒绝时，RequestSize GatewayFilter 工厂将响应状态设置为 403 Payload Too Large 并带有head名为errorMessage 的数据。如下： 1errorMessage: Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0MB 如果未在路由定义中作为过滤器参数提供，则默认请求大小设置为5MB。 28. Modify Request Body这个过滤器用于在将请求转发到下游服务之前，将请求体进行修改。 注意：只能通过java来配置此过滤器。 123456789101112131415161718192021222324252627@Beanpublic RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(\"rewrite_request_obj\", r -&gt; r.host(\"*.rewriterequestobj.org\") .filters(f -&gt; f.prefixPath(\"/httpbin\") .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE, (exchange, s) -&gt; return Mono.just(new Hello(s.toUpperCase())))).uri(uri)) .build();}static class Hello { String message; public Hello() { } public Hello(String message) { this.message = message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; }} 29. Modify Response Body该过滤器在响应发送会客户端之前，对响应体进行修改。同样也只支持Java配置。 123456789@Beanpublic RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(\"rewrite_response_upper\", r -&gt; r.host(\"*.rewriteresponseupper.org\") .filters(f -&gt; f.prefixPath(\"/httpbin\") .modifyResponseBody(String.class, String.class, (exchange, s) -&gt; Mono.just(s.toUpperCase()))).uri(uri) .build();} 30. Default Filter如果想添加一个过滤器去应用在所有的路由上，可以使用 spring.cloud.gateway.default-filters 来配置，这个属性接收一个Filter列表。 application.yaml 123456spring: cloud: gateway: default-filters: - AddResponseHeader=X-Response-Default-Foo, Default-Bar - PrefixPath=/httpbin 总结：这一节主要介绍SpringCloud Gateway中的过滤器。官方文档如下： https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.0.RC1/reference/html/#gatewayfilter-factories","link":"/2020/01/18/SSM/springcloudalibaba/22.gateway%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"title":"2019，新冠肺炎","text":"​ 这个春节在我记忆里，是第一次没有走亲戚的。往年不管是在哪，年前都是期盼回家过年，而今年，回家前真的有一种避难的感觉。 ​ 在2019年12月20号之前，网上报道基本都是说，这个新冠肺炎是可防可控的，未发现人传人的迹象。我有一个同学出差到武汉，但是被派回了上海，所以对这事其实有一点关注了，但是因为说未发现人传人，心里又感觉不太要紧，就没有特别在意。直到12月20号，钟南山院士在采访中说道，新型冠状病毒会人传人，已经发现有人传人现象。并且戴口罩预防传染很重要。一时间，上海所有的实体店，口罩全部脱销，再到网上看，基本已经全部卖完了。 ​ 在这之前，上班地铁上，人们戴口罩大部分都是御寒，而从21号开始，大部分口罩都变成了医用外科或N95。当然，我也是其中一员。接着就是不断出现的手机新闻推送，头条和热搜，让我感觉到了这次肺炎的严重性。下午还差下班一个多小时，上面就派人来说：“没什么事就提前回家吧，下班高峰人多”。当然我们都知道什么原因。而回到公寓之后，通知说明天（22号）【公司23号放假】不用上班了。 ​ …回家… ​ 回家之后，公司就开始统计有没有与武汉回来的密切接触等情况。由于国家的种种措施以及江西省宣布启动一级卫生应急响应，接着就开始了不走亲戚，不串门的春节。也有网友戏称：宅，就是对国家最大的贡献。 ​ 今年的春节。铺天盖地的新闻报道，数据公布。2003年由于还小，对非典基本没什么印象。而今年，真的感受到了什么叫全国人民齐心协力。数据一天一报道，以至于每天醒来，第一件事就是看看最新的数据，确诊人数是不是没有增长了？死亡人数是不是没有增加了？治愈人数是不是大幅增加了？ ​ 封路，这可能是今年春节的热词。硬核村长，是不是觉得很可爱。警察砸麻将桌是不是很霸气。我这个生活在农村的小伙，都真正感受到了政府对这次疫情的重视。各种方式让百姓提高警惕。比如敲锣呐喊，摩托广播，宣传手册。 ​ 国家宣布假期延长至2020年2月2日。上海市政府宣布本市企业，除特殊企业外。复工时间不得早于2020年2月9日24时。 ​ 白岩松老师主持的《新闻1+1》变成了必追的节目。 ​ 记得：出门戴口罩，记得勤洗手，没事不出门，家里要通风。 ​ 武汉加油，中国加油。希望赶快结束这次疫情。 ​","link":"/2020/02/01/%E9%9A%8F%E7%AC%94/2020/01/2019/"},{"title":"三、Mybatis映射文件","text":"Mybatis映射文件 基本CRUD增加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;select id=\"saveRole\" resultType=\"role\"&gt; insert into tb_role ( &lt;trim suffixOverrides=\",\"&gt; &lt;if test=\"roleName!=null\"&gt; role_name, &lt;/if&gt; &lt;if test=\"description != null\"&gt; description, &lt;/if&gt; &lt;if test=\"status != null\"&gt; status, &lt;/if&gt; &lt;if test=\"createTime != null\"&gt; create_time, &lt;/if&gt; &lt;if test=\"createUser != null\"&gt; create_user, &lt;/if&gt; &lt;if test=\"modifyTime != null\"&gt; modify_time, &lt;/if&gt; &lt;if test=\"modifyUser != null\"&gt; modify_user &lt;/if&gt; &lt;/trim&gt; ) VALUES ( &lt;trim suffixOverrides=\",\"&gt; &lt;if test=\"roleName!=null\"&gt; #{roleName}, &lt;/if&gt; &lt;if test=\"description != null\"&gt; #{description}, &lt;/if&gt; &lt;if test=\"status != null\"&gt; #{status}, &lt;/if&gt; &lt;if test=\"createTime != null\"&gt; #{createTime}, &lt;/if&gt; &lt;if test=\"createUser != null\"&gt; #{createUser}, &lt;/if&gt; &lt;if test=\"modifyTime != null\"&gt; #{modifyTime}, &lt;/if&gt; &lt;if test=\"modifyUser != null\"&gt; #{modifyUser} &lt;/if&gt; &lt;/trim&gt; )&lt;/select&gt; 这个增加方法使用if 进行判断，所以只是将不为空的字段添加。 增加并返回ID123456789&lt;!--设置保存的时候需要返回插入时的id--&gt;&lt;insert id=\"saveUser\" useGeneratedKeys=\"true\" keyProperty=\"id\" parameterType=\"User\" &gt; insert into tb_user (user_id, username,password,email,phone,gender,birthday,create_time, create_user,modify_time,modify_user) values ( #{user.userId},#{user.username},#{user.password},#{user.email},#{user.phone},#{user.gender}, #{user.birthday},#{user.createTime},#{user.createUser},#{user.modifyTime},#{user.modifyUser})&lt;/insert&gt; 删除123&lt;delete id=\"deleteRoleById\"&gt; delete from tb_role where id = #{id}&lt;/delete&gt; 这是一个非常简单的删除语句，这里不赘述。 更新123456789101112131415161718192021222324252627&lt;update id=\"updateRole\"&gt; update tb_role &lt;set&gt; &lt;if test=\"roleName!=null\"&gt; role_name = #{roleName}, &lt;/if&gt; &lt;if test=\"description != null\"&gt; description = #{description}, &lt;/if&gt; &lt;if test=\"status != null\"&gt; status = #{status}, &lt;/if&gt; &lt;if test=\"createTime != null\"&gt; create_time = #{createTime}, &lt;/if&gt; &lt;if test=\"createUser != null\"&gt; create_user = #{createUser}, &lt;/if&gt; &lt;if test=\"modifyTime != null\"&gt; modify_time = #{modifyTime}, &lt;/if&gt; &lt;if test=\"modifyUser != null\"&gt; modify_user = #{modifyUser} &lt;/if&gt; &lt;/set&gt; where id = #{id}&lt;/update&gt; 提示：这里采用了选择性更新，即只有字段不为空的时候，才会进行更新操作。 查询123&lt;select id=\"selectRolesByStatus\" resultType=\"role\"&gt; select * from tb_role where status = #{status}&lt;/select&gt; 提示：这里仅仅介绍一下最简单的查询，后面重点介绍与查询相关的。 增删改查标签相关属性请参考： https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#insert_update_and_delete 增删改查标签属性Select 元素的属性 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。 fetchSize 这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。 Insert, Update, Delete 元素的属性 属性 描述 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：true（对于 insert、update 和 delete 语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 结果映射结果映射（resultMap） constructor - 用于在实例化类时，注入结果到构造方法中idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂类型的关联；许多结果将包装成这种类型嵌套结果映射 – 关联本身可以是一个 resultMap 元素，或者从别处引用一个 collection – 一个复杂类型的集合嵌套结果映射 – 集合本身可以是一个 resultMap 元素，或者从别处引用一个 discriminator – 使用结果值来决定使用哪个 resultMapcase – 基于某些值的结果映射嵌套结果映射 – case 本身可以是一个 resultMap 元素，因此可以具有相同的结构和元素，或者从别处引用一个 Id 和 Result 的属性 属性 描述 property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 支持的 JDBC 类型为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY 单表基本结果映射属性设值1234567891011121314&lt;resultMap id=\"base_map\" type=\"role\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/&gt; &lt;result column=\"description\" jdbcType=\"VARCHAR\" property=\"description\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllRoles\" resultMap=\"base_map\"&gt; select * from tb_role&lt;/select&gt; java实体： 123456789101112//空参数，全参数，get，set，toStringpublic class Role implements Serializable { private Integer id; private String roleName; private String description; private Integer status; private Date createTime; private String createUser; private Date modifyTime; private String modifyUser;} 提示：可以看出，这里我们不再直接使用了user作为返回类型(resultType),而是使用了结果映射(resultMap)来映射实体。以上方式使用的实体映射是使用的setter进行设置参数的。我们在setId方法上加一段输入语句之后，再次运行，结果如下： 1234public void setId(Integer id) { System.out.println(\"setId of role is running\"); this.id = id;} 那么我们如何使用构造函数来进行属性设置赋值呢？ 123456789101112&lt;resultMap id=\"base_map\" type=\"role\"&gt; &lt;constructor&gt; &lt;idArg column=\"id\" javaType=\"Integer\"/&gt; &lt;arg column=\"role_name\" javaType=\"String\"/&gt; &lt;arg column=\"description\" javaType=\"String\"/&gt; &lt;arg column=\"status\" javaType=\"Integer\"/&gt; &lt;arg column=\"create_time\" javaType=\"Date\"/&gt; &lt;arg column=\"create_user\" javaType=\"String\"/&gt; &lt;arg column=\"modify_time\" javaType=\"Date\" /&gt; &lt;arg column=\"modify_user\" javaType=\"String\" /&gt; &lt;/constructor&gt;&lt;/resultMap&gt; 构造方法设值1234567891011public Role(Integer id, String roleName, String description, Integer status, Date createTime, String createUser, Date modifyTime, String modifyUser) { System.out.println(\"all args' constructor of role is running \"); this.id = id; this.roleName = roleName; this.description = description; this.status = status; this.createTime = createTime; this.createUser = createUser; this.modifyTime = modifyTime; this.modifyUser = modifyUser;} 测试结果： 关联关系一对一​ 前面我们看到了单表操作，我们通过直接返回对象或是使用resultMap的方式来映射实体。这里我们看一下实体一对一的关系如何映射。 123456789101112131415一对一关系的映射：association标签的属性元素property CDATA 属性，必须column CDATA 数据库表的字段名javaType CDATA 属性的java类型jdbcType CDATA 数据库表的字段的类型select CDATA 嵌套查询时使用。resultMap CDATA 关联外部的手动映射关系时使用typeHandler CDATA 类型处理器notNullColumn CDATA columnPrefix CDATA 字段前缀，一对一中有涉及到resultSet CDATA foreignColumn CDATA autoMapping (true|false) 是否自定映射fetchType (lazy|eager) 是否懒加载 业务：用户与身份证是一对一的关系。 User类： 12345678910111213141516171819202122@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String userId; private String username; private String password; private String email; private String phone; private Integer gender; private Date birthday; private Integer status; private Date createTime; private String createUser; private Date modifyTime; private String modifyUser; private Card card;} 提示：这里使用了lombok 简化实例开发，依赖如下: 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt; Card类： 1234567891011121314@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class Card implements Serializable { private Integer id; private Integer uid; private String cardId; private String address; private Date createTime; private Date modifyTime;} 一对一自动映射​ 通过上面的实例类关系我们可以发现，card是User类中的一个属性，但是如何通过Mybatis的自动映射机制将card表中的数据之间填充到User属性中。我们可以在查询字段上使用别名来映射，如下，uid字段是user的card属性的属性，则可以通过card.uid 来映射到User类的card属性的uid字段。 123456789101112131415&lt;select id=\"findUserWithCardByUserId\" resultType=\"user\"&gt; SELECT a.id,a.user_id,a.username,a.password,a.email,a.phone, a.gender,a.birthday,a.status,a.create_time,a.create_user, a.modify_time,a.modify_user, b.id as \"card.id\" , b.uid as \"card.uid\", b.card_id as \"card.cardId\", b.address as \"card.address\", b.create_time as \"card.createTime\" , b.modify_time as \"card.modifyTime\" FROM tb_user a INNER JOIN tb_card b on a.id = b.uid where a.id = #{id};&lt;/select&gt; 一对一手动映射手动映射就是通过结果集的方式列进行映射,如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;resultMap id=\"BaseResultMapWithCard\" type=\"user\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\"/&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/&gt; &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/&gt; &lt;result column=\"phone\" jdbcType=\"VARCHAR\" property=\"phone\"/&gt; &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/&gt; &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;association property=\"card\" javaType=\"card\"&gt; &lt;id column=\"bid\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"uid\" jdbcType=\"INTEGER\" property=\"uid\"/&gt; &lt;result column=\"card_id\" jdbcType=\"VARCHAR\" property=\"cardId\"/&gt; &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findUserWithCardByUserId\" resultMap=\"BaseResultMapWithCard\"&gt; select a.id,a.user_id,a.username,a.password,a.email,a.phone,a.gender, a.birthday,a.status,a.create_time,a.create_user,a.modify_time,a.modify_user, b.id bid, b.uid, b.card_id, b.address, b.create_time, b.modify_time FROM tb_user a INNER JOIN tb_card b on a.id = b.uid where a.id = #{id}&lt;/select&gt; 通过上述的SQL查询和结果集的手动映射关系，这样就可以实现字段和实体的查询了。 当然，Mybatis还提供下面这种方式来实现： 1234567891011121314151617181920212223242526272829&lt;resultMap id=\"BaseResultMapWithCard\" type=\"user\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\"/&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/&gt; &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/&gt; &lt;result column=\"phone\" jdbcType=\"VARCHAR\" property=\"phone\"/&gt; &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/&gt; &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;association property=\"card\" javaType=\"card\" column=\"id\" select=\"selectCard\"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findUserWithCardByUserId\" resultMap=\"BaseResultMapWithCard\"&gt; select a.id,a.user_id,a.username,a.password,a.email,a.phone,a.gender, a.birthday,a.status,a.create_time,a.create_user,a.modify_time,a.modify_user FROM tb_user a where a.id = #{id}&lt;/select&gt;&lt;select id=\"selectCard\" resultType=\"card\"&gt; select * from tb_card where uid = #{id}&lt;/select&gt; 这样的操作其实就是先查询出User的信息，然后在取user表的id字段来查询card表的数据，这样就相当于向MySQL发送了两条SQL，我们通过日志可以观察到现象： ​ 两种方式都可以实现同样地结果，如果需要控制SQL发送条数的话，可以使用关联方式，如果需要在一定程度上降低SQL的查询时间，则可以将其拆分为多个查询SQL。 拓展： 下面我们看一下下面这个SQL如何进行映射，我们假设，一个User有一个主身份证和一个副身份证，那么我们需要如何查询映射： User: 123456789101112131415161718192021222324@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String userId; private String username; private String password; private String email; private String phone; private Integer gender; private Date birthday; private Integer status; private Date createTime; private String createUser; private Date modifyTime; private String modifyUser; private Card card;//主 private Card card1;//副} 对应的SQL映射如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;resultMap id=\"BaseResultMapWithCard\" type=\"user\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\"/&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/&gt; &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/&gt; &lt;result column=\"phone\" jdbcType=\"VARCHAR\" property=\"phone\"/&gt; &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/&gt; &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;association property=\"card\" javaType=\"card\" resultMap=\"cardResultMap\" columnPrefix=\"b1_\" /&gt; &lt;association property=\"card1\" javaType=\"card\" resultMap=\"cardResultMap\" columnPrefix=\"b2_\" /&gt;&lt;/resultMap&gt;&lt;resultMap id=\"cardResultMap\" type=\"card\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"uid\" jdbcType=\"INTEGER\" property=\"uid\"/&gt; &lt;result column=\"card_id\" jdbcType=\"VARCHAR\" property=\"cardId\"/&gt; &lt;result column=\"address\" jdbcType=\"VARCHAR\" property=\"address\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt;&lt;/resultMap&gt;&lt;select id=\"findUserWithCardByUserId\" resultMap=\"BaseResultMapWithCard\" &gt; select a.id,a.user_id,a.username,a.password,a.email,a.phone,a.gender, a.birthday,a.status,a.create_time,a.create_user,a.modify_time,a.modify_user, b1.id b1_id, b1.uid b1_uid, b1.card_id b1_card_id, b1.address b1_address, b1.create_time b1_create_time, b1.modify_time b1_modify_time, b2.id b2_id, b2.uid b2_uid, b2.card_id b2_card_id, b2.address b2_address, b2.create_time b2_create_time, b2.modify_time b2_modify_time from tb_user a inner join tb_card b1 on a.id = b1.uid inner join tb_card b2 on a.id = b2.uid where a.id = 1&lt;/select&gt; ​ ​ 当连接多个表时，我们可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 association标签的columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 关联关系一对多12345678910111213141516// 下面是collection标签的各个属性元素property CDATA #REQUIRED 必须，指定的是java实体类的属性名column CDATA 指定的是表的字段名（查询出来的，有可能是字段别名）javaType CDATA 集合一般不使用这个ofType CDATA 属性的java类型，例如：string，integerjdbcType CDATA 数据库的字段类型select CDATA 当我们需要进行嵌套查询的时候，执行另外一个查询语句resultMap CDATA 返回值的映射关typeHandler CDATA 类型处理notNullColumn CDATA columnPrefix CDATA 当我们需要进行区分的时候，可以指定前缀，后面有案例resultSet CDATA foreignColumn CDATA 外键autoMapping (true|false) 是否需要自动映射fetchType (lazy|eager) 是否进行懒加载 ​ 在实际开发中，权限往往是无关业务，但是又是至关重要的一环。在设计权限的时候，我们往往不会讲权限之间与用户之前关联，为了更加好的管理，我们会在用户与权限之间引入一个角色，用角色来统一管理具有相同权限的用户，一般一个用户存在于多个角色，比如即使CEO又是系统开发人员（哈哈），这里就是一个一对多的关系，下面我们看看，在Mybatis中一对多的关系如何映射： User: 12345678910111213141516171819202122@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String userId; private String username; private String password; private String email; private String phone; private Integer gender; private Date birthday; private Integer status; private Date createTime; private String createUser; private Date modifyTime; private String modifyUser; private List&lt;Role&gt; roles;} Role: 12345678910111213141516@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class Role implements Serializable { private Integer id; private String roleName; private String description; private Integer status; private Date createTime; private String createUser; private Date modifyTime; private String modifyUser;} 根据id查询的SQLxml文件： 这里与前面的一对多的关联关系有所不同 ，一对多关联关系使用的是association，java类型使用的是javaType。而多对多关联关系使用的标签是collection，java类型属性使用的是ofType。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;resultMap id=\"BaseResultWithRole\" type=\"com.ooyhao.mybatis.bean.User\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\"/&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/&gt; &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/&gt; &lt;result column=\"phone\" jdbcType=\"VARCHAR\" property=\"phone\"/&gt; &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/&gt; &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;collection property=\"roles\" ofType=\"role\"&gt; &lt;id column=\"cid\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/&gt; &lt;result column=\"description\" jdbcType=\"VARCHAR\" property=\"description\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"findUserWithRolesByUserId\" resultMap=\"BaseResultWithRole\"&gt; select a.id,a.user_id,a.username,a.password,a.email,a.phone,a.gender, a.birthday,a.status,a.create_time,a.create_user,a.modify_time,a.create_user, c.id cid, c.role_name, c.description, c.status, c.create_time, c.create_user, c.modify_time, c.create_user from tb_user a left join tb_user_role b on a.id = b.user_id left join tb_role c on c.id = b.role_id where a.id = #{id}&lt;/select&gt; 测试结果如下： 12345678910111213141516171819202122232425262728293031{ \"birthday\": 1551369600000, \"createTime\": 1551433926000, \"createUser\": \"admin\", \"email\": \"12345678@qq.com\", \"gender\": 1, \"id\": 1, \"modifyTime\": 1551679675000, \"password\": \"admin123456789\", \"phone\": \"12345678901\", \"roles\": [{ \"createTime\": 1551433926000, \"createUser\": \"admin\", \"description\": \"超级管理员\", \"id\": 1, \"modifyTime\": 1551679675000, \"roleName\": \"admin\", \"status\": 0 }, { \"createTime\": 1551433926000, \"createUser\": \"admin\", \"description\": \"开发人员\", \"id\": 2, \"modifyTime\": 1551679675000, \"roleName\": \"develop\", \"status\": 0 }], \"status\": 0, \"userId\": \"oms20190001\", \"username\": \"admin\"} 除了上述方式进行关联查询，我们还可以将SQL进行拆分： 关联嵌套查询： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;resultMap id=\"BaseResultWithRole\" type=\"com.ooyhao.mybatis.bean.User\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\"/&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\"/&gt; &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\"/&gt; &lt;result column=\"phone\" jdbcType=\"VARCHAR\" property=\"phone\"/&gt; &lt;result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\"/&gt; &lt;result column=\"birthday\" jdbcType=\"DATE\" property=\"birthday\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt; &lt;collection property=\"roles\" ofType=\"role\" column=\"id\" select=\"selectRole\" /&gt;&lt;/resultMap&gt;&lt;resultMap id=\"selectRole\" type=\"role\"&gt; &lt;id column=\"cid\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"role_name\" jdbcType=\"VARCHAR\" property=\"roleName\"/&gt; &lt;result column=\"description\" jdbcType=\"VARCHAR\" property=\"description\"/&gt; &lt;result column=\"status\" jdbcType=\"INTEGER\" property=\"status\"/&gt; &lt;result column=\"create_time\" jdbcType=\"TIMESTAMP\" property=\"createTime\"/&gt; &lt;result column=\"create_user\" jdbcType=\"VARCHAR\" property=\"createUser\"/&gt; &lt;result column=\"modify_time\" jdbcType=\"TIMESTAMP\" property=\"modifyTime\"/&gt; &lt;result column=\"modify_user\" jdbcType=\"VARCHAR\" property=\"modifyUser\"/&gt;&lt;/resultMap&gt;&lt;select id=\"findUserWithRolesByUserId\" resultMap=\"BaseResultWithRole\"&gt; select a.id,a.user_id,a.username,a.password,a.email,a.phone,a.gender, a.birthday,a.status,a.create_time,a.create_user,a.modify_time,a.create_user from tb_user a where a.id = #{id}&lt;/select&gt;&lt;select id=\"selectRole\" resultType=\"role\" &gt; select b.* from tb_user_role a left join tb_role b on a.role_id = b.id where a.user_id = #{id}&lt;/select&gt; 注：多对多其实就是双向的一对多关系，不再赘述。 鉴别器摘自官网： 有时候，一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）。 鉴别器（discriminator）元素就是被设计来应对这种情况的，另外也能处理其它情况，例如类的继承层次结构。 鉴别器的概念很好理解——它很像 Java 语言中的 switch 语句。 一个鉴别器的定义需要指定 column 和 javaType 属性。column 指定了 MyBatis 查询被比较值的地方。 而 javaType 用来确保使用正确的相等测试（虽然很多情况下字符串的相等测试都可以工作）。例如： 123456789101112131415161718192021222324252627282930313233343536373839&lt;resultMap id=\"vehicleResult\" type=\"Vehicle\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"vin\" column=\"vin\"/&gt; &lt;result property=\"year\" column=\"year\"/&gt; &lt;result property=\"make\" column=\"make\"/&gt; &lt;result property=\"model\" column=\"model\"/&gt; &lt;result property=\"color\" column=\"color\"/&gt; &lt;discriminator javaType=\"int\" column=\"vehicle_type\"&gt; &lt;case value=\"1\" resultMap=\"carResult\"/&gt; &lt;case value=\"2\" resultMap=\"truckResult\"/&gt; &lt;case value=\"3\" resultMap=\"vanResult\"/&gt; &lt;case value=\"4\" resultMap=\"suvResult\"/&gt; &lt;/discriminator&gt;&lt;/resultMap&gt;---------------------------------------也可以这样-----------------------------------------&lt;resultMap id=\"vehicleResult\" type=\"Vehicle\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"vin\" column=\"vin\"/&gt; &lt;result property=\"year\" column=\"year\"/&gt; &lt;result property=\"make\" column=\"make\"/&gt; &lt;result property=\"model\" column=\"model\"/&gt; &lt;result property=\"color\" column=\"color\"/&gt; &lt;discriminator javaType=\"int\" column=\"vehicle_type\"&gt; &lt;case value=\"1\" resultType=\"carResult\"&gt; &lt;result property=\"doorCount\" column=\"door_count\" /&gt; &lt;/case&gt; &lt;case value=\"2\" resultType=\"truckResult\"&gt; &lt;result property=\"boxSize\" column=\"box_size\" /&gt; &lt;result property=\"extendedCab\" column=\"extended_cab\" /&gt; &lt;/case&gt; &lt;case value=\"3\" resultType=\"vanResult\"&gt; &lt;result property=\"powerSlidingDoor\" column=\"power_sliding_door\" /&gt; &lt;/case&gt; &lt;case value=\"4\" resultType=\"suvResult\"&gt; &lt;result property=\"allWheelDrive\" column=\"all_wheel_drive\" /&gt; &lt;/case&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; 提示：请注意，这些都是结果映射，如果你完全不设置任何的 result 元素，MyBatis 将为你自动匹配列和属性。所以上面的例子大多都要比实际的更复杂。 这也表明，大多数数据库的复杂度都比较高，我们不太可能一直依赖于这种机制。 下面通过一个案例来使用一下鉴别器： 数据如下： 我们通过接口的方式来使用鉴别器创建不同的交通工具实体： 123456789101112131415161718192021222324252627282930313233public interface Vehicle {}@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class Bus implements Vehicle { private Integer id; private String name;}@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class Car implements Vehicle{ private Integer id; private String name;}@NoArgsConstructor@AllArgsConstructor@Getter@Setter@ToStringpublic class Subway implements Vehicle { private Integer id; private String name;} Sql.xml文件： 123456789101112131415161718&lt;resultMap id=\"BaseResultMap\" type=\"com.ooyhao.mybatis.bean.Vehicle\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;discriminator javaType=\"INTEGER\" jdbcType=\"INTEGER\" column=\"vehicle_type\" &gt; &lt;case value=\"1\" resultType=\"car\"&gt; &lt;result property=\"name\" column=\"vehicle_name\" jdbcType=\"VARCHAR\" /&gt; &lt;/case&gt; &lt;case value=\"2\" resultType=\"bus\"&gt; &lt;result property=\"name\" column=\"vehicle_name\" jdbcType=\"VARCHAR\"/&gt; &lt;/case&gt; &lt;case value=\"3\" resultType=\"subway\"&gt; &lt;result property=\"name\" column=\"vehicle_name\" jdbcType=\"VARCHAR\"/&gt; &lt;/case&gt; &lt;/discriminator&gt;&lt;/resultMap&gt;&lt;select id=\"findVehicleById\" resultMap=\"BaseResultMap\"&gt; select * from tb_vehicle where id = #{id}&lt;/select&gt; 在case以外的，就相当于在每一个case中都会存在，而在case中的则是根据条件来选择的。 id为1时： id为3时： 源码地址： https://gitee.com/ooyhao/JavaRepo_Public/tree/master/Mybatis","link":"/2020/01/18/SSM/mybatis/3Mybatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/"},{"title":"三、高级装配","text":"高级装配 环境与Profile​ 在实际开发过程中，往往会将项目发布到不同的环境中，由于环境的不同，我们一般需要对在不同环境的数据和配置进行一些个性化的设定。比如，我们一般将开发到生产流程中的环境分为三种：开发(dev)、测试(test)和生产(prod)。而在这三种环境下，我们有些配置（如数据源）需要根据环境来切换。下面看看Spring中如何进行环境的个性化配置。 JavaConfig配置类定义一个普通的User类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class User implements Serializable { private String name; private Integer age; private String sex; public User() {} public User(String name, Integer age, String sex) { this.name = name; this.age = age; this.sex = sex; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", sex='\" + sex + '\\'' + '}'; }} BeanConfigA类：(使用@Profile 来指定环境，可以修饰在类上和方法上。此处只演示修饰在类上的，表示当前类中所有的Bean都只能在dev环境下，才能实例化到IoC容器中。当修饰在方法上，与@Bean配合使用时，将用更加细粒度的控制某一个类在某种环境下才能创建出来) 12345678@Profile(value = \"dev\")@Configurationpublic class BeanConfigA { @Bean public User user(){ return new User(\"张三\",23,\"男\"); }} BeanConfigB类： 12345678@Profile(value = \"prod\")@Configurationpublic class BeanConfigB { @Bean public User user(){ return new User(\"李四\",23,\"男\"); }} BeanConfig类： 12@ComponentScan(basePackages = \"com.ooyhao.spring\")public class BeanConfig {} 测试类： 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = BeanConfig.class)@ActiveProfiles(value = {\"prod\"})public class BeanConfigTest { @Autowired private User user; @Test public void testProfile(){ System.out.println(user); }} 上面使用了在集成测试类上，适应@ActiveProfiles 注解来指定当前测试的环境。 Xml配置文件的方式beanXmlConfig.xml文件： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;beans profile=\"dev\"&gt; &lt;bean class=\"com.ooyhao.spring.bean.User\"&gt; &lt;property name=\"name\" value=\"ouYanghao\"/&gt; &lt;property name=\"age\" value=\"23\"/&gt; &lt;property name=\"sex\" value=\"男\"/&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;beans profile=\"prod\"&gt; &lt;bean class=\"com.ooyhao.spring.bean.User\"&gt; &lt;property name=\"name\" value=\"王五\"/&gt; &lt;property name=\"age\" value=\"30\"/&gt; &lt;property name=\"sex\" value=\"女\"/&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;beans profile=\"test\"&gt; &lt;bean class=\"com.ooyhao.spring.bean.User\"&gt; &lt;constructor-arg name=\"name\" value=\"翠花\"/&gt; &lt;constructor-arg name=\"age\" value=\"28\"/&gt; &lt;constructor-arg name=\"sex\" value=\"女\"/&gt; &lt;/bean&gt; &lt;/beans&gt;&lt;/beans&gt; 注意： ​ xml配置的方式可以看出：通过使用&lt;beans&gt; 标签中嵌套 &lt;beans&gt; 标签，并且使用 &lt;beans&gt; 标签的profile属性来指定环境。 激活Profile环境的几种方式Spring在确定哪个Profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active 和 spring.profiles.default . 如果设置了spring.profiles.active 属性的话，那么它的值就会用来确定哪个profile是激活的。但是如果没有设置spring.profiles.active的话，那spring将会查找 spring.profiles.default 的值，如果spring.profiles.default 和 spring.profiles.active 的值均没设定时，那么久无法激活profile，只有那些没有定义在任何profile中的Bean才会会创建。 有多种方式来设定这两个属性： 作为DispatcherServlet的初始化参数； 作为Web应用的上下文参数； 作为JNDI条目； 作为环境变量； 作为JVM的系统属性； 在集成测试类上，使用@ActiveProfiles 注解设置。 在Web.xml文件中设置： Idea 中如何修改环境变量： Idea 中如何修改JVM的系统变量： 在集成测试类上 ，使用@ActiveProfiles注解设置。 条件化的Bean基本使用在实际开发中，有时候需要控制某些Bean在某些特定的时候才创建，在Spring4之前很难实现这种条件化配置，但是spring4中引入了@Conditional 注解，他可以用到带有@Bean 注解的方法上，如果给定的条件计算结果为true，就会创建这个Bean，否则就会忽略这个Bean的创建。 下面我们以笔记本电脑和笔记本电池为案例，展开讲述 @Conditional 的使用，设定：笔记本创建时需要判断笔记本电池是否创建？ 案例：当我们创建Computer类时，假设需要依赖于Battery类，如果当前容器中没有创建Battery实例，Computer就不创建了。 Computer 类： 12345678910public class Computer { private String brand; private String name; private Battery battery; //noArgsConstructor //allArgsConstructor //getter and setter //toString} Battery 类： 123456789public class Battery { private String brand; private String name; //noArgsContructor //allArgsConstrctor //getter and setter //toString} ComputerCondition类： 通过使自定义Condition类实现Spring的Condition接口，并实现matches方法，依照其返回值true和false来判断标有@Conditional(ComputerCondition.class) 的bean是否创建。 12345678910111213141516public class ComputerCondition implements Condition { /*判断是否某个Bean存在时，存创建指定的Bean*/ public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { try { ConfigurableListableBeanFactory factory = context.getBeanFactory(); Battery bean = factory.getBean(Battery.class); System.out.println(bean); if (bean == null) { return false; } return true; }catch (Exception e){ return false; } }} 配置类： 12345678910111213141516public class BeanConfig { //@Bean public Battery battery(){ return new Battery(\"小米\",\"小米笔记本电池\"); } @Bean @Conditional(ComputerCondition.class) public Computer computer(Battery battery){ Computer computer = new Computer(); computer.setBrand(\"小米\"); computer.setName(\"小米笔记本\"); computer.setBattery(battery); return computer; }} 测试，将创建容器后用断点截断，查看： 测试结果可以直接查看Spring IoC容器中创建了哪些Bean。下图中的 BeanDefinitionMap 就是IoC容器存放Bean的一个地方。 而将配置类中创建电池方法的@Bean 注解注释取消之后，其结果如下图： 小案例用@Conditional 注解来实现@profiles 功能，并且要求在不同的环境下 ，创建不同的Computer Bean。 DevCondition： 12345678910public class DevCondition implements Condition { public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { return context.getEnvironment().acceptsProfiles(new Profiles() { @Override public boolean matches(Predicate&lt;String&gt; activeProfiles) { return activeProfiles.test(\"dev\");// } }); }} TestCondition和ProdCondition只需要将上述代码中的dev改成test或是prod即可。 自定义注解，通过使用@Conditional 注解来标注，即相当于继承了@Conditional 注解，通过制定DevCondition.class. 表示当前注解条件判断是使用DevCondition中的逻辑来判断的。 12345@Target({ElementType.METHOD,ElementType.TYPE})@Inherited@Retention(RetentionPolicy.RUNTIME)@Conditional(DevCondition.class)public @interface DevConditional {} @TestConditional 和 @ProdConditional 只需要修改其传入@Conditional 注解的类即可。 配置类： 1234567891011121314151617181920212223242526272829303132333435363738public class BeanConfig { @Bean public Battery battery(){ return new Battery(\"小米\",\"小米笔记本电池\"); } @Bean @DevConditional public Computer devComputer(){ Computer computer = new Computer(); computer.setBrand(\"小米\"); computer.setName(\"小米笔记本-DEV\"); computer.setBattery(battery()); return computer; } @Bean @TestConditional public Computer testComputer(){ Computer computer = new Computer(); computer.setBrand(\"小米\"); computer.setName(\"小米笔记本-TEST\"); computer.setBattery(battery()); return computer; } @Bean @ProdConditional public Computer prodComputer(){ Computer computer = new Computer(); computer.setBrand(\"小米\"); computer.setName(\"小米笔记本-PROD\"); computer.setBattery(battery()); return computer; }} 测试：通过前面的几种方式可以切换环境，可以测试出能够根据环境的不同产生不同的Computer。 matches方法​ 上面案例和介绍可以看出，通过@Conditional 以及配合Condition接口来实现工作是很简单的，实现Condition接口只需要实现matches方法即可，接下来我们来详细看一下matches方法传入的两个参数：ConditionContext和AnnotatedTypeMetaData。 ConditionContextConditionContext是一个接口，源代码如下： 1234567891011121314// @since 4.0public interface ConditionContext { BeanDefinitionRegistry getRegistry(); @Nullable ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); @Nullable ClassLoader getClassLoader();} 通过ConditionContext，我们可以做到如下几点： 借助getRegistry()返回的BeanDefinitionRegistry检查bean定义； 借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在甚至探查bean的属性； 借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么； 读取并探查getResourceLoader()返回的ResourceLoader所加载的资源； 借助getClassLoader()返回的ClassLoader加载并检查类是否存在； AnnotatedTypeMetaDataAnnotatedTypeMetaData则能够让我们检查带有@Bean 注解的方法上还有什么 注解。与ConditionContext一样，也是一个接口： 123456789101112131415161718// @since 4.0public interface AnnotatedTypeMetadata { boolean isAnnotated(String annotationName); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String annotationName); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String annotationName, boolean classValuesAsString); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationName); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationName, boolean classValuesAsString);} 借助isAnntated()方法，我们能够判断带有@Bean 注解的方法是不是还有其他特定的注解。借助其他的那些方法，我们能够检查@Bean 注解的方法是不是还有其他注解。 其实@Profiles 注解也是使用了@Conditional 注解，并且引用ProfileCondition作为Condition实现，如下所示，ProfileCondition实现了Condition接口，并且在作出决策的过程中，考虑到了ConditionContext 和 AnnotatedTypeMetaData中的多个元素。 123456789101112131415class ProfileCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) { for (Object value : attrs.get(\"value\")) { if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) { return true; } } return false; } return true; }} 处理歧义性Bean当我们在注入Bean的时候，不管是byType,还是byName，如果遇到了两个相同的Bean的时候，Spring就会包NoUniqueBeanDefinitionException 即：不唯一的Bean的定义异常。 Animal： 1public interface Animal {} Cat：(省略无参构造，全参构造，getter，setter，toString方法，后面亦如此) 1234public class Cat implements Animal { private String name; private Integer age;} Dog： 1234public class Dog implements Animal { private String name; private Integer age;} Person： 1234public class Person { private String name; private Animal pet;} BeanConfig： 1234567891011121314151617181920public class BeanConfig { @Bean public Animal cat(){ return new Cat(\"小喵\",3); } @Bean public Animal dog(){ return new Dog(\"小七\",2); } /** * 实例化一个类，其宠物是Animal类型 * */ @Bean public Person person(Animal animal){ return new Person(\"张三\",animal); }} 上述代码运行如下(报错：Bean定义不唯一异常，需要装配Animal，希望找到一个，但是发现了两个，cat，dog)： 标注首选项JavaConfig配置类形式123456789101112131415161718192021public class BeanConfig { @Bean @Primary public Animal cat(){ return new Cat(\"小喵\",3); } @Bean public Animal dog(){ return new Dog(\"小七\",2); } /** * 实例化一个类，其宠物是Animal类型 * */ @Bean public Person person(Animal animal){ return new Person(\"张三\",animal); }} XML配置形式multiBean.xml： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"com.ooyhao.spring.bean.Dog\" primary=\"true\" &gt; &lt;property name=\"name\" value=\"小小七\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.ooyhao.spring.bean.Cat\"&gt; &lt;property name=\"name\" value=\"小小喵\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt; &lt;/bean&gt;&lt;/beans&gt; XmlBeanConfig配置类： 12345678@ImportResource(\"classpath:multiBean.xml\")public class XmlBeanConfig { @Bean public Person person(Animal animal){ return new Person(\"王五\",animal); }} 总结： ​ 通过上述JavaConfig配置类或是Xml配置文件，可以发现，其实在遇到歧义性Bean的时候，可以通过标注首选项来解决，在JavaConfig配置类上使用@Primary 注解 或是在 Xml配置文件在bean标签中使用primary=true 来实现。 限制自动装配的Bean如果在实际项目中byType注入的时候出现多个相同的Bean的时候，我们可以通过ID的形式注入。如下： 在Cat和Dog类上使用@Component 注解标注，Person类如下： 1234567891011@Componentpublic class Person { private String name;// @Autowired// @Qualifier(\"dog\") @Resource(name = \"dog\") private Animal pet;} 通过使用@Autowired 和 @Qualifier 配合使用，并在Qualifier中指定Bean的ID。或者使用@Resource注解，在其name属性指定bean 的Id。 这里特别注释一下这几个注解的注入方式： @AutoWired 注解 ​ 默认是byType 进行装配的，如果在IoC容器中存在两个或两个以上的Bean类型一致时，Autowired会转变为byName进行装配，如果此时相同类型的Bean的ID存在0个或两个以两个以上与需要注入属性的名字一致，则会抛出 NoUniqueBeanDefinitionException 异常。如果此时需要装配Bean的ID与属性名不一致，可以配合@Qualifier 注解来标注。 @Resource 注解 @Resource其实与@Autowired的作用是一致的，都是用来装配Bean的，但是@Resource默认是byName来装配的，@Resource有两个比较 重要的属性，一个是name，一个是type，如果指定name，其实就是使用byName进行装配，如果指定type，则是使用byType进行装配。 装配顺序如下： 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 如果指定了name，则从上下文中查找名称（id）匹配的Bean进行装配，否则就抛出异常。 如果指定了type，则从上下文中查找类型匹配的唯一bean进行装配，找不到或者多个，都会抛出异常。 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为类型匹配，如果匹配则自动装配。 @Qualifier注解 不仅可以与Autowired注解配置使用标注在属性，构造方法，set方法上，还可以标注在类上，如果一个类使用@Component注解标注，通过自动扫描产生的Bean的ID是类名的首字母小写的形式，而如果使用@Qualifier注解组合标注，只需要在注入的时候，选择合适的标注信息进行标注即可。 注意: ​ 1和2 示例中，使用@Qualifier注解只是为Dog对象打一个标注，并不是将Dog对象的ID由dog变成了pet，所以，如果在注入的时候，仅是使用2中的代码依旧会抛出异常，需要使用3中的代码，即需要在注入的时候加上这个标注。如果需要使用2中的代码，则需要将Dog的ID由dog修改为pet，即直接在@Component的value中指定为pet即可。 12345678910111213141516171819202122232425262728293031323334353637// ----------------------1------------------------------@Component@Qualifier(\"pet\")public class Dog implements Animal { private String name; private Integer age;}// ----------------------2-------------------------------@Componentpublic class Person { private String name; @Autowired private Animal pet;}// ----------------------3-------------------------------@Componentpublic class Person { private String name; @Autowired @Qualifier(\"pet\") private Animal pet;}//------------------------4-----------------------------@Component(\"pet\")//@Qualifier(\"pet\")public class Dog implements Animal { private String name; private Integer age;} 由于@Qualifier的注解只是将Bean打上一个标注，而如果遇到两个或两个以上的Bean打了一个相同的标注，此时又无法实现装配了，有人可能会说，一个不够，那就多打几个。由图片可以看出，不支持标注多个@Qualifier的注解，否则会报编译异常。那么如何解决呢？ 上述问题可以通过自定义注解来解决，自定义注解结合@Qualifier注解实现，如下： IPet注解： 1234@Target({ElementType.METHOD,ElementType.TYPE,ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface IPet {} ICat注解： 1234@Target({ElementType.METHOD,ElementType.TYPE,ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface ICat {} IDog注解： 1234@Target({ElementType.METHOD,ElementType.TYPE,ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface IDog {} Cat类： 1234567@Component@IPet@ICatpublic class Cat implements Animal { private String name; private Integer age;} Dog类： 1234567@Component@IPet@IDogpublic class Dog implements Animal { private String name; private Integer age;} Person类使用： 12345678910@Componentpublic class Person { private String name; @Autowired @IPet @IDog private Animal pet;} 测试结果如下： Bean的作用域Bean的作用域分为四种：singleton, prototype, session, request. singleton:单例，默认，即每次从容器中获取的对象都是同一个 prototype：多例（原型），即每次从容器中获取的对象都是不一样的。 session：回话，用于web环境，一次session回话是同一个对象。 request：请求，用于web环境，一次request请求是同一个对象。 常见的作用域是singleton和prototype，下面主要是演示下面两种： Java配置类形式singleton作用域： 123456@Component@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)public class Cat implements Animal { private String name; private Integer age;} prototype作用域： 123456@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Dog implements Animal { private String name; private Integer age;} BeanConfig 配置类： 12@ComponentScan(basePackages = \"com.ooyhao.spring\")public class BeanConfig {} 测试类： 12345678910111213141516public class ScopeTest { @Test public void testScope(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(BeanConfig.class); Cat bean1 = context.getBean(Cat.class); Cat bean2 = context.getBean(Cat.class); System.out.println(bean1 == bean2);//true Dog dog1 = context.getBean(Dog.class); Dog dog2 = context.getBean(Dog.class); System.out.println(dog1 == dog2);//false }} Xml配置文件形式Bean类： 12public class Computer {}public class MobilePhone {} scope.xml配置文件： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"com.ooyhao.spring.bean.Computer\" scope=\"singleton\"/&gt; &lt;bean class=\"com.ooyhao.spring.bean.MobilePhone\" scope=\"prototype\"/&gt;&lt;/beans&gt; 测试类： 123456789101112@Testpublic void testXmlConfig(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"scope.xml\"); Computer computer1 = context.getBean(Computer.class); Computer computer2 = context.getBean(Computer.class); System.out.println(computer1 == computer2);//true MobilePhone mobilePhone1 = context.getBean(MobilePhone.class); MobilePhone mobilePhone2 = context.getBean(MobilePhone.class); System.out.println(mobilePhone1 == mobilePhone2);//false} 运行时注入值Spring 提供了两种在运行时求的方式： 属性占位符(${}) Spring表达式语言(#{}) https://www.cnblogs.com/slowcity/p/9097969.html 注入外部值 在Spring中，处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。 application.properties文件： 123name=ooyhaoage=12sex=男 ​ 通过使用@PropertySource注解，将指定下的文件(此例：application.properties)会被加载到Spring的Environment中，稍后可以从这里检索属性。 UserConfig配置文件： 12345678910111213141516@PropertySources( @PropertySource(value = \"classpath:application.properties\",encoding = \"utf-8\"))public class UserConfig { @Autowired private Environment environment; @Bean public User user(){ String name = environment.getProperty(\"name\"); Integer age = Integer.valueOf(environment.getProperty(\"age\")); String sex = environment.getProperty(\"sex\"); return new User(name,age,sex); }} 深入学习Environment通过打印上述代码中自动注入的Environment可以看出，注入的其实是：org.springframework.core.env.StandardEnvironment. 而它有继承自AbstractEnvironment . AbstractEnviroment 部分方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class AbstractEnvironment implements ConfigurableEnvironment {//=============================profile=============================== // 获取所有激活的profile，返回数组 public String[] getActiveProfiles() {} // 获取所有激活的profile，返回集合 protected Set&lt;String&gt; doGetActiveProfiles() {} // 设置多个激活的profile public void setActiveProfiles(String... profiles) {} // 添加一个激活的profile public void addActiveProfile(String profile) {} // 获取所有的默认的profile，返回数组 public String[] getDefaultProfiles() {} // 获取所有的默认的profile，返回集合 protected Set&lt;String&gt; doGetDefaultProfiles() {} // 设置多个默认的profile public void setDefaultProfiles(String... profiles) {} // 传入一个Profiles，用于判断是否符合特定的条件 public boolean acceptsProfiles(Profiles profiles) {} // 判断一个profile是否为激活状态 protected boolean isProfileActive(String profile) {} // 验证一个profile protected void validateProfile(String profile) {} //=============================property============================== //获取所有的属性源PropertySource public MutablePropertySources getPropertySources() {} // 获取系统属性 public Map&lt;String, Object&gt; getSystemProperties() {} // 获取系统环境 public Map&lt;String, Object&gt; getSystemEnvironment() {} // 设置一个或多个必要的属性值 public void setRequiredProperties(String... requiredProperties) {} // 验证必要的属性 public void validateRequiredProperties() throws MissingRequiredPropertiesException {} // 是否包含指定属性 public boolean containsProperty(String key) {} // 通过指定key，获取属性的值 public String getProperty(String key) {} // 通过指定key，获取属性值，如果没有，则使用默认值 public String getProperty(String key, String defaultValue) {} // 通过指定key，获取属性值，格式化为指定类型对象 public &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType) {} // 通过指定key，获取属性值，格式化为指定类型对象，如果没有，则使用默认值 public &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue) {} // 获取一个必要的key所对应的属性，如果没有则抛出异常 public String getRequiredProperty(String key) throws IllegalStateException {} // 获取一个必要的key所对应的属性，格式化为指定类型对象,如果没有，则抛出异常 public &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException {}} ​ 直接从 Environment 中检索属性是十分方便的，尤其是在Java配置中装配Bean的时候。但是，Spring也提供了通过占位符装配属性的方法，这些占位符的值会来源于一个属性源。 解析属性占位符​ Spring 一直支持将属性定义在外面的属性文件中，并使用占位符值将其插入到Spring Bean中。在Spring装配中，占位符的形式为使用${} 包装的属性名称。 12345678910111213141516171819202122232425262728//@PropertySource(value = \"classpath:application.properties\",encoding = \"utf-8\")/*@PropertySources( @PropertySource(value = \"classpath:application.properties\",encoding = \"utf-8\"))*/public class UserConfig { @Bean public PropertySourcesPlaceholderConfigurer placeholderConfigurer(){ PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer(); Resource resource = new ClassPathResource(\"application.properties\"); configurer.setLocations(resource); return configurer; } @Value(\"${name}\") private String name; @Value(\"${age}\") private Integer age; @Value(\"${sex}\") private String sex; @Bean public User user(){ return new User(name,age,sex); }} 上面提供了两种方式，一种是使用@PropertySources注解，一种是通过创建PropertySourcesPlaceholderConfigurer来指明属性文件的相关信息。 测试： 1234567@Testpublic void testProperties(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(UserConfig.class); User bean = context.getBean(User.class); System.out.println(bean); //User{name='ooyhao', age=12, sex='男'}} 当然也可以使用Xml文件的形式： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--如果需要多个，可以使用逗号分隔或是使用通配符*--&gt; &lt;context:property-placeholder file-encoding=\"utf-8\" location=\"application.properties\"/&gt; &lt;bean class=\"com.ooyhao.spring.bean.User\"&gt; &lt;property name=\"name\" value=\"${name}\"/&gt; &lt;property name=\"age\" value=\"${age}\"/&gt; &lt;property name=\"sex\" value=\"${sex}\"/&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 可以看出，除了上述例子中的属性，还包含更多的属性，比如ignore-resource-not-found和ignore-unresolvable 等属性。上述文件中说明了如何指定多个属性文件。 12&lt;context:property-placeholderlocation=\"classpath:db.properties,classpath:monitor.properties\" /&gt;&lt;context:property-placeholderlocation=\"classpath:*.properties\" /&gt; 属性解释： 12ignore-resource-not-found //如果属性文件找不到，是否忽略，默认false，即不忽略，找不到文件并不会抛出异常。 ignore-unresolvable //是否忽略解析不到的属性，如果不忽略，找不到将抛出异常。但它设置为true的主要原因是： Spring Expression Language介绍Spring Expression Language ：缩写 SpEL。Spring3引入的，它能够以一种强大和简洁的方式将值装配到Bean属性和构造器参数中，在这个过程中所使用的表达式会在运行时计算得到值。使用SpEL，我们可以实现超乎想象的装配效果，这是使用其他的装配技术难以做到的。 SpEL拥有很多特性，包括： 使用bean的ID来引用bean。 调用方法和访问对象的属性。 对值进行算数、关系和逻辑运算。 正则表达式匹配。 集合操作。 ​与属性占位符不同的是，属性占位符使用的是${} , SpEL的表达式是使用#{} 。SpEL 拥有很多特性，例如：调用方法，访问属性，调用构造方法。 小试牛刀下面的结果是：Hello World! 123ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(\" 'Hello World'.concat('!') \");System.out.println(expression.getValue()); 下面的结果是：5 1234ExpressionParser parser = new SpelExpressionParser();//调用 byte[] 的 length属性Expression expression2 = parser.parseExpression(\" 'Hello'.bytes.length \");System.out.println(expression2.getValue());//5 下面的结果：HELLO 123ExpressionParser parser = new SpelExpressionParser();Expression expression3 = parser.parseExpression(\" 'hello'.toUpperCase() \");System.out.println(expression3.getValue());//HELLO Xml文件配置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"address\" class=\"com.ooyhao.spring.bean.Address\"&gt; &lt;property name=\"id\" value=\"#{T(java.lang.Math).random() *10 }\"/&gt; &lt;property name=\"name\" value=\"上海\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.ooyhao.spring.bean.User\"&gt; &lt;property name=\"name\" value=\"ooyhao\"/&gt; &lt;property name=\"age\" value=\"#{T(java.lang.Math).random() *100 }\"/&gt; &lt;property name=\"addrName\" value=\"#{address.name}\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Java类注解配置在属性上使用： 123456789101112131415161718192021public class SpELConfig { @Value(\"#{T(java.lang.Math).random() * 10}\") private Integer id; @Value(\"北京\") private String addrName; @Value(\"#{address.name}\") private String address; @Bean public Address address(){ return new Address(id,addrName); } @Bean public User user(){ return new User(\"1\",23,address); }} 在方法上使用 ： 1234@Value(\"#{address.name}\")public void setAddrName(String addrName) { this.addrName = addrName;} 在构造方法上使用： 注意：在构造方法上使用，需要与@Autowired 配合使用，并且如果需要使用，则全部都需要注入，单个注入会报编译错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Componentpublic class User { @Value(\"#{'林黛玉'}\") private String name; @Value(\"#{T(java.lang.Math).random() * 4 + 16}\") private Integer age; private String addrName; public User() {} @Autowired public User(@Value(\"#{address.name}\") String addrName){ this.addrName = addrName; } public User(String name, Integer age,String addrName) { this.name = name; this.age = age; this.addrName = addrName; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getAddrName() { return addrName; } public void setAddrName(String addrName) { this.addrName = addrName; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", addrName='\" + addrName + '\\'' + '}'; }} SpEL所支持的参考文档和文档： https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#expressions-language-ref https://blog.csdn.net/fanxiaobin577328725/article/details/68942967 支持：（下面仅测试部分类型，具体详细的可以查看Spring官方文档） 字面量123456789101112ExpressionParser parser = new SpelExpressionParser();// Hello WorldString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();// 6.0221415E23double avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();// 2147483647int maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();// trueboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();// nullObject nullValue = parser.parseExpression(\"null\").getValue(); 也可以写作： 1234567891011121314@Value(\" 'Hello World' \")private String hello;@Value(\"6.0221415E+23\")private Double num;@Value(\"0x7FFFFFFF\")private Integer maxValue;@Value(\"true\")private Boolean bool;@Value(\"null\")private Object oNull; 对象​ 调用对象，对象的属性，对象的方法。 [?.] 会先判断问号左边是否为空，是则直接注入null，不在调用右边的方法。 12345678910111213141516171819@Value(\"#{user}\")private User user;@Value(\"#{user.name}\")private String userName;@Value(\"#{user.name.toUpperCase()}\")private String nameUp;@Value(\"#{user.getAddrName().toUpperCase()}\")private String addrUp;@Value(\"#{user.getName() ?.toUpperCase()}\") private String upName;//null@Beanpublic User user(){ return new User(null,23,\"shanghai\");} 类型12345@Value(\"#{T(java.lang.Math).PI}\")private Double pi;// 3.141592653589793@Value(\"#{T(java.lang.Math).random() * 100}\")private Integer randomNum; 运算符 运算符类型 运算符 算数运算符 +、-、*、/、%、^ 比较运算符 &lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge 逻辑运算 and、or、not、| 条件元素符 ?:(ternary)、?:(Elvis) 正则表达式 matches 集合计算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Value(\"#{ user.mobilePhone[1].getName() }\")private String name;// 小米手机@Value(\"#{ user.mobilePhone[1].getColors()[0] }\")private String color;//Pink/*过滤name是华为手机的MobilePhone对象到一个集合*/@Value(\"#{ user.mobilePhone.?[name eq '华为手机' ] }\")private List&lt;MobilePhone&gt; mobilePhone;//[MobilePhone{name='华为手机', colors=[Blue, Yellow, Green]}]/*投影，将user对象中所有的mobilePhone的name属性投影到一个集合中*/@Value(\"#{ user.mobilePhone.![name] }\")private List&lt;String&gt; names;//[华为手机, 小米手机, 小米手机]/*选择user对象中所有的mobilePhone中第一个name属性为小米手机的MobilePhone*/@Value(\"#{ user.mobilePhone.^[name eq '小米手机'] }\")private MobilePhone mobilePhone1;//MobilePhone{name='小米手机', colors=[Pink, Red, White]}/*选择user对象中所有的mobilePhone中最后一个name属性为小米手机的MobilePhone*/@Value(\"#{ user.mobilePhone.$[name eq '小米手机'] }\")private MobilePhone mobilePhone2;//MobilePhone{name='小米手机', colors=[black, cyan, orange]}@Beanpublic MobilePhone huaWei(){ MobilePhone mobilePhone = new MobilePhone(); mobilePhone.setName(\"华为手机\"); List&lt;String&gt; colors = new ArrayList&lt;String&gt;(); colors.add(\"Blue\"); colors.add(\"Yellow\"); colors.add(\"Green\"); mobilePhone.setColors(colors); return mobilePhone;}@Beanpublic MobilePhone xiaoMi(){ MobilePhone mobilePhone = new MobilePhone(); mobilePhone.setName(\"小米手机\"); List&lt;String&gt; colors = new ArrayList&lt;String&gt;(); colors.add(\"Pink\"); colors.add(\"Red\"); colors.add(\"White\"); mobilePhone.setColors(colors); return mobilePhone;}@Beanpublic MobilePhone xiaoO(){ MobilePhone mobilePhone = new MobilePhone(); mobilePhone.setName(\"小米手机\"); List&lt;String&gt; colors = new ArrayList&lt;String&gt;(); colors.add(\"black\"); colors.add(\"cyan\"); colors.add(\"orange\"); mobilePhone.setColors(colors); return mobilePhone;} 总结： ​ 本节基于上节的基础上，进一步了解了Spring的装配特性，从上一节中如何装配Bean到这一节的条件化Bean，歧义性Bean和外部属性值，以及Spring Expression Language 的使用。至此，Spring的IoC部分的大多数知识也已经涉及到，至于高级API知识和源码分析等就不再深入，等本人达到一定水平后，在回头研究Spring或SpringBoot，这一系列主要是基于Spring-in-Action这本书所记录的笔记，系统的复习和再次深入学习一遍。","link":"/2020/01/29/SSM/spring4x/3%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/"},{"title":"七、SpringMVC高级技术","text":"SpringMVC高级技术 通过web.xml加载JavaConfig配置​ 我们前面使用了纯web.xml形式加载applicationContext.xml和springmvc.xml配置文件来搭建一个web项目，也使用AbstractAnnotationConfigDispatcherServletInitializer纯java配置的形式加载ServletConfig.java和RootConfig.java配置类来搭建web项目，这次我们使用web.xml形式结合ServletConfig.java和RootConfig.java搭建项目。 web.xml文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--使用 Java配置形式来加载ApplicationContext/RootConfig.java配置类--&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.ooyhao.spring.config.RootConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置 Java配置形式的DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.ooyhao.spring.config.ServletConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; web加载配置类实现上传文件POM文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-07-01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-07-01 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--导入Servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入SpringMVC依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--hibernate参数校验依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.0.Alpha3&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合Thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-07-01&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--使用 Java配置形式来加载ApplicationContext/RootConfig.java配置类--&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt; contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.ooyhao.spring.config.RootConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置 Java配置形式的DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.ooyhao.spring.config.ServletConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;multipart-config&gt; &lt;location&gt;D:\\data&lt;/location&gt; &lt;max-file-size&gt;52428800&lt;/max-file-size&gt; &lt;max-request-size&gt;52428800&lt;/max-request-size&gt; &lt;file-size-threshold&gt;0&lt;/file-size-threshold&gt; &lt;/multipart-config&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 我们这里使用了web.xml文件来加载配置类的形式搭建web项目。为了实现文件上传，我们可以看出这个web.xml中与前一节不同的是，多个下面几行代码： 123456&lt;multipart-config&gt; &lt;location&gt;D:\\data&lt;/location&gt; &lt;max-file-size&gt;52428800&lt;/max-file-size&gt; &lt;max-request-size&gt;52428800&lt;/max-request-size&gt; &lt;file-size-threshold&gt;0&lt;/file-size-threshold&gt;&lt;/multipart-config&gt; 这个就是用于配置文件上传的一些信息， location:表示文件上传存储的位置。 max-file-size：上传文件的最大容量（以字节为单位）。默认是没有限制的。 max-request-size：整合multipart请求的最大容量（以字节为单位），不会关心有多少个part以及每一个part的大小，默认是没有限制的。 file-size-threshold：在上传过程中，如果文件大小达到了一个指定最大容量（以字节为单位），将会写入到临时文件路径中。默认为0，也就是所有上传的文件都会写入到磁盘上。 ServletConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 描述: * 类【ServletConfig】 * * @author ouYangHao * @create 2019-09-09 16:19 *//*相当于springmvc.xml*/@Configuration@EnableWebMvc@ComponentScan(basePackages = \"com.ooyhao.spring.**.controller\")public class ServletConfig{ @Bean public MultipartResolver multipartResolver(){ StandardServletMultipartResolver resolver = new StandardServletMultipartResolver(); return resolver; } @Bean public SpringResourceTemplateResolver templateResolver(){ SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setPrefix(\"/WEB-INF/templates/\"); resolver.setSuffix(\".html\"); resolver.setCharacterEncoding(\"utf-8\"); resolver.setCacheable(true); resolver.setTemplateMode(TemplateMode.HTML); return resolver; } @Bean public SpringTemplateEngine templateEngine(){ SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setTemplateResolver(templateResolver()); engine.setEnableSpringELCompiler(true); return engine; } @Bean public ThymeleafViewResolver viewResolver(){ ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setCharacterEncoding(\"utf-8\"); resolver.setTemplateEngine(templateEngine()); return resolver; }} 配置文件中与以往不同的是，增加了一个MultipartResolver。 register.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Blog&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt; &lt;style&gt; span.error{ color:red; } div.errors{ background-color: #ffcccc; border: 2px solid red; } label.error{ color:red; } input.error{ background-color: #ffcccc; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎加入Spring的大家庭&lt;/h1&gt; &lt;form method=\"post\" th:object=\"${user}\" enctype=\"multipart/form-data\" &gt; &lt;div class=\"errors\" th:if=\"${#fields.hasErrors('*')}\" &gt; &lt;ul&gt; &lt;li th:each=\"err : ${#fields.errors('*')}\" th:text=\"${err}\" &gt; Input is Incorrect &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;label th:class=\"${#fields.hasErrors('username')} ? 'error' \"&gt; 账号： &lt;/label&gt; &lt;input type=\"text\" th:field=\"*{username}\" th:class=\"${#fields.hasErrors('username')} ? 'error'\"/&gt;&lt;br&gt; &lt;label th:class=\"${#fields.hasErrors('password')} ? 'error' \"&gt; 密码：&lt;/label&gt; &lt;input type=\"password\" th:field=\"*{password}\" th:class=\"${#fields.hasErrors('password')} ? 'error'\" /&gt;&lt;br&gt; &lt;label th:class=\"${#fields.hasErrors('age')} ? 'error' \"&gt;年龄：&lt;/label&gt; &lt;input th:field=\"*{age}\" th:class=\"${#fields.hasErrors('age')} ? 'error'\"/&gt;&lt;br&gt; &lt;label&gt; 图片：&lt;/label&gt; &lt;input type=\"file\" name=\"file\" accept=\"image/jpeg,image/png,image/gif\" &gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\" &gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; IndexController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ooyhao.spring.controller;import com.ooyhao.spring.bean.User;import com.ooyhao.spring.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.multipart.MultipartFile;import javax.validation.Valid;import java.io.File;import java.io.IOException;@Controllerpublic class IndexController { @Autowired private UserService userService; @GetMapping(\"/\") public String home(){ return \"home\"; } @GetMapping(\"/register\") public String toRegister(Model model){ model.addAttribute(\"user\",new User()); return \"register\"; } /*处理表单数据，并验证*/ @PostMapping(\"/register\") public String register(@Valid User user, MultipartFile file, BindingResult bindingResult, Model model) throws IOException { if (bindingResult.hasErrors()){ System.out.println(\"错误数目:\" + bindingResult.getErrorCount()); model.addAttribute(user); return \"register\";//注册失败，重新返回到注册页面 } if (!file.isEmpty()){ file.transferTo( new File(System.currentTimeMillis() +file.getOriginalFilename().substring( file.getOriginalFilename().indexOf(\".\")))); } userService.saveUser(user); return \"redirect:/registerSuccess\"; } @GetMapping(\"/registerSuccess\") public String registerSuccess(){ return \"registerSuccess\"; } @GetMapping(\"/registerFail\") public String registerFail(){ return \"registerFail\"; }} Controller接收前端上传文件普通方式是使用byte[],或是Part接收，如下： 123456@PostMapping(\"/register\")public String register(@RequestPart(\"file\") byte[] file){}@PostMapping(\"/register\")public String register(@RequestPart(\"file\") Part file){} 但是，我们一般是使用SpringMVC的MultipartFile来接收文件。下面看一下这个接口的方法： 1234567891011121314151617181920212223242526272829public interface MultipartFile extends InputStreamSource { String getName(); @Nullable String getOriginalFilename(); @Nullable String getContentType(); boolean isEmpty(); long getSize(); byte[] getBytes() throws IOException; @Override InputStream getInputStream() throws IOException; default Resource getResource() { return new MultipartFileResource(this); } void transferTo(File dest) throws IOException, IllegalStateException; default void transferTo(Path dest) throws IOException, IllegalStateException { FileCopyUtils.copy(getInputStream(), Files.newOutputStream(dest)); }} 效果图： 纯配置文件形式实现文件上传POM依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-07-02&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-07-02 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--导入Servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入SpringMVC依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--hibernate参数校验依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.0.Alpha3&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合Thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-07-02&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; WebInit123456789101112131415161718192021222324252627282930313233343536373839404142public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer { /*配置文件上传的一些参数*/ /** * MultipartConfigElement与 &lt;multipart-config&gt;&lt;/multipart-config&gt; 的默认值相同。 * 都必须配置保存路径。 * @param registration */ @Override protected void customizeRegistration( ServletRegistration.Dynamic registration){ MultipartConfigElement configElement = new MultipartConfigElement( \"D:\\\\data\\\\upload\\\\\", 52428800, 52428800, 0); registration.setMultipartConfig(configElement); } @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[]{ RootConfig.class }; } @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class[]{ ServletConfig.class }; } @Override protected String[] getServletMappings() { return new String[]{ \"/\" }; }} RootConfig.java1234567891011121314package com.ooyhao.spring.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@ComponentScan(basePackages = \"com.ooyhao.spring\", useDefaultFilters = true,excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = EnableWebMvc.class)})@Configurationpublic class RootConfig {} ServletConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ooyhao.spring.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.multipart.MultipartResolver;import org.springframework.web.multipart.support.StandardServletMultipartResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.thymeleaf.spring5.SpringTemplateEngine;import org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver;import org.thymeleaf.spring5.view.ThymeleafViewResolver;import org.thymeleaf.templatemode.TemplateMode;@EnableWebMvc //开启webmvc@ComponentScan(basePackages = \"com.ooyhao.spring.**.controller\")@Configuration //标注为一个配置类public class ServletConfig implements WebMvcConfigurer { @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } /*配置文件上传*/ @Bean public MultipartResolver multipartResolver(){ StandardServletMultipartResolver resolver = new StandardServletMultipartResolver(); return resolver; } /*配置模板解析器*/ @Bean public SpringResourceTemplateResolver templateResolver(){ SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setCacheable(true); resolver.setPrefix(\"/WEB-INF/templates/\"); resolver.setSuffix(\".html\"); resolver.setCharacterEncoding(\"utf-8\"); resolver.setTemplateMode(TemplateMode.HTML); return resolver; } /*配置模板引擎*/ @Bean public SpringTemplateEngine templateEngine(){ SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setEnableSpringELCompiler(true); engine.setTemplateResolver(templateResolver()); return engine; } /*配置视图解析器*/ @Bean public ThymeleafViewResolver thymeleafViewResolver(){ ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setTemplateEngine(templateEngine()); resolver.setCharacterEncoding(\"utf-8\"); return resolver; }} IndexController12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.ooyhao.spring.controller;import com.ooyhao.spring.bean.User;import com.ooyhao.spring.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.multipart.MultipartFile;import javax.validation.Valid;import java.io.File;import java.io.IOException;@Controllerpublic class IndexController { @Autowired private UserService userService; @GetMapping(\"/\") public String home(){ return \"home\"; } @GetMapping(\"/register\") public String toRegister(Model model){ model.addAttribute(\"user\",new User()); return \"register\"; } /*处理表单数据，并验证*/ @PostMapping(\"/register\") public String register(@Valid User user, MultipartFile file, BindingResult bindingResult, Model model) throws IOException { if (bindingResult.hasErrors()){ System.out.println(\"错误数目:\" + bindingResult.getErrorCount()); model.addAttribute(user); return \"register\";//注册失败，重新返回到注册页面 } if (!file.isEmpty()){ file.transferTo(new File(System.currentTimeMillis()+file.getOriginalFilename().substring(file.getOriginalFilename().indexOf(\".\")))); } userService.saveUser(user); return \"redirect:/registerSuccess\"; } @GetMapping(\"/registerSuccess\") public String registerSuccess(){ return \"registerSuccess\"; } @GetMapping(\"/registerFail\") public String registerFail(){ return \"registerFail\"; }} 效果 总结​ 至此，我们已经实现了使用纯Java配置的方式搭建了一个Springweb项目，并且通过配置的方式实现了文件上传。 处理异常使用@ResponseStatus我们看一下下面这个代码： 123456789101112131415161718192021222324/*将参数写到路径上*/@GetMapping(\"/article/{id}\")@ResponseBodypublic Article article(@PathVariable(value = \"id\") Integer id){ Article article = null; try{ article = articleService.findArticleById(id); }catch (ArticleNotFoundException e){ e.printStackTrace(); } return article;}//Service:public Article findArticleById(Integer id) { Article article = articles.get(id); if (article == null){ throw new ArticleNotFoundException(); } return article;}public class ArticleNotFoundException extends RuntimeException {} 当我们访问时，如果findArticleById(id)查询出来为空时，按照当前的代码，会报500错误，但是正常情况我们希望抛出的是404.所以，在定义异常的时候，可以定义为： 12@ResponseStatus(value = HttpStatus.NOT_FOUND,reason = \"Not Found\")public class ArticleNotFoundException extends RuntimeException {} 我们看一下@ResponseStatus注解 12345678910111213@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ResponseStatus { @AliasFor(\"code\") HttpStatus value() default HttpStatus.INTERNAL_SERVER_ERROR; @AliasFor(\"value\") HttpStatus code() default HttpStatus.INTERNAL_SERVER_ERROR; String reason() default \"\";} 测试结果： 编写异常处理方法如上一节中处理异常方法所示，在Handler中既包含正常业务逻辑代码，有包含处理异常的代码，那么有什么方法可以将异常处理代码剥离出来，Handler中只处理业务逻辑。 123456@GetMapping(\"/article/{id}\")@ResponseBodypublic Article article(@PathVariable(value = \"id\") Integer id){ Article article = articleService.findArticleById(id); return article;} 编写异常方法，即在当前controller中添加下列方法： 12345678@ExceptionHandler(ArticleNotFoundException.class)@ResponseBodypublic Map&lt;String,Object&gt; handleNotFoundException(){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",404); map.put(\"message\",\"数据未查询到\"); return map;} 测试结果： 控制器通知处理异常​ 我们都知道，在正常的项目中，我们不可能将所有的处理方法都写在一个Controller中，为了区分业务模块，我们会将所有的controller方法划分在不同的controller类中。如果此时还是使用上述处理方法来处理异常的话，那么我们会发现很多相同的处理异常的代码。Spring3.2之后，有了统一的处理方案就是使用@ControllerAdvice。 https://www.cnblogs.com/yanggb/p/10859907.html 包含@ControllerAdvice的方法可以包含一个或多个如下类型的方法： @ExceptionHandler标注的方法 @InitBinder标注的方法 @ModelAttribute标注的方法 @ExceptionHandler1234567891011/**@ExceptionHandler的作用主要在于声明一个或多个类型的异常，当符合条件的Controller抛出这些异常之后将会对这些异常进行捕获，然后按照其标注的方法的逻辑进行处理，从而改变返回的视图信息。 */ @ControllerAdvicepublic class SpringControllerAdvice { @ExceptionHandler(RuntimeException.class) public ModelAndView runtimeExceptionHandler(RuntimeException e) { e.printStackTrace(); return new ModelAndView(\"error\"); }} @InitBandler12345678910/** 对于@InitBinder，该注解的主要作用是绑定一些自定义的参数。一般情况下我们使用的参数通过@RequestParam，@RequestBody或者@ModelAttribute等注解就可以进行绑定了，但对于一些特殊类型参数，比如Date，它们的绑定Spring是没有提供直接的支持的，我们只能为其声明一个转换器，将request中字符串类型的参数通过转换器转换为Date类型的参数，从而供给@RequestMapping标注的方法使用。*/@ControllerAdvicepublic class SpringControllerAdvice { @InitBinder public void globalInitBinder(WebDataBinder binder) { binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\")); }} @ModelAttribute1234567891011/**关于@ModelAttribute的用法，除了用于方法参数时可以用于转换对象类型的属性之外，其还可以用来进行方法的声明。如果声明在方法上，并且结合@ControllerAdvice，该方法将会在@ControllerAdvice所指定的范围内的所有接口方法执行之前执行，并且@ModelAttribute标注的方法的返回值还可以供给后续会调用的接口方法使用。 */ public class GlobalExceptionHandler { @ModelAttribute //应用到所有@RequestMapping注解方法 //此处将键值对添加到全局，注解了@RequestMapping的方法都可以获得此键值对 public void addUser(Model model) { model.addAttribute(\"msg\", \"此处将键值对添加到全局，注解了@RequestMapping的方法都可以获得此键值对\"); }} 实例123456789101112131415161718192021222324252627@ControllerAdvice public class GlobalExceptionHandler { private final static String ERROR_PAGE = \"error\"; //异常处理 @ExceptionHandler(Exception.class) public ModelAndView handle(Exception e){ ModelAndView mv = new ModelAndView(); mv.addObject(\"message\", e.getMessage()); mv.setViewName(ERROR_PAGE); return mv; } @ModelAttribute //应用到所有@RequestMapping注解方法 //此处将键值对添加到全局，注解了@RequestMapping的方法都可以获得此键值对 public void addUser(Model model) { model.addAttribute(\"msg\", \"此处将键值对添加到全局，注解了@RequestMapping的方法都可以获得此键值对\"); } @InitBinder //应用到所有@RequestMapping注解方法，在其执行之前初始化数据绑定器 //用来设置WebDataBinder，用于自动绑定前台请求参数到Model中。 public void initBinder(WebDataBinder binder) { } } 全局异常处理12345678910111213141516171819/** * 描述: * 类【GlobalExceptionHandler】 * * @author ouYangHao * @create 2019-09-10 10:51 */@ControllerAdvicepublic class GlobalExceptionHandler { @ExceptionHandler(ArticleNotFoundException.class) @ResponseBody public Map&lt;String,Object&gt; handleNotFoundException(){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",404); map.put(\"message\",\"数据未查询到\"); return map; }} 跨重定向请求传递数据使用URL模板进行重定向可以使用下列方式来传递参数 1234567891011121314/*将参数写到路径上*/ @GetMapping(\"/article/{id}\") public String article(@PathVariable(value = \"id\") Integer id, Model model){ model.addAttribute(\"id\",id); model.addAttribute(\"username\",\"ooyhao\"); return \"redirect:/article/id/{id}\";}@RequestMapping(\"/article/id/{id}\")@ResponseBodypublic String articleId(@PathVariable(value = \"id\") Integer id){ return \"id:\"+id;} ​ 但是上述方式只能传递普通参数，当我们需要传递对象的时候，这种方式就无能为力了。此时我们可以使用Spring flash来传递。 代码如下： 12345678910111213141516171819@GetMapping(\"/article/{id}\")public String article(@PathVariable(value = \"id\") Integer id, RedirectAttributes attributes){ Article article = articleService.findArticleById(id); attributes.addAttribute(\"id\",id); attributes.addAttribute(\"username\",\"ooyhao\"); attributes.addFlashAttribute(article); return \"redirect:/article/id/{id}\";}@RequestMapping(\"/article/id/{id}\")@ResponseBodypublic Map&lt;String,Object&gt; articleId(@PathVariable(value = \"id\") Integer id,String username, Model model){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"id\",id); map.put(\"username\",username); map.put(\"article\",model.asMap().get(\"article\")); return map;} 测试结果： 总结：本节实现了文件上传，异常处理，以及跨重定向请求传递参数。","link":"/2020/01/29/SSM/spring4x/7SpringMVC%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"},{"title":"五、SpringMVC起步","text":"​SpringMVC基于模型-视图-通知器(Model-View-Controller,MVC)模式实现的，它能够帮助我们构建像Spring框架那样灵活和松耦合的Web应用程序。 跟踪SpringMVC流程图示： 步骤说明： 用户发送请求到前端控制器(DispatchServlet),该控制器会过滤出哪些请求可以访问servlet、哪些不能访问。就是URL-Pattern的作用，并且会加载SpringMVC.xml配置文件。 前端控制器会找到处理器映射器(HandlerMapping),通过HandlerMapping完成URL到Controller映射的组件，简单来说，就是将在SpringMVC.xml中配置的或者注解的URL与对应的处理类找到并进行存储，用Map&lt;URL,handler&gt;这样的方式来存储。 HandlerMapping有了映射关系，并且找到了URL对应的处理器，HandlerMapping就会将其处理器(Handler)返回，在放回前，会加上很多拦截器。 DispatchServlet拿到Handler之后，找到HandlerAdapter（处理器适配器），通过它来访问处理器，并执行处理器。 执行处理器。 处理器会返回一个ModelAndView对象到HandlerAdapter。 通过HandlerAdapter将ModelAndView对象返回到前端控制器DispatchServlet。 前端控制器请求视图解析器（ViewResolver）去进行视图解析，根据逻辑视图名解析成真真的视图（JSP），其实就是将ModelAndView对象中存放视图的名称进行查找，找到对应的页面形成视图对象。 返回视图对象到前端控制器。 视图渲染，就是将ModelAndView对象中的数据放到Request域中，用来让页面加载数据的。 通过第8步，通过名称找到了对应的页面，通过第10步，request域中有了所需要的数据，那么就可以进行视图渲染了。最后将其返回即可。 这里再附上网上的一张详细的图： web.xml版本的Web项目1. 项目结构 说明：蓝色的Java文件夹，标注为 sources，标有条形圆筒的resources文件夹标注为Resources。 java文件夹用来存放java源码。 resources文件夹用来存放资源文件：如spring配置文件，mapper文件。 webapp目录则用来存放web相关的资源。 File–&gt;Project Structure 2. Pom 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-05-01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-05-01 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json 解析，不配置转化器和引入依赖，返回List则会抛出异常--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-05-01&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3. 生成web.xml项目结构搭建好之后，需要生成web.xml文件并配置。 web.xml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置applicationContext配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置Spring上下文加载器的监听器--&gt; &lt;!--默认加载classpath:下面的applicationContext.xml文件。需要自定义可以配置 &lt;context-param&gt;&lt;/context-param&gt; 进行配合使用 --&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4. 配置Spring和SpringMVCspringmvc.xml配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"com.ooyhao.spring.**.controller\"/&gt; &lt;!--注解驱动，配置controller返回的转换器--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"/&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!--解决@ResponseBody返回中文乱码情况--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" &gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=utf-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--静态页面，如html,css,js,images可以访问--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; spring.xml配置文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=\"com.ooyhao.spring\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 5. 编写逻辑代码User类： 123456789public class User implements Serializable { private String username; private Integer age; private String sex; //noArgsConstructor //allArgsConstructor //getter and setter //toString} UserService类： 123456789@Servicepublic class UserService { public List&lt;User&gt; findAllUsers(){ List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(new User(\"林黛玉\",18,\"女\")); users.add(new User(\"贾宝玉\",20,\"男\")); return users; }} UserController类： 12345678910@Controllerpublic class UserController { @Autowired private UserService userService; @RequestMapping(\"/hello\") @ResponseBody public List&lt;User&gt; hello(){ return userService.findAllUsers(); }} 6. 测试和结果启动程序，并测试 localhost:8080/SpringDemo/getAllUsers 无配置文件的Web项目如果使用过SpringBoot的都知道，SpringBoot可以做到零配置，即没有xml文件，这是因为Spring3.2之后，引入了WebApplicationInitializer。我们可以看一下这个类的源码中： 容在下，拿着这一级英语水平去翻译。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/**Interface to be implemented in Servlet 3.0+ environments in order to configure the {@link ServletContext} programmatically as opposed to (or possibly in conjunction with) the traditional {@code web.xml}-based approach.译： 在servlet3.0版本以上，通过实现接口以编程的方式进行配置ServletContext，这与传统的web.xml的形式近乎相反（不用web.xml文件，同样可以创建一个web应用）Implementations of this SPI will be detected automatically by {@linkSpringServletContainerInitializer}, which itself is bootstrapped automatically by any Servlet 3.0 container.译： 实现了这个SPI，将会被SpringServletContainerInitializer自动识别，并自动启动。See {@linkplain SpringServletContainerInitializer itsJavadoc} for details on this bootstrapping mechanism.译： 可以通过查看SpringServletContainerInitializer文档去了解自启动机制的详情。 &lt;h2&gt;Example&lt;/h2&gt;译：示例 &lt;h3&gt;The traditional, XML-based approach&lt;/h3&gt; 译：传统基于Xml的方式Most Spring users building a web application will need to register Spring's {@code DispatcherServlet}. For reference, in WEB-INF/web.xml, this would typically be done as，follows: 译：大部分Spring用户在构建一个web应用程序都需要去注册一个Spring的前端控制器（DispatchServlet），而其典型的就是在WEB-INF下的web.xml文件中注册。如下： ---&gt;源码不是这样的，源码的尖括号使用了转义字符 * &lt;servlet&gt; * &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; * &lt;servlet-class&gt; * org.springframework.web.servlet.DispatcherServlet * &lt;/servlet-class&gt; * &lt;init-param&gt; * &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; * &lt;param-value&gt;/WEB-INF/spring/dispatcher-config.xml&lt;/param-value&gt; * &lt;/init-param&gt; * &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; * &lt;/servlet&gt; * * &lt;servlet-mapping&gt; * &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; * &lt;url-pattern&gt;/&lt;/url-pattern&gt; * &lt;/servlet-mapping&gt;以上配置就是使用传统的xml配置文件的方式，向servlet容器中注册一个DispatchServlet。The code-based approach with {@code WebApplicationInitializer} * Here is the equivalent {@code DispatcherServlet} registration logic, * {@code WebApplicationInitializer}-style: 译： 通过使用WebApplicationInitializer的基于代码的方式，其与xml是一个相同的注册逻辑。WebApplicationInitializer代码方式： * public class MyWebAppInitializer implements WebApplicationInitializer { * @Override * public void onStartup(ServletContext container) { * XmlWebApplicationContext appContext = new XmlWebApplicationContext(); * appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\"); * * ServletRegistration.Dynamic dispatcher = * container.addServlet(\"dispatcher\", new DispatcherServlet(appContext)); * dispatcher.setLoadOnStartup(1); * dispatcher.addMapping(\"/\"); * } * } * * As an alternative to the above, you can also extend from {@linkorg.springframework.web.servlet.support.AbstractDispatcherServletInitializer}.译：你也可以通过集成自AbstractDispatcherServletInitializer来实现，以上二者任选其一 * As you can see, thanks to Servlet 3.0's new {@link ServletContext#addServlet} method we're actually registering an instance of the {@code DispatcherServlet}, and this means that the {@code DispatcherServlet} can now be treated like any other object receiving constructor injection of its application context in this case. 译：如你所见，正是由于servlet3.0 的新方法(ServletContext#addServlet)出现，我们可以通过它注册一个DispatchServlet的实例了。这也意味着DispatchServlet可以像其他对象那样，通过构造注入的方式接受一个Application ContextThis style is both simpler and more concise. There is no concern for dealing with init-params, etc, just normal JavaBean-style properties and constructor arguments. You are free to create and work with your Spring application contexts as necessary before injecting them into the {@code DispatcherServlet}.译:这种方式既简单又简洁。我们不需要如何去处理初始化参数，等，仅仅需要处理像普通JavaBean那样的属性和构造方法参数。在你必须将他们注入到DispatchServlet中之前，你可以很自由的构建和处理你的spring应用程序。 Most major Spring Web components have been updated to support this style of registration. You'll find that {@code DispatcherServlet}, {@code FrameworkServlet},{@code ContextLoaderListener} and {@code DelegatingFilterProxy} all now support constructor arguments. Even if a component (e.g. non-Spring, other third party) has not been specifically updated for use within {@code WebApplicationInitializers}, they still may be used in any case. The Servlet 3.0 {@code ServletContext} API allows for setting init-params, context-params, etc programmatically. 译：大部分Spring web 组件都进行了更新，以至于能够支持这个注册方式，你可以发现像 DispatcherServlet、FrameworkServlet、ContextLoaderListener和DelegatingFilterProxy ，现在全部都支持构造参数注入。甚至是一些非spring，其他第三方组织的组件在WebApplicationInitializers中使用的没有支持的也会更新，以至于一直可以使用。Servlet3.0 API 也可以通过编程的方式 去设置 初始化参数、容器参数等 A 100% code-based approach to configuration In the example above, {@code WEB-INF/web.xml} was successfully replaced with code in * the form of a {@code WebApplicationInitializer}, but the actual * {@code dispatcher-config.xml} Spring configuration remained XML-based. * {@code WebApplicationInitializer} is a perfect fit for use with Spring's code-based * {@code @Configuration} classes. See @{@link org.springframework.context.annotation.Configuration Configuration} Javadoc for complete details, but the following example demonstrates refactoring to use Spring's {@link org.springframework.web.context.support.AnnotationConfigWebApplicationContext AnnotationConfigWebApplicationContext} in lieu of {@code XmlWebApplicationContext}, and user-defined {@code @Configuration} classes {@code AppConfig} and {@code DispatcherConfig} instead of Spring XML files. 译 ：上面是一个完全由代码的配置方式的案例，web.xml文件已经被一个WebApplicationInitializer 成功取代。当然，实际上 Spring的配置任然保持着基于xml方式，WebApplicationInitializer 是一个更加适合 Spring代码的 配置类。可以查看Configuration的文档，了解完整的详情。但是下面这个例子是使用Spring的 AnnotationConfigWebApplicationContext 来代替XmlWebApplicationContext进行重构的。并且用户通过@Configuration,AppConfig,DispatcherConfig来代替xml配置文件。 This example also goes a bit beyond those above to demonstrate typical configuration of the 'root' application context and registration of the {@code ContextLoaderListener}:译：这个例子比上面的例子更进一步，使用root application context 来重构的典型配置，并且注册ContextLoaderListener * public class MyWebAppInitializer implements WebApplicationInitializer { * @Override * public void onStartup(ServletContext container) { * // Create the 'root' Spring application context 创建root Spring的应用上下文 * AnnotationConfigWebApplicationContext rootContext = * new AnnotationConfigWebApplicationContext(); * rootContext.register(AppConfig.class); * // Manage the lifecycle of the root application context 管理root 应用上下文的生命周期 * container.addListener(new ContextLoaderListener(rootContext)); * // Create the dispatcher servlet's Spring application context // 创建了Servlet的前端控制器的Spring应用上下文 * AnnotationConfigWebApplicationContext dispatcherContext = * new AnnotationConfigWebApplicationContext(); * dispatcherContext.register(DispatcherConfig.class); * // Register and map the dispatcher servlet //注册并且映射前端控制器 * ServletRegistration.Dynamic dispatcher = * container.addServlet(\"dispatcher\", new DispatcherServlet(dispatcherContext)); * dispatcher.setLoadOnStartup(1); * dispatcher.addMapping(\"/\"); * } * } * * As an alternative to the above, you can also extend from {@link org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer}. 你也可以通过集成自AbstractAnnotationConfigDispatcherServletInitializer，以上二者任选其一。 Remember that {@code WebApplicationInitializer} implementations are detected automatically -- so you are free to package them within your application as you see fit. 记住，WebApplicationInitializer 的实现类 都是自动识别的。所以，你可以自由的将他们打包到你认为合适的应用程序中。 Ordering {@code WebApplicationInitializer} execution {@code WebApplicationInitializer} implementations may optionally be annotated at the * class level with Spring's @{@link org.springframework.core.annotation.Order Order} * annotation or may implement Spring's {@link org.springframework.core.Ordered Ordered} * interface. If so, the initializers will be ordered prior to invocation. This provides * a mechanism for users to ensure the order in which servlet container initialization * occurs. Use of this feature is expected to be rare, as typical applications will likely * centralize all container initialization within a single {@code WebApplicationInitializer}. Caveats ：说明、警告web.xml versioning web.xml版本{@code WEB-INF/web.xml} and {@code WebApplicationInitializer} use are not mutually exclusive; for example, web.xml can register one servlet, and a {@code WebApplicationInitializer} can register another. An initializer can even modify registrations performed in {@code web.xml} through methods such as {@link ServletContext#getServletRegistration(String)}. 译：web.xml与WebApplicationInitializer不会相互排斥，例如，web.xml可注册一个Servlet，而WebApplicationInitializer可以注册另一个，后者甚至可以修改在xml中注册的。However, if {@code WEB-INF/web.xml} is present in the application, its {@code version} attribute must be set to \"3.0\" or greater, otherwise {@code ServletContainerInitializer} bootstrapping will be ignored by the servlet container译：然而，如果web.xml存在于应用中，那么它的版本必须在3.0或以上，否则ServletContainerInitializer 自己化启动将会被Servlet容器忽略。 * &lt;h3&gt;Mapping to '/' under Tomcat&lt;/h3&gt;、 在tomcat下映射/ * &lt;p&gt;Apache Tomcat maps its internal {@code DefaultServlet} to \"/\", and on Tomcat versions&lt;= 7.0.14, this servlet mapping cannot be overridden programmatically 7.0.15 fixes this issue. Overriding the \"/\" servlet mapping has also been tested successfully under GlassFish 3.1译：在tomcat7.0.14及以下，tomcat使用其自身的DefaultServlet去映射/,这个Servlet映射将不能被编程方式重写在7.0.15版本。在GlassFish 3.1下， 成功测试出可以重写/这个Servlet映射器。 */public interface WebApplicationInitializer { /** * Configure the given {@link ServletContext} with any servlets, filters, listeners context-params and attributes necessary for initializing this web application. 为你这个web容器配置任何必要的 filter，listener，servlet，及其参数和属性 See examples {@linkplain WebApplicationInitializer above}. * @param servletContext the {@code ServletContext} to initialize * @throws ServletException if any call against the given {@code ServletContext} * throws a {@code ServletException} */ void onStartup(ServletContext servletContext) throws ServletException;} ​ 当你耐心的看完源码和翻译，你大概就知道SpringBoot为何可以做到不用web.xml文件就可以搭建一个web项目。这是使用了WebApplicationInitializer。其实当我们好好学习Spring，会发现曾经SpringBoot那些神秘面纱，慢慢被揭开了。这也是我学了SpringBoot基础之后，又回头学习Spring的原因。废话不多说了，开始搭建我们无配置文件的wen项目。 1. 替代web.xml的InitWebweb.xml这里使用InitWeb.java代替，这里使用的是AbstractAnnotationConfigDispatcherServletInitializer，WebApplicationInitializer的子类，代码如下： 123456789101112131415161718192021public class InitWeb extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class&lt;?&gt;[] getRootConfigClasses() { //配置rootConfig，即原来的applicationContext.xml return new Class[]{RootConfig.class}; } @Override protected Class&lt;?&gt;[] getServletConfigClasses() { //配置ServletConfig，即原来的springmvc.xml return new Class[]{ServletConfig.class}; } @Override protected String[] getServletMappings() { //配置servlet映射，即之前在web.xml中DispatchServlet中配置的。 return new String[]{\"/\"}; }} 2. POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-05-02&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-05-02 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-05-02&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 3. RootConfig12345/*相当于spring.xml*/@ComponentScan(basePackages = \"com.ooyhao.spring\", useDefaultFilters = true,excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = EnableWebMvc.class)})public class RootConfig { 扫描基础包，使用默认的过滤器。即全部都扫描。排除标有Controller注解的。 4. ServletConfig123456789101112131415161718192021222324/*相当于springmvc.xml*/@Configuration@EnableWebMvc@ComponentScan(basePackages = \"com.ooyhao.spring.**.controller\")public class ServletConfig implements WebMvcConfigurer { /*配置JSP视图解析器*/ @Bean public ViewResolver viewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/views/\"); resolver.setSuffix(\".jsp\"); resolver.setExposeContextBeansAsAttributes(true); return resolver; } /*配置静态资源的处理*/ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); }} 可以看出，SpringMvc的配置文件，比前面的spring配置文件多了很多内容。扫描所有的Controller，配置视图解析器，配置静态资源处理。开启webmvc（@EnableWebMvc） @EnableWebMvc 相当于之前在springmvc.xml文件中配置的&lt;mvc:annotation-driven&gt; 5. 编写逻辑代码Article: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Article implements Serializable { private Integer id; private String title; private String content; private String author; public Article() {} public Article(Integer id, String title, String content, String author) { this.id = id; this.title = title; this.content = content; this.author = author; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } @Override public String toString() { return \"Article{\" + \"id=\" + id + \", title='\" + title + '\\'' + \", content='\" + content + '\\'' + \", author='\" + author + '\\'' + '}'; }} ArticleService: 1234567891011121314151617181920@Servicepublic class ArticleService { private static List&lt;Article&gt; articles = new ArrayList&lt;&gt;(); static { Article article1 = new Article(1,\"红楼梦\",\"红楼梦\",\"曹雪芹\"); Article article2 = new Article(2,\"三国演义\",\"三国演义\",\"罗贯中\"); Article article3 = new Article(3,\"水浒传\",\"水浒传\",\"施耐庵\"); Article article4 = new Article(4,\"西游记\",\"西游记\",\"吴承恩\"); articles.add(article1); articles.add(article2); articles.add(article3); articles.add(article4); } public List&lt;Article&gt; findAllArticle(){ return articles; }} ArticleController： 123456789101112@Controllerpublic class ArticleController { @Autowired private ArticleService articleService; @RequestMapping(\"/findAllArticles\") @ResponseBody public List&lt;Article&gt; findAllArticles(){ List&lt;Article&gt; articles = articleService.findAllArticle(); return articles; }} 6. 测试和结果 接受请求参数的输入SpringMVC允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括： 查询参数（Query Parameter） 表单参数（Form Patameter） 路径参数（Path Variable） 将上述示例进行了一定的修改，配合页面进行展示： 1. 查询参数查询参数，我们以分页来做示例： ArticleService: 12345678910111213141516171819202122232425262728293031@Servicepublic class ArticleService { private static Map&lt;Integer,Article&gt; articles = new HashMap&lt;&gt;(); static { Article article1 = new Article(1,\"红楼梦\",\"林黛玉、贾宝玉\",\"曹雪芹\"); Article article2 = new Article(2,\"三国演义\",\"诸葛亮、刘备\",\"罗贯中\"); Article article3 = new Article(3,\"水浒传\",\"鲁智深、武松\",\"施耐庵\"); Article article4 = new Article(4,\"西游记\",\"孙悟空、猪八戒\",\"吴承恩\"); articles.put(1,article1); articles.put(2,article2); articles.put(3,article3); articles.put(4,article4); } public List&lt;Article&gt; findAllArticle(){ return new ArrayList&lt;&gt;(articles.values()); } public Article findArticleById(Integer id) { return articles.get(id); } public List&lt;Article&gt; findArticleByPage(Integer page, Integer size){ int firstIndex = (page-1) * size; int lastIndex = page * size; return new ArrayList&lt;&gt; (articles.values()).subList(firstIndex,lastIndex); }} ArticleController: 12345678910111213141516@Controllerpublic class ArticleController { @Autowired private ArticleService articleService; @GetMapping(\"/article\") public String article(Model model, @RequestParam(value = \"page\",defaultValue = \"1\") Integer page, @RequestParam(value = \"size\",defaultValue = \"2\") Integer size){ List&lt;Article&gt; articles = articleService.findArticleByPage(page, size); model.addAttribute(\"articles\",articles); return \"articleList\"; }} articleList.jsp 12345678910111213141516171819202122232425262728&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%-- Created by IntelliJ IDEA. User: ouYang Date: 2019/9/1 Time: 11:13 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--文章信息--%&gt; &lt;h1&gt;文章列表&lt;/h1&gt; &lt;c:forEach items=\"${articles}\" var=\"article\"&gt; &lt;ul&gt; &lt;li&gt;ID:&lt;c:out value=\"${article.id}\"/&gt;&lt;/li&gt; &lt;li&gt;标题：&lt;c:out value=\"${article.title}\"/&gt;&lt;/li&gt; &lt;li&gt;内容：&lt;c:out value=\"${article.content}\"/&gt;&lt;/li&gt; &lt;li&gt;作者：&lt;c:out value=\"${article.author}\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 测试及结果： 说明： ​ 请求参数会拼接在请求路径后面使用?隔开，参数和值之间使用=连接。多个参数之间使用&amp;进行拼接。Controller可以通过@RequestParam注解接收，可以设置默认值，当然，也可以省略@RequestParam注解。 2. 通过路径参数ArticleController： 123456789/*将参数写到路径上*/@GetMapping(\"/article/{id}\")public String article(Model model,@PathVariable(\"id\") Integer id){ Article article = articleService.findArticleById(id); List&lt;Article&gt; articles = new ArrayList&lt;&gt;(); articles.add(article); model.addAttribute(\"articles\",articles); return \"articleList\";} 测试及结果： 说明： ​ 可以看出，路径参数与请求参数是不一样的，路径参数是请求地址中的一部分，在Controller中通过@PathVariable注解来注释接受。/article/{id} 在路径上使用{}来标注参数的位置。 3. 处理表单处理表单参数，首先我们需要一个表单，这里以注册为例： register jsp文件： 123456789101112131415161718192021222324&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%-- Created by IntelliJ IDEA. User: ouYang Date: 2019/9/1 Time: 10:29 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎加入Spring的大家庭&lt;/h1&gt; &lt;form method=\"post\" &gt; 用户名：&lt;input name=\"username\" type=\"text\" &gt;&lt;br&gt; 密码：&lt;input name=\"password\" type=\"password\" &gt;&lt;br&gt; 年龄：&lt;input name=\"age\" type=\"number\" &gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 一个普通的表单，使用post请求提交，当我们没有指定action属性的时候，点击提交之后，会使用原地址，即请求表单页面的地址，通过post请求提交，本例中是/register. 表单包括 用户名，密码和年龄三个属性。后台进行相应的Bean接受（User） User: 123456public class User implements Serializable { private String username; private String password; private Integer age; //all/noArgConstructor, getter and setter, toString} UserService: 1234567@Servicepublic class UserService { private static List&lt;User&gt; users = new ArrayList&lt;&gt;(); public void saveUser(User user){ users.add(user); }} IndexController: 123456789101112131415161718192021222324252627282930313233@Controllerpublic class IndexController { @Autowired private UserService userService; @GetMapping(\"/\") public String home(){ return \"home\"; } @GetMapping(\"/register\") public String toRegister(){ return \"register\"; } /*处理表单数据，并验证*/ @PostMapping(\"/register\") public String register(User user){ userService.saveUser(user); return \"redirect:/registerSuccess\"; } @GetMapping(\"/registerSuccess\") public String registerSuccess(){ return \"registerSuccess\"; } @GetMapping(\"/registerFail\") public String registerFail(){ return \"registerFail\"; }} ​ 通过上面代码可以看出，通过get请求类型，请求路径为/register，通过返回逻辑视图名，DispatchServlet将逻辑视图名去查找视图，并渲染返回，就可以进入注册表单页面。显而易见，前端提交的参数会自动填写到User对象中，这就是SpringMVC的强大之处，可以将数据自动与实体进行映射。 注册成功之后就会跳到注册成功的页面： 12345678910&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;注册成功~&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 如下： 但是此时我们可以尝试，在页面不填写任何数据，同样是可以提交成功的，这明显不符合我们的业务要求。所以这里需要进行参数校验。 4. 参数校验首先，我们需要导入一个Jar包 123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.0.Alpha3&lt;/version&gt;&lt;/dependency&gt; 其次我们需要修改我们的实体类 12345678910111213141516public class User implements Serializable { @NotNull @Size(min = 4,max = 20) private String username; @NotNull @Size(min = 6,max = 32) private String password; @NotNull @Min(1) @Max(150) private Integer age; //all/noArgConstructor, getter and setter, toString} 并且需要在Controller的方式接受参数的地方加上@Valid注解，如下： 123456789/*处理表单数据，并验证*/@PostMapping(\"/register\")public String register(@Valid User user, Errors errors){ if (errors.hasErrors()){ return \"redirect:/registerFail\"; } userService.saveUser(user); return \"redirect:/registerSuccess\";} ​ 可以看出这里有个Errors参数，这个参数必须紧跟在@Valid注解之后，并且可以通过它判断参数填写是否正确。因为即使加了@Valid，也无法阻止方法的执行，所以需要手动判断处理。 我们增加一个注册失败的提示页面。 registerFail: 12345678910&lt;%@ taglib prefix=\"c\" uri=\"http://www.springframework.org/tags\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;注册失败，请检查数据是否填写正确~&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 如未按要求填写数据就提交： 4.1 参数检验注解 注解 描述 @AssertFalse 所注解的元素必须是Boolean类型，并且值为false @AssertTrue 所注解的元素必须是Boolean类型，并且值为true @DecimalMax 所注解的元素必须是数字，并且它的值要小于或等于给定的BigDecimalString的值 @DecimalMin 所注解的元素必须是数字，并且它的值要大于或等于给定的BigDecimalString的值 @Digists 所注解的元素必须是数字，并且它的值必须有指定的位数 @Future 所注解的元素的值必须是一个将来的日期 @Max 所注解的元素必须是数字，并且它的值要小于或等于给定的值 @Min 所注解的元素必须是数字，并且它的值要大于或等于给定的值 @NotNull 所注解元素的值必须不能为null @Null 所注解元素的值必须为null @Past 所注解的元素的值必须是一个已过去的日期 @Pattern 所注解的元素的值必须匹配给定的正则表达式 @Size 所注解的元素的值必须是String，集合或数组，并且它的长度要符合给定的范围 5. 本地中的POM 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ooyhao.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-in-action-05-02&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;spring-in-action-05-02 Maven Webapp&lt;/name&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- @ResponseBody自动转JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet参数 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 参数校验 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.0.Alpha3&lt;/version&gt; &lt;/dependency&gt;&lt;!--jsp中使用jstl标签--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-in-action-05-02&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 总结： ​ 这一节主要是将web.xml构建web项目和WebApplicationInitializer构建项目对比，手动搭建一个无xml文件的web项目。同时也揭开了SpringBoot无配置文件启动的神秘面纱。并且连接了三种参数输入的方式。","link":"/2020/01/29/SSM/spring4x/5SpringMVC%E8%B5%B7%E6%AD%A5/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","link":"/tags/JavaSE/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"spring4x","slug":"spring4x","link":"/tags/spring4x/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"nacos","slug":"nacos","link":"/tags/nacos/"},{"name":"sentinel","slug":"sentinel","link":"/tags/sentinel/"},{"name":"gateway","slug":"gateway","link":"/tags/gateway/"},{"name":"feign","slug":"feign","link":"/tags/feign/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"hessian","slug":"hessian","link":"/tags/hessian/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"ribbon","slug":"ribbon","link":"/tags/ribbon/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/tags/rabbitmq/"},{"name":"新冠肺炎","slug":"新冠肺炎","link":"/tags/%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E/"}],"categories":[{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"JavaSE","slug":"基础/JavaSE","link":"/categories/%E5%9F%BA%E7%A1%80/JavaSE/"},{"name":"SSM","slug":"SSM","link":"/categories/SSM/"},{"name":"springboot","slug":"SSM/springboot","link":"/categories/SSM/springboot/"},{"name":"mybatis","slug":"SSM/mybatis","link":"/categories/SSM/mybatis/"},{"name":"spring4x","slug":"SSM/spring4x","link":"/categories/SSM/spring4x/"},{"name":"springcloudbalibaba","slug":"SSM/springcloudbalibaba","link":"/categories/SSM/springcloudbalibaba/"},{"name":"DB","slug":"DB","link":"/categories/DB/"},{"name":"Redis","slug":"DB/Redis","link":"/categories/DB/Redis/"},{"name":"中间件","slug":"中间件","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"hessian","slug":"中间件/hessian","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/hessian/"},{"name":"idea","slug":"tools/idea","link":"/categories/tools/idea/"},{"name":"spring","slug":"SSM/spring","link":"/categories/SSM/spring/"},{"name":"mysql","slug":"DB/mysql","link":"/categories/DB/mysql/"},{"name":"rabbitmq","slug":"中间件/rabbitmq","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"新冠肺炎","slug":"随笔/新冠肺炎","link":"/categories/%E9%9A%8F%E7%AC%94/%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8E/"}]}